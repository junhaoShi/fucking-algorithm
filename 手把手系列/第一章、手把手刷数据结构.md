# 第一章、手把手刷数据结构

1、《算法秘籍》和《刷题笔记》两本 PDF 下载 [ 点这里](https://mp.weixin.qq.com/s/X-fE9sR4BLi6T9pn7xP4pg) 。

2、刷题插件下载及使用手册 [ 点这里 ](https://mp.weixin.qq.com/s/wIxflO1dvXzDlibhEcENcQ) 。

3、公众号菜单栏参与 [ 21 天算法挑战活动 ](https://mp.weixin.qq.com/s/eUG2OOzY3k_ZTz-CFvtv5Q) 。

# 手把手刷链表题目

1、《算法秘籍》和《刷题笔记》两本 PDF 下载 [ 点这里](https://mp.weixin.qq.com/s/X-fE9sR4BLi6T9pn7xP4pg) 。

2、刷题插件下载及使用手册 [ 点这里 ](https://mp.weixin.qq.com/s/wIxflO1dvXzDlibhEcENcQ) 。

3、公众号菜单栏参与 [ 21 天算法挑战活动 ](https://mp.weixin.qq.com/s/eUG2OOzY3k_ZTz-CFvtv5Q) 。

## 一文搞懂单链表的六大解题套路


读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 21. 合并两个有序链表（简单） ](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

[ 23. 合并K个升序链表（困难） ](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

[ 141. 环形链表（简单） ](https://leetcode-cn.com/problems/linked-list-cycle/)

[ 142. 环形链表 II（中等） ](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

[ 876. 链表的中间结点（简单） ](https://leetcode-cn.com/problems/middle-of-the-linked-
list/)

[ 160. 相交链表（简单） ](https://leetcode-cn.com/problems/intersection-of-two-linked-
lists/)

[ 19. 删除链表的倒数第 N 个结点（中等） ](https://leetcode-cn.com/problems/remove-nth-node-
from-end-of-list/)

**———–**

上次在视频号直播，跟大家说到单链表有很多巧妙的操作，本文就总结一下单链表的基本技巧，每个技巧都对应着至少一道算法题：

1、合并两个有序链表

2、合并 ` k ` 个有序链表

3、寻找单链表的倒数第 ` k ` 个节点

4、寻找单链表的中点

5、判断单链表是否包含环并找出环起点

6、判断两个单链表是否相交并找出交点

这些解法都用到了双指针技巧，所以说对于单链表相关的题目，双指针的运用是非常广泛的，下面我们就来一个一个看。

### 合并两个有序链表

这是最基本的链表技巧，力扣第 21 题「合并两个有序链表」就是这个问题：

![](https://labuladong.gitee.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/title.jpg)

给你输入两个有序链表，请你把他俩合并成一个新的有序链表，函数签名如下：

```java
    ListNode mergeTwoLists(ListNode l1, ListNode l2);

```

这题比较简单，我们直接看解法：

```java
    ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        // 虚拟头结点
        ListNode dummy = new ListNode(-1), p = dummy;
        ListNode p1 = l1, p2 = l2;
        
        while (p1 != null && p2 != null) {
            // 比较 p1 和 p2 两个指针
            // 将值较小的的节点接到 p 指针
            if (p1.val > p2.val) {
                p.next = p2;
                p2 = p2.next;
            } else {
                p.next = p1;
                p1 = p1.next;
            }
            // p 指针不断前进
            p = p.next;
        }
        
        if (p1 != null) {
            p.next = p1;
        }
        
        if (p2 != null) {
            p.next = p2;
        }
        
        return dummy.next;
    }

```

我们的 while 循环每次比较 ` p1 ` 和 ` p2 ` 的大小，把较小的节点接到结果链表上：

![](https://labuladong.gitee.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/1.gif)

这个算法的逻辑类似于「拉拉链」， ` l1, l2 ` 类似于拉链两侧的锯齿，指针 ` p ` 就好像拉链的拉索，将两个有序链表合并。

**代码中还用到一个链表的算法题中是很常见的「虚拟头结点」技巧，也就是` dummy ` 节点 ** 。你可以试试，如果不使用 ` dummy `虚拟节点，代码会复杂很多，而有了 ` dummy ` 节点这个占位符，可以避免处理空指针的情况，降低代码的复杂性。

### 合并 k 个有序链表

看下力扣第 23 题「合并K个升序链表」：

![](https://labuladong.gitee.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/title2.jpg)

函数签名如下：

```java
    ListNode mergeKLists(ListNode[] lists);

```

合并 ` k ` 个有序链表的逻辑类似合并两个有序链表，难点在于，如何快速得到 ` k ` 个节点中的最小节点，接到结果链表上？

这里我们就要用到 [ 优先级队列（二叉堆） ](https://labuladong.gitee.io/algo/2/19/50/) 这种数据结构，把链表节点放入一个最小堆，就可以每次获得 ` k `个节点中的最小节点：

```java
    ListNode mergeKLists(ListNode[] lists) {
        if (lists.length == 0) return null;
        // 虚拟头结点
        ListNode dummy = new ListNode(-1);
        ListNode p = dummy;
        // 优先级队列，最小堆
        PriorityQueue<ListNode> pq = new PriorityQueue<>(
            lists.length, (a, b)->(a.val - b.val));
        // 将 k 个链表的头结点加入最小堆
        for (ListNode head : lists) {
            if (head != null)
                pq.add(head);
        }
    
        while (!pq.isEmpty()) {
            // 获取最小节点，接到结果链表中
            ListNode node = pq.poll();
            p.next = node;
            if (node.next != null) {
                pq.add(node.next);
            }
            // p 指针不断前进
            p = p.next;
        }
        return dummy.next;
    }

```

这个算法是面试常考题，它的时间复杂度是多少呢？

优先队列 ` pq ` 中的元素个数最多是 ` k ` ，所以一次 ` poll ` 或者 ` add ` 方法的时间复杂度是 ` O(logk) `；所有的链表节点都会被加入和弹出 ` pq ` ， **所以算法整体的时间复杂度是` O(Nlogk) ` ，其中 ` k ` 是链表的条数， ` N `是这些链表的节点总数 ** 。

### 单链表的倒数第 k 个节点

从前往后寻找单链表的第 ` k ` 个节点很简单，一个 for 循环遍历过去就找到了，但是如何寻找从后往前数的第 ` k ` 个节点呢？

那你可能说，假设链表有 ` n ` 个节点，倒数第 ` k ` 个节点就是正数第 ` n - k ` 个节点，不也是一个 for 循环的事儿吗？

是的，但是算法题一般只给你一个 ` ListNode ` 头结点代表一条单链表，你不能直接得出这条链表的长度 ` n ` ，而需要先遍历一遍链表算出 ` n
` 的值，然后再遍历链表计算第 ` n - k ` 个节点。

也就是说，这个解法需要遍历两次链表才能得到出倒数第 ` k ` 个节点。

那么，我们能不能 **只遍历一次链表** ，就算出倒数第 ` k `个节点？可以做到的，如果是面试问到这道题，面试官肯定也是希望你给出只需遍历一次链表的解法。

这个解法就比较巧妙了，假设 ` k = 2 ` ，思路如下：

首先，我们先让一个指针 ` p1 ` 指向链表的头节点 ` head ` ，然后走 ` k ` 步：

![](https://labuladong.gitee.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/1.jpeg)

现在的 ` p1 ` ，只要再走 ` n - k ` 步，就能走到链表末尾的空指针了对吧？

趁这个时候，再用一个指针 ` p2 ` 指向链表头节点 ` head ` ：

![](https://labuladong.gitee.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/2.jpeg)

接下来就很显然了，让 ` p1 ` 和 ` p2 ` 同时向前走， ` p1 ` 走到链表末尾的空指针时走了 ` n - k ` 步， ` p2 ` 也走了
` n - k ` 步，也就是链表的倒数第 ` k ` 个节点：

![](https://labuladong.gitee.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/3.jpeg)

这样，只遍历了一次链表，就获得了倒数第 ` k ` 个节点 ` p2 ` 。

上述逻辑的代码如下：

```java
    // 返回链表的倒数第 k 个节点
    ListNode findFromEnd(ListNode head, int k) {
        ListNode p1 = head;
        // p1 先走 k 步
        for (int i = 0; i < k; i++) {
            p1 = p1.next;
        }
        ListNode p2 = head;
        // p1 和 p2 同时走 n - k 步
        while (p1 != null) {
            p2 = p2.next;
            p1 = p1.next;
        }
        // p2 现在指向第 n - k 个节点
        return p2;
    }

```

当然，如果用 big O 表示法来计算时间复杂度，无论遍历一次链表和遍历两次链表的时间复杂度都是 ` O(N) ` ，但上述这个算法更有技巧性。

很多链表相关的算法题都会用到这个技巧，比如说力扣第 19 题「删除链表的倒数第 N 个结点」：

![](https://labuladong.gitee.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/title3.jpg)

我们直接看解法代码：

```java
    // 主函数
    public ListNode removeNthFromEnd(ListNode head, int n) {
        // 虚拟头结点
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        // 删除倒数第 n 个，要先找倒数第 n + 1 个节点
        ListNode x = findFromEnd(dummy, n + 1);
        // 删掉倒数第 n 个节点
        x.next = x.next.next;
        return dummy.next;
    }
        
    private ListNode findFromEnd(ListNode head, int k) {
        // 代码见上文
    }

```

这个逻辑就很简单了，要删除倒数第 ` n ` 个节点，就得获得倒数第 ` n + 1 ` 个节点的引用，可以用我们实现的 ` findFromEnd `来操作。

不过注意我们又使用了虚拟头结点的技巧，也是为了防止出现空指针的情况，比如说链表总共有 5 个节点，题目就让你删除倒数第 5 个节点，也就是第一个节点，那按照算法逻辑，应该首先找到倒数第 6
个节点。但第一个节点前面已经没有节点了，这就会出错。

但有了我们虚拟节点 ` dummy ` 的存在，就避免了这个问题，能够对这种情况进行正确的删除。

### 单链表的中点

这个技巧在前文 [ 双指针技巧汇总 ](https://labuladong.gitee.io/algo/2/20/55/) 写过，如果看过的读者可以跳过。

力扣第 876 题「链表的中间结点」就是这个题目，问题的关键也在于我们无法直接得到单链表的长度 ` n ` ，常规方法也是先遍历链表计算 ` n `，再遍历一次得到第 ` n / 2 ` 个节点，也就是中间节点。

如果想一次遍历就得到中间节点，也需要耍点小聪明，使用「快慢指针」的技巧：

我们让两个指针 ` slow ` 和 ` fast ` 分别指向链表头结点 ` head ` 。

**每当慢指针` slow ` 前进一步，快指针 ` fast ` 就前进两步，这样，当 ` fast ` 走到链表末尾时， ` slow `就指向了链表中点 ** 。

上述思路的代码实现如下：

```java
    ListNode middleNode(ListNode head) {
        // 快慢指针初始化指向 head
        ListNode slow = head, fast = head;
        // 快指针走到末尾时停止
        while (fast != null && fast.next != null) {
            // 慢指针走一步，快指针走两步
            slow = slow.next;
            fast = fast.next.next;
        }
        // 慢指针指向中点
        return slow;
    }

```

需要注意的是，如果链表长度为偶数，也就是说中点有两个的时候，我们这个解法返回的节点是靠后的那个节点。

另外，这段代码稍加修改就可以直接用到判断链表成环的算法题上。

### 判断链表是否包含环

这个技巧也在前文 [ 双指针技巧汇总 ](https://labuladong.gitee.io/algo/2/20/55/) 写过，如果看过的读者可以跳过。

判断链表是否包含环属于经典问题了，解决方案也是用快慢指针：

每当慢指针 ` slow ` 前进一步，快指针 ` fast ` 就前进两步。

如果 ` fast ` 最终遇到空指针，说明链表中没有环；如果 ` fast ` 最终和 ` slow ` 相遇，那肯定是 ` fast ` 超过了 `slow ` 一圈，说明链表中含有环。

只需要把寻找链表中点的代码稍加修改就行了：

```java
    boolean hasCycle(ListNode head) {
        // 快慢指针初始化指向 head
        ListNode slow = head, fast = head;
        // 快指针走到末尾时停止
        while (fast != null && fast.next != null) {
            // 慢指针走一步，快指针走两步
            slow = slow.next;
            fast = fast.next.next;
            // 快慢指针相遇，说明含有环
            if (slow == fast) {
                return true;
            }
        }
        // 不包含环
        return false;
    }

```

当然，这个问题还有进阶版：如果链表中含有环，如何计算这个环的起点？

这里简单提一下解法：

```java
    ListNode detectCycle(ListNode head) {
        ListNode fast, slow;
        fast = slow = head;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
            if (fast == slow) break;
        }
        // 上面的代码类似 hasCycle 函数
        if (fast == null || fast.next == null) {
            // fast 遇到空指针说明没有环
            return null;
        }
    
        // 重新指向头结点
        slow = head;
        // 快慢指针同步前进，相交点就是环起点
        while (slow != fast) {
            fast = fast.next;
            slow = slow.next;
        }
        return slow;
    }

```

可以看到，当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。

前文 [ 双指针技巧汇总 ](https://labuladong.gitee.io/algo/2/20/55/) 详细解释了其中的原理，这里简单说一下。

我们假设快慢指针相遇时，慢指针 ` slow ` 走了 ` k ` 步，那么快指针 ` fast ` 一定走了 ` 2k ` 步：

![](https://labuladong.gitee.io/algo/images/%E5%8F%8C%E6%8C%87%E9%92%88/3.jpeg)

` fast ` 一定比 ` slow ` 多走了 ` k ` 步，这多走的 ` k ` 步其实就是 ` fast ` 指针在环里转圈圈，所以 ` k `的值就是环长度的「整数倍」。

假设相遇点距环的起点的距离为 ` m ` ，那么结合上图的 ` slow ` 指针，环的起点距头结点 ` head ` 的距离为 ` k - m `，也就是说如果从 ` head ` 前进 ` k - m ` 步就能到达环起点。

巧的是，如果从相遇点继续前进 ` k - m ` 步，也恰好到达环起点。因为结合上图的 ` fast ` 指针，从相遇点开始走k步可以转回到相遇点，那走 `k - m ` 步肯定就走到环起点了：

![](https://labuladong.gitee.io/algo/images/%E5%8F%8C%E6%8C%87%E9%92%88/2.jpeg)

所以，只要我们把快慢指针中的任一个重新指向 ` head ` ，然后两个指针同速前进， ` k - m ` 步后一定会相遇，相遇之处就是环的起点了。

### 两个链表是否相交

这个问题有意思，也是力扣第 160 题「相交链表」函数签名如下：

```java
    ListNode getIntersectionNode(ListNode headA, ListNode headB);

```

给你输入两个链表的头结点 ` headA ` 和 ` headB ` ，这两个链表可能存在相交。

如果相交，你的算法应该返回相交的那个节点；如果没相交，则返回 null。

比如题目给我们举的例子，如果输入的两个链表如下图：

![](https://labuladong.gitee.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/4.png)

那么我们的算法应该返回 ` c1 ` 这个节点。

这个题直接的想法可能是用 ` HashSet ` 记录一个链表的所有节点，然后和另一条链表对比，但这就需要额外的空间。

如果不用额外的空间，只使用两个指针，你如何做呢？

难点在于，由于两条链表的长度可能不同，两条链表之间的节点无法对应：

![](https://labuladong.gitee.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/5.jpeg)

如果用两个指针 ` p1 ` 和 ` p2 ` 分别在两条链表上前进，并不能 **同时** 走到公共节点，也就无法得到相交节点 ` c1 ` 。

**解决这个问题的关键是，通过某些方式，让` p1 ` 和 ` p2 ` 能够同时到达相交节点 ` c1 ` ** 。

所以，我们可以让 ` p1 ` 遍历完链表 ` A ` 之后开始遍历链表 ` B ` ，让 ` p2 ` 遍历完链表 ` B ` 之后开始遍历链表 ` A
` ，这样相当于「逻辑上」两条链表接在了一起。

如果这样进行拼接，就可以让 ` p1 ` 和 ` p2 ` 同时进入公共部分，也就是同时到达相交节点 ` c1 ` ：

![](https://labuladong.gitee.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/6.jpeg)

那你可能会问，如果说两个链表没有相交点，是否能够正确的返回 null 呢？

这个逻辑可以覆盖这种情况的，相当于 ` c1 ` 节点是 null 空指针嘛，可以正确返回 null。

按照这个思路，可以写出如下代码：

```java
    ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        // p1 指向 A 链表头结点，p2 指向 B 链表头结点
        ListNode p1 = headA, p2 = headB;
        while (p1 != p2) {
            // p1 走一步，如果走到 A 链表末尾，转到 B 链表
            if (p1 == null) p1 = headB;
            else            p1 = p1.next;
            // p2 走一步，如果走到 B 链表末尾，转到 A 链表
            if (p2 == null) p2 = headA;
            else            p2 = p2.next;
        }
        return p1;
    }

```

这样，这道题就解决了，空间复杂度为 ` O(1) ` ，时间复杂度为 ` O(N) ` 。

以上就是单链表的所有技巧，希望对你有启发。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


## 递归反转链表的一部分


读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 206. 反转链表（简单） ](https://leetcode-cn.com/problems/reverse-linked-list/)

[ 92. 反转链表II（中等） ](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

**———–**

反转单链表的迭代实现不是一个困难的事情，但是递归实现就有点难度了，如果再加一点难度，让你仅仅反转单链表中的一部分，你是否能 **够递归实现** 呢？

本文就来由浅入深，step by step 地解决这个问题。如果你还不会递归地反转单链表也没关系， **本文会从递归反转整个单链表开始拓展**，只要你明白单链表的结构，相信你能够有所收获。

```java
    // 单链表节点的结构
    public class ListNode {
        int val;
        ListNode next;
        ListNode(int x) { val = x; }
    }

```

什么叫反转单链表的一部分呢，就是给你一个索引区间，让你把单链表中这部分元素反转，其他部分不变：

![](https://labuladong.gitee.io/algo/images/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/title.png)

**注意这里的索引是从 1 开始的** 。迭代的思路大概是：先用一个 for 循环找到第 ` m ` 个位置，然后再用一个 for 循环将 ` m ` 和
` n ` 之间的元素反转。但是我们的递归解法不用一个 for 循环，纯递归实现反转。

迭代实现思路看起来虽然简单，但是细节问题很多的，反而不容易写对。相反，递归实现就很简洁优美，下面就由浅入深，先从反转整个单链表说起。

### 一、递归反转整个链表

这也是力扣第 206 题「反转链表」，递归反转单链表的算法可能很多读者都听说过，这里详细介绍一下，直接看代码实现：

```java
    ListNode reverse(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode last = reverse(head.next);
        head.next.next = head;
        head.next = null;
        return last;
    }

```

看起来是不是感觉不知所云，完全不能理解这样为什么能够反转链表？这就对了，这个算法常常拿来显示递归的巧妙和优美，我们下面来详细解释一下这段代码。

**对于递归算法，最重要的就是明确递归函数的定义** 。具体来说，我们的 ` reverse ` 函数定义是这样的：

**输入一个节点` head ` ，将「以 ` head ` 为起点」的链表反转，并返回反转之后的头结点 ** 。

明白了函数的定义，再来看这个问题。比如说我们想反转这个链表：

![](https://labuladong.gitee.io/algo/images/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/1.jpg)

那么输入 ` reverse(head) ` 后，会在这里进行递归：

```java
    ListNode last = reverse(head.next);

```

不要跳进递归（你的脑袋能压几个栈呀？），而是要根据刚才的函数定义，来弄清楚这段代码会产生什么结果：

![](https://labuladong.gitee.io/algo/images/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/2.jpg)

这个 ` reverse(head.next) ` 执行完成后，整个链表就成了这样：

![](https://labuladong.gitee.io/algo/images/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/3.jpg)

并且根据函数定义， ` reverse ` 函数会返回反转之后的头结点，我们用变量 ` last ` 接收了。

现在再来看下面的代码：

```java
    head.next.next = head;

```

![](https://labuladong.gitee.io/algo/images/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/4.jpg)

接下来：

```java
    head.next = null;
    return last;

```

![](https://labuladong.gitee.io/algo/images/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/5.jpg)

神不神奇，这样整个链表就反转过来了！递归代码就是这么简洁优雅，不过其中有两个地方需要注意：

1、递归函数要有 base case，也就是这句：

```java
    if (head.next == null) return head;

```

意思是如果链表只有一个节点的时候反转也是它自己，直接返回即可。

2、当链表递归反转之后，新的头结点是 ` last ` ，而之前的 ` head ` 变成了最后一个节点，别忘了链表的末尾要指向 null：

```java
    head.next = null;

```

理解了这两点后，我们就可以进一步深入了，接下来的问题其实都是在这个算法上的扩展。

### 二、反转链表前 N 个节点

这次我们实现一个这样的函数：

```java
    // 将链表的前 n 个节点反转（n <= 链表长度）
    ListNode reverseN(ListNode head, int n)

```

比如说对于下图链表，执行 ` reverseN(head, 3) ` ：

![](https://labuladong.gitee.io/algo/images/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/6.jpg)

解决思路和反转整个链表差不多，只要稍加修改即可：

```java
    ListNode successor = null; // 后驱节点
    
    // 反转以 head 为起点的 n 个节点，返回新的头结点
    ListNode reverseN(ListNode head, int n) {
        if (n == 1) {
            // 记录第 n + 1 个节点
            successor = head.next;
            return head;
        }
        // 以 head.next 为起点，需要反转前 n - 1 个节点
        ListNode last = reverseN(head.next, n - 1);
    
        head.next.next = head;
        // 让反转之后的 head 节点和后面的节点连起来
        head.next = successor;
        return last;
    }

```

具体的区别：

1、base case 变为 ` n == 1 ` ，反转一个元素，就是它本身，同时 **要记录后驱节点** 。

2、刚才我们直接把 ` head.next ` 设置为 null，因为整个链表反转后原来的 ` head ` 变成了整个链表的最后一个节点。但现在 `head ` 节点在递归反转之后不一定是最后一个节点了，所以要记录后驱 ` successor ` （第 n + 1 个节点），反转之后将 ` head `连接上。

![](https://labuladong.gitee.io/algo/images/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/7.jpg)

OK，如果这个函数你也能看懂，就离实现「反转一部分链表」不远了。

### 三、反转链表的一部分

现在解决我们最开始提出的问题，给一个索引区间 ` [m,n] ` （索引从 1 开始），仅仅反转区间中的链表元素。

```java
    ListNode reverseBetween(ListNode head, int m, int n)

```

首先，如果 ` m == 1 ` ，就相当于反转链表开头的 ` n ` 个元素嘛，也就是我们刚才实现的功能：

```java
    ListNode reverseBetween(ListNode head, int m, int n) {
        // base case
        if (m == 1) {
            // 相当于反转前 n 个元素
            return reverseN(head, n);
        }
        // ...
    }

```

如果 ` m != 1 ` 怎么办？如果我们把 ` head ` 的索引视为 1，那么我们是想从第 ` m ` 个元素开始反转对吧；如果把 `head.next ` 的索引视为 1 呢？那么相对于 ` head.next ` ，反转的区间应该是从第 ` m - 1 ` 个元素开始的；那么对于 `head.next.next ` 呢……

区别于迭代思想，这就是递归思想，所以我们可以完成代码：

```java
    ListNode reverseBetween(ListNode head, int m, int n) {
        // base case
        if (m == 1) {
            return reverseN(head, n);
        }
        // 前进到反转的起点触发 base case
        head.next = reverseBetween(head.next, m - 1, n - 1);
        return head;
    }

```

至此，我们的最终大 BOSS 就被解决了。

### 四、最后总结

递归的思想相对迭代思想，稍微有点难以理解，处理的技巧是：不要跳进递归，而是利用明确的定义来实现算法逻辑。

处理看起来比较困难的问题，可以尝试化整为零，把一些简单的解法进行修改，解决困难的问题。

值得一提的是，递归操作链表并不高效。和迭代解法相比，虽然时间复杂度都是 O(N)，但是迭代解法的空间复杂度是 O(1)，而递归解法需要堆栈，空间复杂度是 O(N)
。所以递归操作链表可以作为对递归算法的练习或者拿去和小伙伴装逼，但是考虑效率的话还是使用迭代算法更好。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


## 如何 K 个一组反转链表


读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 25. K个一组翻转链表（困难） ](https://leetcode-cn.com/problems/reverse-nodes-in-k-
group)

**———–**

之前的文章「递归反转链表的一部分」讲了如何递归地反转一部分链表，有读者就问如何迭代地反转链表，这篇文章解决的问题也需要反转链表的函数，我们不妨就用迭代方式来解决。

本文要解决「K 个一组反转链表」，题目不难理解：

![](https://labuladong.gitee.io/algo/images/kgroup/title.png)

这个问题经常在面经中看到，而且 LeetCode 上难度是 Hard，它真的有那么难吗？

对于基本数据结构的算法问题其实都不难，只要结合特点一点点拆解分析，一般都没啥难点。下面我们就来拆解一下这个问题。

### 一、分析问题

首先，前文 [ 学习数据结构的框架思维 ](https://labuladong.gitee.io/algo/1/2/) 提到过，链表是一种兼具递归和迭代性质的数据结构，认真思考一下可以发现
**这个问题具有递归性质** 。

什么叫递归性质？直接上图理解，比如说我们对这个链表调用 ` reverseKGroup(head, 2) ` ，即以 2 个节点为一组反转链表：

![](https://labuladong.gitee.io/algo/images/kgroup/1.jpg)

如果我设法把前 2 个节点反转，那么后面的那些节点怎么处理？后面的这些节点也是一条链表，而且规模（长度）比原来这条链表小，这就叫 **子问题** 。

![](https://labuladong.gitee.io/algo/images/kgroup/2.jpg)

我们可以直接递归调用 ` reverseKGroup(cur, 2) ` ，因为子问题和原问题的结构完全相同，这就是所谓的递归性质。

发现了递归性质，就可以得到大致的算法流程：

**1、先反转以` head ` 开头的 ` k ` 个元素 ** 。

![](https://labuladong.gitee.io/algo/images/kgroup/3.jpg)

**2、将第` k + 1 ` 个元素作为 ` head ` 递归调用 ` reverseKGroup ` 函数 ** 。

![](https://labuladong.gitee.io/algo/images/kgroup/4.jpg)

**3、将上述两个过程的结果连接起来** 。

![](https://labuladong.gitee.io/algo/images/kgroup/5.jpg)

整体思路就是这样了，最后一点值得注意的是，递归函数都有个 base case，对于这个问题是什么呢？

题目说了，如果最后的元素不足 ` k ` 个，就保持不变。这就是 base case，待会会在代码里体现。

### 二、代码实现

首先，我们要实现一个 ` reverse ` 函数反转一个区间之内的元素。在此之前我们再简化一下，给定链表头结点，如何反转整个链表？

```java
    // 反转以 a 为头结点的链表
    ListNode reverse(ListNode a) {
        ListNode pre, cur, nxt;
        pre = null; cur = a; nxt = a;
        while (cur != null) {
            nxt = cur.next;
            // 逐个结点反转
            cur.next = pre;
            // 更新指针位置
            pre = cur;
            cur = nxt;
        }
        // 返回反转后的头结点
        return pre;
    }

```

![](https://labuladong.gitee.io/algo/images/kgroup/8.gif)

这次使用迭代思路来实现的，借助动画理解应该很容易。

「反转以 ` a ` 为头结点的链表」其实就是「反转 ` a ` 到 null 之间的结点」，那么如果让你「反转 ` a ` 到 ` b `之间的结点」，你会不会？

只要更改函数签名，并把上面的代码中 ` null ` 改成 ` b ` 即可：

```java
    /** 反转区间 [a, b) 的元素，注意是左闭右开 */
    ListNode reverse(ListNode a, ListNode b) {
        ListNode pre, cur, nxt;
        pre = null; cur = a; nxt = a;
        // while 终止的条件改一下就行了
        while (cur != b) {
            nxt = cur.next;
            cur.next = pre;
            pre = cur;
            cur = nxt;
        }
        // 返回反转后的头结点
        return pre;
    }

```

现在我们迭代实现了反转部分链表的功能，接下来就按照之前的逻辑编写 ` reverseKGroup ` 函数即可：

```java
    ListNode reverseKGroup(ListNode head, int k) {
        if (head == null) return null;
        // 区间 [a, b) 包含 k 个待反转元素
        ListNode a, b;
        a = b = head;
        for (int i = 0; i < k; i++) {
            // 不足 k 个，不需要反转，base case
            if (b == null) return head;
            b = b.next;
        }
        // 反转前 k 个元素
        ListNode newHead = reverse(a, b);
        // 递归反转后续链表并连接起来
        a.next = reverseKGroup(b, k);
        return newHead;
    }

```

解释一下 ` for ` 循环之后的几句代码，注意 ` reverse ` 函数是反转区间 ` [a, b) ` ，所以情形是这样的：

![](https://labuladong.gitee.io/algo/images/kgroup/6.jpg)

递归部分就不展开了，整个函数递归完成之后就是这个结果，完全符合题意：

![](https://labuladong.gitee.io/algo/images/kgroup/7.jpg)

### 三、最后说两句

从阅读量上看，基本数据结构相关的算法文章看的人都不多，我想说这是要吃亏的。

大家喜欢看动态规划相关的问题，可能因为面试很常见，但就我个人理解，很多算法思想都是源于数据结构的。我们公众号的成名之作之一，「学习数据结构的框架思维」就提过，什么动规、回溯、分治算法，其实都是树的遍历，树这种结构它不就是个多叉链表吗？你能处理基本数据结构的问题，解决一般的算法问题应该也不会太费事。

那么如何分解问题、发现递归性质呢？这个只能多练习，也许后续可以专门写一篇文章来探讨一下，本文就到此为止吧，希望对大家有帮助！

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


## 如何判断回文链表


读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 234. 回文链表（简单） ](https://leetcode-cn.com/problems/palindrome-linked-list)

**———–**

我们之前有两篇文章写了回文串和回文序列相关的问题。

**寻找** 回文串的核心思想是从中心向两端扩展：

```java
    string palindrome(string& s, int l, int r) {
        // 防止索引越界
        while (l >= 0 && r < s.size()
                && s[l] == s[r]) {
            // 向两边展开
            l--; r++;
        }
        // 返回以 s[l] 和 s[r] 为中心的最长回文串
        return s.substr(l + 1, r - l - 1);
    }

```

因为回文串长度可能为奇数也可能是偶数，长度为奇数时只存在一个中心点，而长度为偶数时存在两个中心点，所以上面这个函数需要传入 ` l ` 和 ` r ` 。

而 **判断** 一个字符串是不是回文串就简单很多，不需要考虑奇偶情况，只需要「双指针技巧」，从两端向中间逼近即可：

```java
    bool isPalindrome(string s) {
        int left = 0, right = s.length - 1;
        while (left < right) {
            if (s[left] != s[right])
                return false;
            left++; right--;
        }
        return true;
    }

```

以上代码很好理解吧， **因为回文串是对称的，所以正着读和倒着读应该是一样的，这一特点是解决回文串问题的关键** 。

下面扩展这一最简单的情况，来解决：如何判断一个「单链表」是不是回文。

### 一、判断回文单链表

输入一个单链表的头结点，判断这个链表中的数字是不是回文：

```java
    /**
     * 单链表节点的定义：
     * public class ListNode {
     *     int val;
     *     ListNode next;
     * }
     */
    
    boolean isPalindrome(ListNode head);
    
    输入: 1->2->null
    输出: false
    
    输入: 1->2->2->1->null
    输出: true

```

这道题的关键在于，单链表无法倒着遍历，无法使用双指针技巧。

那么最简单的办法就是，把原始链表反转存入一条新的链表，然后比较这两条链表是否相同。关于如何反转链表，可以参见前文 [ 递归翻转链表的一部分](https://labuladong.gitee.io/algo/2/16/16/) 。

其实， **借助二叉树后序遍历的思路，不需要显式反转原始链表也可以倒序遍历链表** ，下面来具体聊聊。

对于二叉树的几种遍历方式，我们再熟悉不过了：

```java
    void traverse(TreeNode root) {
        // 前序遍历代码
        traverse(root.left);
        // 中序遍历代码
        traverse(root.right);
        // 后序遍历代码
    }

```

在 [ 学习数据结构的框架思维 ](https://labuladong.gitee.io/algo/1/2/) 中说过，链表兼具递归结构，树结构不过是链表的衍生。那么，
**链表其实也可以有前序遍历和后序遍历** ：

```java
    void traverse(ListNode head) {
        // 前序遍历代码
        traverse(head.next);
        // 后序遍历代码
    }

```

这个框架有什么指导意义呢？如果我想正序打印链表中的 ` val ` 值，可以在前序遍历位置写代码；反之，如果想倒序遍历链表，就可以在后序遍历位置操作：

```java
    /* 倒序打印单链表中的元素值 */
    void traverse(ListNode head) {
        if (head == null) return;
        traverse(head.next);
        // 后序遍历代码
        print(head.val);
    }

```

说到这了，其实可以稍作修改，模仿双指针实现回文判断的功能：

```java
    // 左侧指针
    ListNode left;
    
    boolean isPalindrome(ListNode head) {
        left = head;
        return traverse(head);
    }
    
    boolean traverse(ListNode right) {
        if (right == null) return true;
        boolean res = traverse(right.next);
        // 后序遍历代码
        res = res && (right.val == left.val);
        left = left.next;
        return res;
    }

```

这么做的核心逻辑是什么呢？ **实际上就是把链表节点放入一个栈，然后再拿出来，这时候元素顺序就是反的** ，只不过我们利用的是递归函数的堆栈而已。

![](https://labuladong.gitee.io/algo/images/%e5%9b%9e%e6%96%87%e9%93%be%e8%a1%a8/1.gif)

当然，无论造一条反转链表还是利用后序遍历，算法的时间和空间复杂度都是 O(N)。下面我们想想，能不能不用额外的空间，解决这个问题呢？

### 二、优化空间复杂度

更好的思路是这样的：

**1、先通过[ 双指针技巧 ](https://labuladong.gitee.io/algo/2/16/15/) 中的快慢指针来找到链表的中点 ** ：

```java
    ListNode slow, fast;
    slow = fast = head;
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    // slow 指针现在指向链表中点

```

![](https://labuladong.gitee.io/algo/images/%e5%9b%9e%e6%96%87%e9%93%be%e8%a1%a8/1.jpg)

**2、如果` fast ` 指针没有指向 ` null ` ，说明链表长度为奇数， ` slow ` 还要再前进一步 ** ：

```java
    if (fast != null)
        slow = slow.next;

```

![](https://labuladong.gitee.io/algo/images/%e5%9b%9e%e6%96%87%e9%93%be%e8%a1%a8/2.jpg)

**3、从` slow ` 开始反转后面的链表，现在就可以开始比较回文串了 ** ：

```java
    ListNode left = head;
    ListNode right = reverse(slow);
    
    while (right != null) {
        if (left.val != right.val)
            return false;
        left = left.next;
        right = right.next;
    }
    return true;

```

![](https://labuladong.gitee.io/algo/images/%e5%9b%9e%e6%96%87%e9%93%be%e8%a1%a8/3.jpg)

至此，把上面 3 段代码合在一起就高效地解决这个问题了，其中 ` reverse ` 函数很容易实现：

```java
    boolean isPalindrome(ListNode head) {
        ListNode slow, fast;
        slow = fast = head;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        
        if (fast != null)
            slow = slow.next;
        
        ListNode left = head;
        ListNode right = reverse(slow);
        while (right != null) {
            if (left.val != right.val)
                return false;
            left = left.next;
            right = right.next;
        }
        
        return true;
    }
    
    ListNode reverse(ListNode head) {
        ListNode pre = null, cur = head;
        while (cur != null) {
            ListNode next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        }
        return pre;
    }

```

![](https://labuladong.gitee.io/algo/images/kgroup/8.gif)

算法总体的时间复杂度 O(N)，空间复杂度 O(1)，已经是最优的了。

我知道肯定有读者会问：这种解法虽然高效，但破坏了输入链表的原始结构，能不能避免这个瑕疵呢？

其实这个问题很好解决，关键在于得到 ` p, q ` 这两个指针位置：

![](https://labuladong.gitee.io/algo/images/%e5%9b%9e%e6%96%87%e9%93%be%e8%a1%a8/4.jpg)

这样，只要在函数 return 之前加一段代码即可恢复原先链表顺序：

```java
    p.next = reverse(q);

```

篇幅所限，我就不写了，读者可以自己尝试一下。

### 三、最后总结

首先，寻找回文串是从中间向两端扩展，判断回文串是从两端向中间收缩。对于单链表，无法直接倒序遍历，可以造一条新的反转链表，可以利用链表的后序遍历，也可以用栈结构倒序处理单链表。

具体到回文链表的判断问题，由于回文的特殊性，可以不完全反转链表，而是仅仅反转部分链表，将空间复杂度降到 O(1)。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


# 手把手刷二叉树

1、《算法秘籍》和《刷题笔记》两本 PDF 下载 [ 点这里](https://mp.weixin.qq.com/s/X-fE9sR4BLi6T9pn7xP4pg) 。

2、刷题插件下载及使用手册 [ 点这里 ](https://mp.weixin.qq.com/s/wIxflO1dvXzDlibhEcENcQ) 。

3、公众号菜单栏参与 [ 21 天算法挑战活动 ](https://mp.weixin.qq.com/s/eUG2OOzY3k_ZTz-CFvtv5Q) 。

## 手把手带你刷二叉树（纲领篇）


读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 104. 二叉树的最大深度（简单） ](https://leetcode-cn.com/problems/maximum-depth-of-
binary-tree)

[ 543. 二叉树的直径（简单） ](https://leetcode-cn.com/problems/diameter-of-binary-tree)

[ 144. 二叉树的前序遍历（简单） ](https://leetcode-cn.com/problems/binary-tree-preorder-
traversal)

**———–**

PS： [ 刷题插件 ](https://mp.weixin.qq.com/s/OE1zPVPj0V2o82N4HtLQbw)集成了手把手刷二叉树功能，按照公式和套路讲解了 150 道二叉树题目，可手把手带你刷完二叉树分类的题目，迅速掌握递归思维。

公众号历史文章都是按照 [ 学习数据结构和算法的框架思维 ](https://labuladong.gitee.io/algo/1/2/)提出的框架思维来构建的，其中着重强调了二叉树题目的重要性，所以我写了 6 篇手把手刷二叉树系列文章：

* [ 东哥手把手带你刷二叉树（第一期） ](https://labuladong.gitee.io/algo/2/17/21/)
* [ 东哥手把手带你刷二叉树（第二期） ](https://labuladong.gitee.io/algo/2/17/22/)
* [ 东哥手把手带你刷二叉树（第三期） ](https://labuladong.gitee.io/algo/2/17/23/)
* [ 东哥手把手带你刷二叉搜索树（第一期） ](https://labuladong.gitee.io/algo/2/17/24/)
* [ 东哥手把手带你刷二叉搜索树（第二期） ](https://labuladong.gitee.io/algo/2/17/25/)
* [ 东哥手把手带你刷二叉搜索树（第三期） ](https://labuladong.gitee.io/algo/2/17/26/)

本文是一个总纲，对上述文章进行总结，无论你是否看过上述几篇文章，看完本文再去看它们都会对二叉树和递归有更深的认识。

另外，本文中会用题目来举例，但都是最最简单的题目，所以不用担心自己看不懂。我可以帮你从最简单的问题中提炼出所有二叉树题目的共性，并将这些思维反手用到 [
动态规划 ](https://labuladong.gitee.io/algo/3/22/66/) ， [ 回溯算法 ](https://labuladong.gitee.io/algo/4/28/105/) ， [ 分治算法](https://labuladong.gitee.io/algo/4/30/125/) ， [ 图论算法 ](https://labuladong.gitee.io/algo/2/18/34/) 中去，这也是我一直强调框架思维的原因。

### 深入理解前中后序

之前二叉树的文章，总有读者说看不出解法应该用前序中序还是后序，其实原因是你对前中后序的理解还不到位，这里我简单解释一下。

首先，先回顾一下 [ 学习数据结构和算法的框架思维 ](https://labuladong.gitee.io/algo/1/2/) 中说到的二叉树遍历框架：

```java
    void traverse(TreeNode root) {
        if (root == null) {
            return;
        }
        // 前序位置
        traverse(root.left);
        // 中序位置
        traverse(root.right);
        // 后序位置
    }

```

先不管所谓前中后序，单看这段代码是什么？

其实就是一个能够遍历二叉树所有节点的一个函数，和你遍历数组或者链表本质上没有区别：

```java
    /* 迭代遍历数组 */
    void traverse(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
    
        }
    }
    
    /* 递归遍历数组 */
    void traverse(int[] arr, int i) {
        if (i == arr.length) {
            return;
        }
        // 前序位置
        traverse(arr, i + 1);
        // 后序位置
    }
    
    /* 迭代遍历单链表 */
    void traverse(ListNode head) {
        for (ListNode p = head; p != null; p = p.next) {
    
        }
    }
    
    /* 递归遍历单链表 */
    void traverse(ListNode head) {
        if (head == null) {
            return;
        }
        // 前序位置
        traverse(head.next);
        // 后序位置
    }

```

单链表和数组的遍历可以是迭代的，也可以是递归的，二叉树这种结构无非就是二叉链表，不过没办法简单改写成迭代形式，所以一般说二叉树的遍历框架都是指递归的形式。

你也注意到了，只要是递归形式的遍历，都会有一个前序和后序位置，分别在递归之前和之后。

所谓前序位置，就是刚进入一个节点（元素）的时候，后序位置就是即将离开一个节点（元素）的时候。

**你把代码写在不同位置，代码执行的时机也不同** ：

![](https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e6%94%b6%e5%ae%98/1.jpeg)

比如说，如果让你 **倒序打印** 一条单链表上所有节点的值，你怎么搞？

实现方式当然有很多，但如果你对递归的理解足够透彻，可以利用后序位置：

```java
    /* 递归遍历单链表，倒序打印链表元素 */
    void traverse(ListNode head) {
        if (head == null) {
            return;
        }
        traverse(head.next);
        // 后序位置
        print(head.val);
    }

```

结合上面那张图，你应该知道为什么这段代码能够倒序打印单链表了吧，本质上是利用递归的堆栈帮你实现了倒序遍历的效果。

那么说回二叉树也是一样的，只不过多了一个中序位置罢了。

这里我强调一个初学者经常犯的错误：因为教科书里只会问你前中后序遍历结果分别是什么，所以对于一个只上过大学数据结构课程的人来说，他大概以为二叉树的前中后序只不过对应三种顺序不同的
` List<Integer> ` 列表。

但是我想说， **前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点** ，绝不仅仅是三个顺序不同的 List：

前序位置的代码在刚刚进入一个二叉树节点的时候执行；

后序位置的代码在将要离开一个二叉树节点的时候执行；

中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。

你注意本文的用词，我一直说前中后序「位置」，就是要和大家常说的前中后序「遍历」有所区别：你可以在前序位置写代码往一个 List 里面塞元素，那最后可以得到前序遍历结果；但并不是说你就不可以写更复杂的代码做更复杂的事。

画成图，前中后序三个位置在二叉树上是这样：

![](https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e6%94%b6%e5%ae%98/2.jpeg)

你可以发现 **每个节点都有「唯一」属于自己的前中后序位置** ，所以我说前中后序遍历是遍历二叉树过程中处理每一个节点的三个特殊时间点。

这里你也可以理解为什么多叉树没有中序位置，因为二叉树的每个节点只会进行唯一一次左子树切换右子树，而多叉树节点可能有很多子节点，会多次切换子树去遍历，所以多叉树节点没有「唯一」的中序遍历位置。

说了这么多基础的，就是要帮你对二叉树建立正确的认识，然后你会发现： **二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的** 。

这也就是之前 6 篇手把手刷二叉树文章的核心思想：你只需要思考每一个节点应该做什么，其他的不用你管，抛给二叉树遍历框架，递归会对所有节点做相同的操作。

你也可以看到， [ 图论算法基础 ](https://labuladong.gitee.io/algo/2/18/34/)把二叉树的遍历框架扩展到了图，并以遍历为基础实现了图论的各种经典算法，不过这是后话，本文就不多说了。

### 两种解题思路

前文 [ 我的算法学习心得 ](https://labuladong.gitee.io/algo/1/3/) 说过，
**二叉树题目的递归解法可以分两类思路，第一类是遍历一遍二叉树得出答案，第二类是通过分解问题计算出答案，这两类思路分别对应着[ 回溯算法核心框架](https://labuladong.gitee.io/algo/4/28/105/) 和 [ 动态规划核心框架 ](https://labuladong.gitee.io/algo/3/22/66/) ** 。

当时我是用二叉树的最大深度这个问题来举例，重点在于把这两种思路和动态规划和回溯算法进行对比，而本文的重点在于分析这两种思路如何解决二叉树的题目。

力扣第 104 题「二叉树的最大深度」就是最大深度的题目，所谓最大深度就是根节点到「最远」叶子节点的最长路径上的节点数，比如输入这棵二叉树，算法应该返回 3：

![](https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e6%94%b6%e5%ae%98/tree.jpg)

你做这题的思路是什么？显然遍历一遍二叉树，用一个外部变量记录每个节点所在的深度，取最大值就可以得到最大深度， **这就是遍历二叉树计算答案的思路** 。

解法代码如下：

```java
    // 记录最大深度
    int res = 0;
    // 记录遍历到的节点的深度
    int depth = 0;
    
    // 主函数
    int maxDepth(TreeNode root) {
    	traverse(root);
    	return res;
    }
    
    // 二叉树遍历框架
    void traverse(TreeNode root) {
    	if (root == null) {
    		// 到达叶子节点，更新最大深度
    		res = Math.max(res, depth);
    		return;
    	}
    	// 前序位置
    	depth++;
    	traverse(root.left);
    	traverse(root.right);
    	// 后序位置
    	depth--;
    }

```

这个解法应该很好理解，但为什么需要在前序位置增加 ` depth ` ，在后序位置减小 ` depth ` ？

因为前面说了，前序位置是进入一个节点的时候，后序位置是离开一个节点的时候， ` depth ` 记录当前递归到的节点深度，所以要这样维护。

当然，你也很容易发现一棵二叉树的最大深度可以通过子树的最大高度推导出来， **这就是分解问题计算答案的思路** 。

解法代码如下：

```java
    // 定义：输入根节点，返回这棵二叉树的最大深度
    int maxDepth(TreeNode root) {
    	if (root == null) {
    		return 0;
    	}
    	// 利用定义，计算左右子树的最大深度
    	int leftMax = maxDepth(root.left);
    	int rightMax = maxDepth(root.right);
    	// 整棵树的最大深度等于左右子树的最大深度取最大值，
        // 然后再加上根节点自己
    	int res = Math.max(leftMax, rightMax) + 1;
    
    	return res;
    }

```

只要明确递归函数的定义，这个解法也不难理解，但为什么主要的代码逻辑集中在后序位置？

因为这个思路正确的核心在于，你确实可以通过子树的最大高度推导出原树的高度，所以当然要首先利用递归函数的定义算出左右子树的最大深度，然后推出原树的最大深度，主要逻辑自然放在后序位置。

如果你理解了最大深度这个问题的两种思路， **那么我们再回头看看最基本的二叉树前中后序遍历** ，就比如算前序遍历结果吧。

我们熟悉的解法就是用「遍历」的思路，我想应该没什么好说的：

```java
    List<Integer> res = new LinkedList<>();
    
    // 返回前序遍历结果
    List<Integer> preorderTraverse(TreeNode root) {
        traverse(root);
        return res;
    }
    
    // 二叉树遍历函数
    void traverse(TreeNode root) {
        if (root == null) {
            return;
        }
        // 前序位置
        res.add(root.val);
        traverse(root.left);
        traverse(root.right);
    }

```

但你是否能够用「分解问题」的思路，来计算前序遍历的结果？

换句话说，不要用像 ` traverse ` 这样的辅助函数和任何外部变量，单纯用题目给的 ` preorderTraverse `函数递归解题，你会不会？

我们知道前序遍历的特点是，根节点的值排在首位，接着是左子树的前序遍历结果，最后是右子树的前序遍历结果：

![](https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e6%94%b6%e5%ae%98/3.jpeg)

那这不就可以分解问题了么， **一棵二叉树的前序遍历分解成了根节点和左右子树的前序遍历结果** 。

所以，你可以这样实现前序遍历算法：

```java
    // 定义：输入一棵二叉树的根节点，返回这棵树的前序遍历结果
    List<Integer> preorderTraverse(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        if (root == null) {
            return res;
        }
        // 前序遍历的结果，root.val 在第一个
        res.add(root.val);
        // 利用函数定义，后面接着左子树的前序遍历结果
        res.addAll(preorderTraverse(root.left));
        // 利用函数定义，最后接着右子树的前序遍历结果
        res.addAll(preorderTraverse(root.right));
    }

```

中序和后序遍历也是类似的，只要把 ` add(root.val) ` 放到中序和后序对应的位置就行了。

这个解法短小精干，但为什么不常见呢？

一个原因是 **这个算法的复杂度不好把控** ，比较依赖语言特性。

Java 的话无论 ArrayList 还是 LinkedList， ` addAll ` 方法的复杂度都是 O(N)，所以总体的最坏时间复杂度会达到 O(N^2)，除非你自己实现一个复杂度为 O(1) 的 ` addAll `方法，底层用链表的话并不是不可能。

当然，最主要的原因还是因为教科书上从来没有这么教过……

上文举了两个简单的例子，但还有不少二叉树的题目是可以同时使用两种思路来思考和求解的，这就要靠你自己多去练习和思考，不要仅仅满足于一种熟悉的解法思路。

综上，遇到一道二叉树的题目时的通用思考过程是：

**是否可以通过遍历一遍二叉树得到答案？如果不能的话，是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案** ？

**[ 我的刷题插件 ](https://mp.weixin.qq.com/s/uOubir_nLzQtp_fWHL73JA)更新了所有值得一做的二叉树题目思路，全部归类为上述两种思路 **，你如果按照插件提供的思路解法过一遍二叉树的所有题目，不仅可以完全掌握递归思维，而且可以更容易理解高级的算法：

![](https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e6%94%b6%e5%ae%98/plugin1.png)

### 后序位置的特殊之处

说后序位置之前，先简单说下中序和前序。

中序位置主要用在 BST 场景中，你完全可以把 BST 的中序遍历认为是遍历有序数组。

前序位置本身其实没有什么特别的性质，之所以你发现好像很多题都是在前序位置写代码，实际上是因为我们习惯把那些对前中后序位置不敏感的代码写在前序位置罢了。

接下来主要说下后序位置，和前序位置对比，发现前序位置的代码执行是自顶向下的，而后序位置的代码执行是自底向上的：

![](https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e6%94%b6%e5%ae%98/2.jpeg)

这不奇怪，因为本文开头就说了前序位置是刚刚进入节点的时刻，后序位置是即将离开节点的时刻。

**但这里面大有玄妙，意味着前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据**。

举具体的例子，现在给你一棵二叉树，我问你两个简单的问题：

1、如果把根节点看做第 1 层，如何打印出每一个节点所在的层数？

2、如何打印出每个节点的左右子树各有多少节点？

第一个问题可以这样写代码：

```java
    // 二叉树遍历函数
    void traverse(TreeNode root, int level) {
        if (root == null) {
            return;
        }
        // 前序位置
        printf("节点 %s 在第 %d 层", root, level);
        traverse(root.left, level + 1);
        traverse(root.right, level + 1);
    }
    
    // 这样调用
    traverse(root, 1);

```

第二个问题可以这样写代码：

```java
    // 定义：输入一棵二叉树，返回这棵二叉树的节点总数
    int count(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int leftCount = count(root.left);
        int rightCount = count(root.right);
        // 后序位置
        printf("节点 %s 的左子树有 %d 个节点，右子树有 %d 个节点",
                root, leftCount, rightCount);
    
        return leftCount + rightCount + 1;
    }

```

结合这两个简单的问题，你品味一下后序位置的特点，只有后序位置才能通过返回值获取子树的信息。

**那么换句话说，一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了** 。

接下来看下后序位置是如何在实际的题目中发挥作用的，简单聊下力扣第 543 题「二叉树的直径」，让你计算一棵二叉树的最长直径长度。

所谓二叉树的「直径」长度，就是任意两个结点之间的路径长度。最长「直径」并不一定要穿过根结点，比如下面这棵二叉树：

![](https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e6%94%b6%e5%ae%98/tree1.png)

它的最长直径是 3，即 ` [4,2,1,3] ` 或者 ` [5,2,1,3] ` 这两条「直径」的长度。

解决这题的关键在于， **每一条二叉树的「直径」长度，就是一个节点的左右子树的最大深度之和** 。

现在让我求整棵树中的最长「直径」，那直截了当的思路就是遍历整棵树中的每个节点，然后通过每个节点的左右子树的最大深度算出每个节点的「直径」，最后把所有「直径」求个最大值即可。

最大深度的算法我们刚才实现过了，上述思路就可以写出以下代码：

```java
    // 记录最大直径的长度
    int maxDiameter = 0;
    
    public int diameterOfBinaryTree(TreeNode root) {
        // 对每个节点计算直径，求最大直径
        traverse(root);
        return maxDiameter;
    }
    
    // 遍历二叉树
    void traverse(TreeNode root) {
        if (root == null) {
            return;
        }
        // 对每个节点计算直径
        int leftMax = maxDepth(root.left);
        int rightMax = maxDepth(root.right);
        int myDiameter = leftMax + rightMax;
        // 更新全局最大直径
        maxDiameter = Math.max(maxDiameter, myDiameter);
        
        traverse(root.left);
        traverse(root.right);
    }
    
    // 计算二叉树的最大深度
    int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int leftMax = maxDepth(root.left);
        int rightMax = maxDepth(root.right);
        return 1 + Math.max(leftMax, rightMax);
    }

```

这个解法是正确的，但是运行时间很长，原因也很明显， ` traverse ` 遍历每个节点的时候还会调用递归函数 ` maxDepth ` ，而 `maxDepth ` 是要遍历所有子树的，所以最坏时间复杂度是 O(N^2)。

这就出现了刚才探讨的情况， **前序位置无法获取子树信息，所以只能让每个节点调用` maxDepth ` 函数去算子树的深度 ** 。

那如何优化？我们应该把计算「直径」的逻辑放在后序位置，准确说应该是放在 ` maxDepth ` 的后序位置，因为 ` maxDepth `的后序位置是知道左右子树的最大深度的。

所以，稍微改一下代码逻辑即可得到更好的解法：

```java
    // 记录最大直径的长度
    int maxDiameter = 0;
    
    public int diameterOfBinaryTree(TreeNode root) {
        maxDepth(root);
        return maxDiameter;
    }
    
    int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int leftMax = maxDepth(root.left);
        int rightMax = maxDepth(root.right);
        // 后序位置顺便计算最大直径
        int myDiameter = leftMax + rightMax;
        maxDiameter = Math.max(maxDiameter, myDiameter);
    
        return 1 + Math.max(leftMax, rightMax);
    }

```

这下时间复杂度只有 ` maxDepth ` 函数的 O(N) 了。

讲到这里，照应一下前文：遇到子树问题，首先想到的是给函数设置返回值，然后在后序位置做文章。

反过来，如果你写出了类似一开始的那种递归套递归的解法，大概率也需要反思是不是可以通过后序遍历优化了。

**[ 我的刷题插件 ](https://mp.weixin.qq.com/s/uOubir_nLzQtp_fWHL73JA)对于这类考察后序遍历的题目也有特殊的说明 ** ，并且会给出前置题目，帮助你由浅入深理解这类题目：

![](https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e6%94%b6%e5%ae%98/plugin2.png)

### 层序遍历

二叉树题型主要是用来培养递归思维的，而层序遍历属于迭代遍历，也比较简单，这里就过一下代码框架吧：

```java
    // 输入一棵二叉树的根节点，层序遍历这棵二叉树
    void levelTraverse(TreeNode root) {
        if (root == null) return;
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);
    
        // 从上到下遍历二叉树的每一层
        while (!q.isEmpty()) {
            int sz = q.size();
            // 从左到右遍历每一层的每个节点
            for (int i = 0; i < sz; i++) {
                TreeNode cur = q.poll();
                // 将下一层节点放入队列
                if (cur.left != null) {
                    q.offer(cur.left);
                }
                if (cur.right != null) {
                    q.offer(cur.right);
                }
            }
        }
    }

```

这里面 while 循环和 for 循环分管从上到下和从左到右的遍历：

![](https://labuladong.gitee.io/algo/images/dijkstra/1.jpeg)

前文 [ BFS 算法框架 ](https://labuladong.gitee.io/algo/4/28/110/) 就是从二叉树的层序遍历扩展出来的，常用于求无权图的 **最短路径** 问题。

当然这个框架还可以灵活修改，题目不需要记录层数（步数）时可以去掉上述框架中的 for 循环，比如前文 [ Dijkstra 算法](https://labuladong.gitee.io/algo/2/18/41/) 中计算加权图的最短路径问题，详细探讨了 BFS 算法的扩展。

值得一提的是，有些很明显需要用层序遍历技巧的二叉树的题目，也可以用递归遍历的方式去解决，而且技巧性会更强，非常考察你对前中后序的把控。

对于这类问题， [ 我的刷题插件 ](https://mp.weixin.qq.com/s/uOubir_nLzQtp_fWHL73JA)也会同时提供递归遍历和层序遍历的解法代码：

![](https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e6%94%b6%e5%ae%98/plugin4.png)

好了，本文已经够长了，围绕前中后序位置算是把二叉树题目里的各种套路给讲透了，真正能运用出来多少，就需要你亲自刷题实践和思考了。

希望大家能探索尽可能多的解法，只要参透二叉树这种基本数据结构的原理，那么就很容易在学习其他高级算法的道路上找到抓手，打通回路，形成闭环（手动狗头）。

最后，我在不断完善刷题插件对二叉树系列题目的支持，在公众号后台回复关键词「 **插件** 」即可下载。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


## 手把手带你刷二叉树（第一期）


读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 226. 翻转二叉树（简单） ](https://leetcode-cn.com/problems/invert-binary-tree)

[ 114. 二叉树展开为链表（中等） ](https://leetcode-cn.com/problems/flatten-binary-tree-to-
linked-list)

[ 116. 填充每个节点的下一个右侧节点指针（中等） ](https://leetcode-cn.com/problems/populating-
next-right-pointers-in-each-node)

**———–**

PS： [ 刷题插件 ](https://mp.weixin.qq.com/s/OE1zPVPj0V2o82N4HtLQbw)集成了手把手刷二叉树功能，按照公式和套路讲解了 150 道二叉树题目，可手把手带你刷完二叉树分类的题目，迅速掌握递归思维。

我们公众号的成名之作 [ 学习数据结构和算法的框架思维 ](https://labuladong.gitee.io/algo/1/2/)中多次强调，先刷二叉树的题目，先刷二叉树的题目，先刷二叉树的题目，因为很多经典算法，以及我们前文讲过的所有回溯、动归、分治算法，其实都是树的问题，而树的问题就永远逃不开树的递归遍历框架这几行破代码：

```java
    /* 二叉树遍历框架 */
    void traverse(TreeNode root) {
        // 前序遍历
        traverse(root.left)
        // 中序遍历
        traverse(root.right)
        // 后序遍历
    }

```

上篇公众号文章让读者留言说说对什么问题还有疑惑，我接下来可以重点写一写相关的文章。结果还有很多读者说觉得「递归」非常难以理解，说实话，递归解法应该是最简单，最容易理解的才对，行云流水地写递归代码是学好算法的基本功，而二叉树相关的题目就是最练习递归基本功，最练习框架思维的。

我先花一些篇幅说明二叉树算法的重要性。

### 一、二叉树的重要性

举个例子，比如说我们的经典算法「快速排序」和「归并排序」，对于这两个算法，你有什么理解？
**如果你告诉我，快速排序就是个二叉树的前序遍历，归并排序就是个二叉树的后序遍历，那么我就知道你是个算法高手了** 。

为什么快速排序和归并排序能和二叉树扯上关系？我们来简单分析一下他们的算法思想和代码框架：

快速排序的逻辑是，若要对 ` nums[lo..hi] ` 进行排序，我们先找一个分界点 ` p ` ，通过交换元素使得 ` nums[lo..p-1] `都小于等于 ` nums[p] ` ，且 ` nums[p+1..hi] ` 都大于 ` nums[p] ` ，然后递归地去 ` nums[lo..p-1]
` 和 ` nums[p+1..hi] ` 中寻找新的分界点，最后整个数组就被排序了。

快速排序的代码框架如下：

```java
    void sort(int[] nums, int lo, int hi) {
        /****** 前序遍历位置 ******/
        // 通过交换元素构建分界点 p
        int p = partition(nums, lo, hi);
        /************************/
    
        sort(nums, lo, p - 1);
        sort(nums, p + 1, hi);
    }

```

先构造分界点，然后去左右子数组构造分界点，你看这不就是一个二叉树的前序遍历吗？

再说说归并排序的逻辑，若要对 ` nums[lo..hi] ` 进行排序，我们先对 ` nums[lo..mid] ` 排序，再对 `nums[mid+1..hi] ` 排序，最后把这两个有序的子数组合并，整个数组就排好序了。

归并排序的代码框架如下：

```java
    void sort(int[] nums, int lo, int hi) {
        int mid = (lo + hi) / 2;
        sort(nums, lo, mid);
        sort(nums, mid + 1, hi);
    
        /****** 后序遍历位置 ******/
        // 合并两个排好序的子数组
        merge(nums, lo, mid, hi);
        /************************/
    }

```

先对左右子数组排序，然后合并（类似合并有序链表的逻辑），你看这是不是二叉树的后序遍历框架？另外，这不就是传说中的分治算法嘛，不过如此呀。

如果你一眼就识破这些排序算法的底细，还需要背这些算法代码吗？这不是手到擒来，从框架慢慢扩展就能写出算法了。

说了这么多，旨在说明，二叉树的算法思想的运用广泛，甚至可以说，只要涉及递归，都可以抽象成二叉树的问题， **所以本文和后续的[ 手把手带你刷二叉树（第二期）](https://labuladong.gitee.io/algo/2/17/22/) 以及 [ 手把手刷二叉树（第三期） ](https://labuladong.gitee.io/algo/2/17/23/)
，我们直接上几道比较有意思，且能体现出递归算法精妙的二叉树题目，东哥手把手教你怎么用算法框架搞定它们 ** 。

### 二、写递归算法的秘诀

我们前文 [ 二叉树的最近公共祖先 ](https://labuladong.gitee.io/algo/2/17/30/) 写过，
**写递归算法的关键是要明确函数的「定义」是什么，然后相信这个定义，利用这个定义推导最终结果，绝不要跳入递归的细节** 。

怎么理解呢，我们用一个具体的例子来说，比如说让你计算一棵二叉树共有几个节点：

```java
    // 定义：count(root) 返回以 root 为根的树有多少节点
    int count(TreeNode root) {
        // base case
        if (root == null) return 0;
        // 自己加上子树的节点数就是整棵树的节点数
        return 1 + count(root.left) + count(root.right);
    }

```

这个问题非常简单，大家应该都会写这段代码， ` root ` 本身就是一个节点，加上左右子树的节点数就是以 ` root ` 为根的树的节点总数。

左右子树的节点数怎么算？其实就是计算根为 ` root.left ` 和 ` root.right ` 两棵树的节点数呗，按照定义，递归调用 ` count
` 函数即可算出来。

**写树相关的算法，简单说就是，先搞清楚当前` root ` 节点「该做什么」以及「什么时候做」，然后根据函数定义递归调用子节点 **，递归调用会让孩子节点做相同的事情。

所谓「该做什么」就是让你想清楚写什么代码能够实现题目想要的效果，所谓「什么时候做」，就是让你思考这段代码到底应该写在前序、中序还是后序遍历的代码位置上。

我们接下来看几道算法题目实操一下。

### 三、算法实践

**第一题、翻转二叉树**

我们先从简单的题开始，看看力扣第 226 题「翻转二叉树」，输入一个二叉树根节点 ` root ` ，让你把整棵树镜像翻转，比如输入的二叉树如下：

```java
         4
       /   \
      2     7
     / \   / \
    1   3 6   9

```

算法原地翻转二叉树，使得以 ` root ` 为根的树变成：

```java
         4
       /   \
      7     2
     / \   / \
    9   6 3   1

```

通过观察， **我们发现只要把二叉树上的每一个节点的左右子节点进行交换，最后的结果就是完全翻转之后的二叉树** 。

可以直接写出解法代码：

```java
    // 将整棵树的节点翻转
    TreeNode invertTree(TreeNode root) {
        // base case
        if (root == null) {
            return null;
        }
    
        /**** 前序遍历位置 ****/
        // root 节点需要交换它的左右子节点
        TreeNode tmp = root.left;
        root.left = root.right;
        root.right = tmp;
    
        // 让左右子节点继续翻转它们的子节点
        invertTree(root.left);
        invertTree(root.right);
        
        return root;
    }

```

这道题目比较简单，关键思路在于我们发现翻转整棵树就是交换每个节点的左右子节点，于是我们把交换左右子节点的代码放在了前序遍历的位置。

值得一提的是，如果把交换左右子节点的代码复制粘贴到后序遍历的位置也是可以的，但是直接放到中序遍历的位置是不行的，请你想一想为什么？这个应该不难想到，我会把答案置顶在公众号留言区。

首先讲这道题目是想告诉你， **二叉树题目的一个难点就是，如何把题目的要求细化成每个节点需要做的事情** 。

这种洞察力需要多刷题训练，我们看下一道题。

**第二题、填充二叉树节点的右侧指针**

这是力扣第 116 题，看下题目：

![](https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e7%b3%bb%e5%88%97/title1.png)

```java
    Node connect(Node root);

```

题目的意思就是把二叉树的每一层节点都用 ` next ` 指针连接起来：

![](https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e7%b3%bb%e5%88%97/1.png)

而且题目说了，输入是一棵「完美二叉树」，形象地说整棵二叉树是一个正三角形，除了最右侧的节点 ` next ` 指针会指向 ` null `，其他节点的右侧一定有相邻的节点。

这道题怎么做呢？把每一层的节点穿起来，是不是只要把每个节点的左右子节点都穿起来就行了？

我们可以模仿上一道题，写出如下代码：

```java
    Node connect(Node root) {
        if (root == null || root.left == null) {
            return root;
        }
    
        root.left.next = root.right;
    
        connect(root.left);
        connect(root.right);
    
        return root;
    }

```

这样其实有很大问题，再看看这张图：

![](https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e7%b3%bb%e5%88%97/1.png)

节点 5 和节点 6 不属于同一个父节点，那么按照这段代码的逻辑，它俩就没办法被穿起来，这是不符合题意的。

回想刚才说的， **二叉树的问题难点在于，如何把题目的要求细化成每个节点需要做的事情**，但是如果只依赖一个节点的话，肯定是没办法连接「跨父节点」的两个相邻节点的。

那么，我们的做法就是增加函数参数，一个节点做不到，我们就给他安排两个节点，「将每一层二叉树节点连接起来」可以细化成「将每两个相邻节点都连接起来」：

```java
    // 主函数
    Node connect(Node root) {
        if (root == null) return null;
        connectTwoNode(root.left, root.right);
        return root;
    }
    
    // 辅助函数
    void connectTwoNode(Node node1, Node node2) {
        if (node1 == null || node2 == null) {
            return;
        }
        /**** 前序遍历位置 ****/
        // 将传入的两个节点连接
        node1.next = node2;
        
        // 连接相同父节点的两个子节点
        connectTwoNode(node1.left, node1.right);
        connectTwoNode(node2.left, node2.right);
        // 连接跨越父节点的两个子节点
        connectTwoNode(node1.right, node2.left);
    }

```

这样， ` connectTwoNode `函数不断递归，可以无死角覆盖整棵二叉树，将所有相邻节点都连接起来，也就避免了我们之前出现的问题，这道题就解决了。

**第三题、将二叉树展开为链表**

这是力扣第 114 题，看下题目：

![](https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e7%b3%bb%e5%88%97/title2.png)

函数签名如下：

```java
    void flatten(TreeNode root);

```

我们尝试给出这个函数的定义：

**给` flatten ` 函数输入一个节点 ` root ` ，那么以 ` root ` 为根的二叉树就会被拉平为一条链表 ** 。

我们再梳理一下，如何按题目要求把一棵树拉平成一条链表？很简单，以下流程：

1、将 ` root ` 的左子树和右子树拉平。

2、将 ` root ` 的右子树接到左子树下方，然后将整个左子树作为右子树。

![](https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e7%b3%bb%e5%88%97/2.jpeg)

上面三步看起来最难的应该是第一步对吧，如何把 ` root ` 的左右子树拉平？其实很简单，按照 ` flatten ` 函数的定义，对 ` root `的左右子树递归调用 ` flatten ` 函数即可：

```java
    // 定义：将以 root 为根的树拉平为链表
    void flatten(TreeNode root) {
        // base case
        if (root == null) return;
        
        flatten(root.left);
        flatten(root.right);
    
        /**** 后序遍历位置 ****/
        // 1、左右子树已经被拉平成一条链表
        TreeNode left = root.left;
        TreeNode right = root.right;
        
        // 2、将左子树作为右子树
        root.left = null;
        root.right = left;
    
        // 3、将原先的右子树接到当前右子树的末端
        TreeNode p = root;
        while (p.right != null) {
            p = p.right;
        }
        p.right = right;
    }

```

你看，这就是递归的魅力，你说 ` flatten ` 函数是怎么把左右子树拉平的？说不清楚，但是只要知道 ` flatten `的定义如此，相信这个定义，让 ` root ` 做它该做的事情，然后 ` flatten `函数就会按照定义工作。另外注意递归框架是后序遍历，因为我们要先拉平左右子树才能进行后续操作。

至此，这道题也解决了，我们旧文 [ k个一组翻转链表 ](https://labuladong.gitee.io/algo/2/16/17/) 的递归思路和本题也有一些类似。

### 四、最后总结

递归算法的关键要明确函数的定义，相信这个定义，而不要跳进递归细节。

写二叉树的算法题，都是基于递归框架的，我们先要搞清楚 ` root ` 节点它自己要做什么，然后根据题目要求选择使用前序，中序，后续的递归框架。

二叉树题目的难点在于如何通过题目的要求思考出每一个节点需要做什么，这个只能通过多刷题进行练习了。

如果本文讲的三道题对你有一些启发，请三连，数据好的话东哥下次再来一波手把手刷题文，你会发现二叉树的题真的是越刷越顺手，欲罢不能，恨不得一口气把二叉树的题刷通。

接下来可阅读：

* [ 手把手刷二叉树（第二期） ](https://labuladong.gitee.io/algo/2/17/22/)
* [ 手把手刷二叉树（第三期） ](https://labuladong.gitee.io/algo/2/17/23/)

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


## 手把手带你刷二叉树（第二期）


读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 654. 最大二叉树（中等） ](https://leetcode-cn.com/problems/maximum-binary-tree/)

[ 105. 从前序与中序遍历序列构造二叉树（中等） ](https://leetcode-cn.com/problems/construct-
binary-tree-from-preorder-and-inorder-traversal/)

[ 106. 从中序与后序遍历序列构造二叉树（中等） ](https://leetcode-cn.com/problems/construct-
binary-tree-from-inorder-and-postorder-traversal/)

[ 889. 根据前序和后序遍历构造二叉树（中等） ](https://leetcode-cn.com/problems/construct-binary-
tree-from-preorder-and-postorder-traversal/)

**———–**

PS： [ 刷题插件 ](https://mp.weixin.qq.com/s/OE1zPVPj0V2o82N4HtLQbw)集成了手把手刷二叉树功能，按照公式和套路讲解了 150 道二叉树题目，可手把手带你刷完二叉树分类的题目，迅速掌握递归思维。

上篇文章 [ 手把手教你刷二叉树（第一篇） ](https://labuladong.gitee.io/algo/2/17/21/)连刷了三道二叉树题目，很多读者直呼内行。其实二叉树相关的算法真的不难，本文再来三道，手把手带你看看树的算法到底怎么做。

先来复习一下，我们说过写树的算法，关键思路如下：

**把题目的要求细化，搞清楚根节点应该做什么，然后剩下的事情抛给前/中/后序的遍历框架就行了** ，我们千万不要跳进递归的细节里，你的脑袋才能压几个栈呀。

也许你还不太理解这句话，我们下面来看例子。

### 构造最大二叉树

先来道简单的，这是力扣第 654 题，题目如下：

![](https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e7%b3%bb%e5%88%972/title1.png)

函数签名如下：

```java
    TreeNode constructMaximumBinaryTree(int[] nums);

```

按照我们刚才说的，先明确根节点做什么？ **对于构造二叉树的问题，根节点要做的就是把想办法把自己构造出来** 。

我们肯定要遍历数组把找到最大值 ` maxVal ` ，把根节点 ` root ` 做出来，然后对 ` maxVal `左边的数组和右边的数组进行递归调用，作为 ` root ` 的左右子树。

按照题目给出的例子，输入的数组为 ` [3,2,1,6,0,5] ` ，对于整棵树的根节点来说，其实在做这件事：

```java
    TreeNode constructMaximumBinaryTree([3,2,1,6,0,5]) {
        // 找到数组中的最大值
        TreeNode root = new TreeNode(6);
        // 递归调用构造左右子树
        root.left = constructMaximumBinaryTree([3,2,1]);
        root.right = constructMaximumBinaryTree([0,5]);
        return root;
    }

```

再详细一点，就是如下伪码：

```java
    TreeNode constructMaximumBinaryTree(int[] nums) {
        if (nums is empty) return null;
        // 找到数组中的最大值
        int maxVal = Integer.MIN_VALUE;
        int index = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] > maxVal) {
                maxVal = nums[i];
                index = i;
            }
        }
    
        TreeNode root = new TreeNode(maxVal);
        // 递归调用构造左右子树
        root.left = constructMaximumBinaryTree(nums[0..index-1]);
        root.right = constructMaximumBinaryTree(nums[index+1..nums.length-1]);
        return root;
    }

```

看懂了吗？ **对于每个根节点，只需要找到当前` nums ` 中的最大值和对应的索引，然后递归调用左右数组构造左右子树即可 ** 。

明确了思路，我们可以重新写一个辅助函数 ` build ` ，来控制 ` nums ` 的索引：

```java
    /* 主函数 */
    TreeNode constructMaximumBinaryTree(int[] nums) {
        return build(nums, 0, nums.length - 1);
    }
    
    /* 将 nums[lo..hi] 构造成符合条件的树，返回根节点 */
    TreeNode build(int[] nums, int lo, int hi) {
        // base case
        if (lo > hi) {
            return null;
        }
    
        // 找到数组中的最大值和对应的索引
        int index = -1, maxVal = Integer.MIN_VALUE;
        for (int i = lo; i <= hi; i++) {
            if (maxVal < nums[i]) {
                index = i;
                maxVal = nums[i];
            }
        }
    
        TreeNode root = new TreeNode(maxVal);
        // 递归调用构造左右子树
        root.left = build(nums, lo, index - 1);
        root.right = build(nums, index + 1, hi);
        
        return root;
    }

```

至此，这道题就做完了，还是挺简单的对吧，下面看两道更困难一些的。

### 通过前序和中序遍历结果构造二叉树

经典问题了，面试/笔试中常考，力扣第 105 题就是这个问题：

![](https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e7%b3%bb%e5%88%972/title3.png)

函数签名如下：

```java
    TreeNode buildTree(int[] preorder, int[] inorder);

```

废话不多说，直接来想思路，首先思考，根节点应该做什么。

**类似上一题，我们肯定要想办法确定根节点的值，把根节点做出来，然后递归构造左右子树即可** 。

我们先来回顾一下，前序遍历和中序遍历的结果有什么特点？

```java
    void traverse(TreeNode root) {
        // 前序遍历
        preorder.add(root.val);
        traverse(root.left);
        traverse(root.right);
    }
    
    void traverse(TreeNode root) {
        traverse(root.left);
        // 中序遍历
        inorder.add(root.val);
        traverse(root.right);
    }

```

前文 [ 二叉树就那几个框架 ](https://labuladong.gitee.io/algo/2/17/29/) 写过，这样的遍历顺序差异，导致了 ` preorder ` 和 ` inorder
` 数组中的元素分布有如下特点：

![](https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e7%b3%bb%e5%88%972/1.jpeg)

找到根节点是很简单的，前序遍历的第一个值 ` preorder[0] ` 就是根节点的值，关键在于如何通过根节点的值，将 ` preorder ` 和 `postorder ` 数组划分成两半，构造根节点的左右子树？

换句话说，对于以下代码中的 ` ? ` 部分应该填入什么：

```java
    /* 主函数 */
    TreeNode buildTree(int[] preorder, int[] inorder) {
        return build(preorder, 0, preorder.length - 1,
                     inorder, 0, inorder.length - 1);
    }
    
    /* 
       若前序遍历数组为 preorder[preStart..preEnd]，
       中序遍历数组为 inorder[inStart..inEnd]，
       构造二叉树，返回该二叉树的根节点 
    */
    TreeNode build(int[] preorder, int preStart, int preEnd, 
                   int[] inorder, int inStart, int inEnd) {
        // root 节点对应的值就是前序遍历数组的第一个元素
        int rootVal = preorder[preStart];
        // rootVal 在中序遍历数组中的索引
        int index = 0;
        for (int i = inStart; i <= inEnd; i++) {
            if (inorder[i] == rootVal) {
                index = i;
                break;
            }
        }
    
        TreeNode root = new TreeNode(rootVal);
        // 递归构造左右子树
        root.left = build(preorder, ?, ?,
                          inorder, ?, ?);
    
        root.right = build(preorder, ?, ?,
                           inorder, ?, ?);
        return root;
    }

```

对于代码中的 ` rootVal ` 和 ` index ` 变量，就是下图这种情况：

![](https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e7%b3%bb%e5%88%972/2.jpeg)

现在我们来看图做填空题，下面这几个问号处应该填什么：

```java
    root.left = build(preorder, ?, ?,
                      inorder, ?, ?);
    
    root.right = build(preorder, ?, ?,
                       inorder, ?, ?);

```

对于左右子树对应的 ` inorder ` 数组的起始索引和终止索引比较容易确定：

![](https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e7%b3%bb%e5%88%972/3.jpeg)

```java
    root.left = build(preorder, ?, ?,
                      inorder, inStart, index - 1);
    
    root.right = build(preorder, ?, ?,
                       inorder, index + 1, inEnd);

```

对于 ` preorder ` 数组呢？如何确定左右数组对应的起始索引和终止索引？

这个可以通过左子树的节点数推导出来，假设左子树的节点数为 ` leftSize ` ，那么 ` preorder ` 数组上的索引情况是这样的：

![](https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e7%b3%bb%e5%88%972/4.jpeg)

看着这个图就可以把 ` preorder ` 对应的索引写进去了：

```java
    int leftSize = index - inStart;
    
    root.left = build(preorder, preStart + 1, preStart + leftSize,
                      inorder, inStart, index - 1);
    
    root.right = build(preorder, preStart + leftSize + 1, preEnd,
                       inorder, index + 1, inEnd);

```

至此，整个算法思路就完成了，我们再补一补 base case 即可写出解法代码：

```java
    TreeNode build(int[] preorder, int preStart, int preEnd, 
                   int[] inorder, int inStart, int inEnd) {
            
        if (preStart > preEnd) {
            return null;
        }
    
        // root 节点对应的值就是前序遍历数组的第一个元素
        int rootVal = preorder[preStart];
        // rootVal 在中序遍历数组中的索引
        int index = 0;
        for (int i = inStart; i <= inEnd; i++) {
            if (inorder[i] == rootVal) {
                index = i;
                break;
            }
        }
    
        int leftSize = index - inStart;
    
        // 先构造出当前根节点
        TreeNode root = new TreeNode(rootVal);
        // 递归构造左右子树
        root.left = build(preorder, preStart + 1, preStart + leftSize,
                          inorder, inStart, index - 1);
    
        root.right = build(preorder, preStart + leftSize + 1, preEnd,
                           inorder, index + 1, inEnd);
        return root;
    }

```

我们的主函数只要调用 ` build `函数即可，你看着函数这么多参数，解法这么多代码，似乎比我们上面讲的那道题难很多，让人望而生畏，实际上呢，这些参数无非就是控制数组起止位置的，画个图就能解决了。

### 通过后序和中序遍历结果构造二叉树

类似上一题，这次我们利用 **后序** 和 **中序** 遍历的结果数组来还原二叉树，这是力扣第 106 题：

![](https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e7%b3%bb%e5%88%972/title2.png)

函数签名如下：

```java
    TreeNode buildTree(int[] inorder, int[] postorder);

```

类似的，看下后序和中序遍历的特点：

```java
    void traverse(TreeNode root) {
        traverse(root.left);
        traverse(root.right);
        // 后序遍历
        postorder.add(root.val);
    }
    
    void traverse(TreeNode root) {
        traverse(root.left);
        // 中序遍历
        inorder.add(root.val);
        traverse(root.right);
    }

```

这样的遍历顺序差异，导致了 ` preorder ` 和 ` inorder ` 数组中的元素分布有如下特点：

![](https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e7%b3%bb%e5%88%972/5.jpeg)

这道题和上一题的关键区别是，后序遍历和前序遍历相反，根节点对应的值为 ` postorder ` 的最后一个元素。

整体的算法框架和上一题非常类似，我们依然写一个辅助函数 ` build ` ：

```java
    TreeNode buildTree(int[] inorder, int[] postorder) {
        return build(inorder, 0, inorder.length - 1,
                     postorder, 0, postorder.length - 1);
    }
    
    /* 
       后序遍历数组为 postorder[postStart..postEnd]，
       中序遍历数组为 inorder[inStart..inEnd]，
       构造二叉树，返回该二叉树的根节点 
    */
    TreeNode build(int[] inorder, int inStart, int inEnd,
                   int[] postorder, int postStart, int postEnd) {
        // root 节点对应的值就是后序遍历数组的最后一个元素
        int rootVal = postorder[postEnd];
        // rootVal 在中序遍历数组中的索引
        int index = 0;
        for (int i = inStart; i <= inEnd; i++) {
            if (inorder[i] == rootVal) {
                index = i;
                break;
            }
        }
    
        TreeNode root = new TreeNode(rootVal);
        // 递归构造左右子树
        root.left = build(preorder, ?, ?,
                          inorder, ?, ?);
    
        root.right = build(preorder, ?, ?,
                           inorder, ?, ?);
        return root;
    }

```

现在 ` postoder ` 和 ` inorder ` 对应的状态如下：

![](https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e7%b3%bb%e5%88%972/6.jpeg)

我们可以按照上图将问号处的索引正确填入：

```java
    int leftSize = index - inStart;
    
    root.left = build(inorder, inStart, index - 1,
                      postorder, postStart, postStart + leftSize - 1);
    
    root.right = build(inorder, index + 1, inEnd,
                       postorder, postStart + leftSize, postEnd - 1);

```

综上，可以写出完整的解法代码：

```java
    TreeNode build(int[] inorder, int inStart, int inEnd,
                   int[] postorder, int postStart, int postEnd) {
    
        if (inStart > inEnd) {
            return null;
        }
        // root 节点对应的值就是后序遍历数组的最后一个元素
        int rootVal = postorder[postEnd];
        // rootVal 在中序遍历数组中的索引
        int index = 0;
        for (int i = inStart; i <= inEnd; i++) {
            if (inorder[i] == rootVal) {
                index = i;
                break;
            }
        }
        // 左子树的节点个数
        int leftSize = index - inStart;
        TreeNode root = new TreeNode(rootVal);
        // 递归构造左右子树
        root.left = build(inorder, inStart, index - 1,
                            postorder, postStart, postStart + leftSize - 1);
        
        root.right = build(inorder, index + 1, inEnd,
                            postorder, postStart + leftSize, postEnd - 1);
        return root;
    }

```

有了前一题的铺垫，这道题很快就解决了，无非就是 ` rootVal ` 变成了最后一个元素，再改改递归函数的参数而已，只要明白二叉树的特性，也不难写出来。

### 通过后序和前序遍历结果构造二叉树

这是力扣第 889 题「根据前序和后序遍历构造二叉树」，给你输入二叉树的前序和后序遍历结果，让你还原二叉树的结构。

函数签名如下：

```java
    TreeNode constructFromPrePost(int[] preorder, int[] postorder);

```

这道题和前两道题有一个本质的区别：

**通过前序中序，或者后序中序遍历结果可以确定一棵原始二叉树，但是通过前序后序遍历结果无法确定原始二叉树** 。

题目也说了，如果有多种可能的还原结果，你可以返回任意一种。

为什么呢？我们说过，构建二叉树的套路很简单，先找到根节点，然后找到并递归构造左右子树即可。

前两道题，可以通过前序或者后序遍历结果找到根节点，然后根据中序遍历结果确定左右子树。

这道题，你可以确定根节点，但是无法确切的知道左右子树有哪些节点。

举个例子，下面这两棵树结构不同，但是它们的前序遍历和后序遍历结果是相同的：

![](https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e7%b3%bb%e5%88%972/7.png)

不过话说回来，用后序遍历和前序遍历结果还原二叉树，解法逻辑上和前两道题差别不大，也是通过控制左右子树的索引来构建：

**1、首先把前序遍历结果的第一个元素或者后序遍历结果的最后一个元素确定为根节点的值** 。

**2、然后把前序遍历结果的第二个元素作为左子树的根节点的值** 。

**3、在后序遍历结果中寻找左子树根节点的值，从而确定了左子树的索引边界，进而确定右子树的索引边界，递归构造左右子树即可** 。

![](https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e7%b3%bb%e5%88%972/8.jpeg)

详情见代码。

```java
    class Solution {
        public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {
            return build(preorder, 0, preorder.length - 1,
                    postorder, 0, postorder.length - 1);
        }
    
        // 定义：根据 preorder[preStart..preEnd] 和 postorder[postStart..postEnd]
        // 构建二叉树，并返回根节点。
        TreeNode build(int[] preorder, int preStart, int preEnd,
                       int[] postorder, int postStart, int postEnd) {
            if (preStart > preEnd) {
                return null;
            }
            if (preStart == preEnd) {
                return new TreeNode(preorder[preStart]);
            }
    
            // root 节点对应的值就是前序遍历数组的第一个元素
            int rootVal = preorder[preStart];
            // root.left 的值是前序遍历第二个元素
            // 通过前序和后序遍历构造二叉树的关键在于通过左子树的根节点
            // 确定 preorder 和 postorder 中左右子树的元素区间
            int leftRootVal = preorder[preStart + 1];
            // leftRootVal 在后序遍历数组中的索引
            int index = 0;
            for (int i = postStart; i < postEnd; i++) {
                if (postorder[i] == leftRootVal) {
                    index = i;
                    break;
                }
            }
            // 左子树的元素个数
            int leftSize = index - postStart + 1;
    
            // 先构造出当前根节点
            TreeNode root = new TreeNode(rootVal);
            // 递归构造左右子树
            // 根据左子树的根节点索引和元素个数推导左右子树的索引边界
            root.left = build(preorder, preStart + 1, preStart + leftSize,
                    postorder, postStart, index);
            root.right = build(preorder, preStart + leftSize + 1, preEnd,
                    postorder, index + 1, postEnd);
    
            return root;
        }
    }

```

代码和前两道题非常类似，我们可以看着代码思考一下，为什么通过前序遍历和后序遍历结果还原的二叉树可能不唯一呢？

关键在这一句：

```java
    int leftRootVal = preorder[preStart + 1];

```

我们假设前序遍历的第二个元素是左子树的根节点，但实际上左子树可能是空指针，这个元素可能是右子树的根节点。

由于这里无法确切进行判断，所以导致了最终答案的不唯一。

至此，通过前序和后序遍历结果还原二叉树的问题也解决了。

最后呼应下前文， **做二叉树的问题，关键是把题目的要求细化，搞清楚根节点应该做什么，然后剩下的事情抛给前/中/后序的遍历框架就行了** 。

现在你是否明白其中的玄妙了呢？

接下来可阅读：

* [ 手把手刷二叉树（第三期） ](https://labuladong.gitee.io/algo/2/17/23/)

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


## 手把手带你刷二叉树（第三期）


读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 652. 寻找重复的子树（中等） ](https://leetcode-cn.com/problems/find-duplicate-subtrees)

**———–**

PS： [ 刷题插件 ](https://mp.weixin.qq.com/s/OE1zPVPj0V2o82N4HtLQbw)集成了手把手刷二叉树功能，按照公式和套路讲解了 150 道二叉树题目，可手把手带你刷完二叉树分类的题目，迅速掌握递归思维。

接前文 [ 手把手带你刷二叉树（第一期） ](https://labuladong.gitee.io/algo/2/17/21/) 和 [ 手把手带你刷二叉树（第二期）](https://labuladong.gitee.io/algo/2/17/22/) ，本文继续来刷二叉树。

从前两篇文章的阅读量来看，大家还是能够通过二叉树学习到 [ 框架思维 ](https://labuladong.gitee.io/algo/1/2/) 的。但还是有不少读者有一些问题，比如
**如何判断我们应该用前序还是中序还是后序遍历的框架** ？

那么本文就针对这个问题，不贪多，给你掰开揉碎只讲一道题。还是那句话， **根据题意，思考一个二叉树节点需要做什么，到底用什么遍历顺序就清楚了** 。

看题，这是力扣第 652 题「寻找重复子树」：

![](https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%913/title.png)

函数签名如下：

```java
    List<TreeNode> findDuplicateSubtrees(TreeNode root);

```

我来简单解释下题目，输入是一棵二叉树的根节点 ` root ` ，返回的是一个列表，里面装着若干个二叉树节点，这些节点对应的子树在原二叉树中是存在重复的。

说起来比较绕，举例来说，比如输入如下的二叉树：

![](https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%913/1.png)

首先，节点 4 本身可以作为一棵子树，且二叉树中有多个节点 4：

![](https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%913/2.png)

类似的，还存在两棵以 2 为根的重复子树：

![](https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%913/3.png)

那么，我们返回的 ` List ` 中就应该有两个 ` TreeNode ` ，值分别为 4 和 2（具体是哪个节点都无所谓）。

这题咋做呢？ **还是老套路，先思考，对于某一个节点，它应该做什么** 。

比如说，你站在图中这个节点 2 上：

![](https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%913/4.png)

如果你想知道以自己为根的子树是不是重复的，是否应该被加入结果列表中，你需要知道什么信息？

**你需要知道以下两点** ：

**1、以我为根的这棵二叉树（子树）长啥样** ？

**2、以其他节点为根的子树都长啥样** ？

这就叫知己知彼嘛，我得知道自己长啥样，还得知道别人长啥样，然后才能知道有没有人跟我重复，对不对？

**＿＿＿＿＿＿＿＿＿＿＿＿＿**

应合作方要求，本文不便在此发布，请扫码关注回复关键词「二叉树」查看：

![](https://labuladong.gitee.io/algo/images/qrcode.jpg)

## 手把手带你刷二叉搜索树（第一期）


读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 230. BST第K小的元素（中等） ](https://leetcode-cn.com/problems/kth-smallest-element-
in-a-bst)

[ 538. 二叉搜索树转化累加树（中等） ](https://leetcode-cn.com/problems/convert-bst-to-
greater-tree)

[ 1038. BST转累加树（中等） ](https://leetcode-cn.com/problems/binary-search-tree-to-
greater-sum-tree)

**———–**

PS： [ 刷题插件 ](https://mp.weixin.qq.com/s/OE1zPVPj0V2o82N4HtLQbw)集成了手把手刷二叉树功能，按照公式和套路讲解了 150 道二叉树题目，可手把手带你刷完二叉树分类的题目，迅速掌握递归思维。

前文手把手带你刷二叉树已经写了 [ 第一期 ](https://labuladong.gitee.io/algo/2/17/21/) ， [ 第二期 ](https://labuladong.gitee.io/algo/2/17/22/) 和 [
第三期 ](https://labuladong.gitee.io/algo/2/17/23/) ，今天写一篇二叉搜索树（Binary Search Tree，后文简写 BST）相关的文章，手把手带你刷 BST。

首先，BST 的特性大家应该都很熟悉了：

1、对于 BST 的每一个节点 ` node ` ，左子树节点的值都比 ` node ` 的值要小，右子树节点的值都比 ` node ` 的值大。

2、对于 BST 的每一个节点 ` node ` ，它的左侧子树和右侧子树都是 BST。

二叉搜索树并不算复杂，但我觉得它可以算是数据结构领域的半壁江山，直接基于 BST 的数据结构有 AVL 树，红黑树等等，拥有了自平衡性质，可以提供 logN 级别的增删查改效率；还有 B+ 树，线段树等结构都是基于 BST 的思想来设计的。

**从做算法题的角度来看 BST，除了它的定义，还有一个重要的性质：BST 的中序遍历结果是有序的（升序）** 。

也就是说，如果输入一棵 BST，以下代码可以将 BST 中每个节点的值升序打印出来：

```java
    void traverse(TreeNode root) {
        if (root == null) return;
        traverse(root.left);
        // 中序遍历代码位置
        print(root.val);
        traverse(root.right);
    }

```

那么根据这个性质，我们来做两道算法题。

### 寻找第 K 小的元素

这是力扣第 230 题「二叉搜索树中第K小的元素」，看下题目：

![](https://labuladong.gitee.io/algo/images/BST1/title.png)

这个需求很常见吧，一个直接的思路就是升序排序，然后找第 ` k ` 个元素呗。BST 的中序遍历其实就是升序排序的结果，找第 ` k `个元素肯定不是什么难事。

按照这个思路，可以直接写出代码：

```java
    int kthSmallest(TreeNode root, int k) {
        // 利用 BST 的中序遍历特性
        traverse(root, k);
        return res;
    }
    
    // 记录结果
    int res = 0;
    // 记录当前元素的排名
    int rank = 0;
    void traverse(TreeNode root, int k) {
        if (root == null) {
            return;
        }
        traverse(root.left, k);
        /* 中序遍历代码位置 */
        rank++;
        if (k == rank) {
            // 找到第 k 小的元素
            res = root.val;
            return;
        }
        /*****************/
        traverse(root.right, k);
    }

```

这道题就做完了，不过呢，还是要多说几句，因为这个解法并不是最高效的解法，而是仅仅适用于这道题。

我们旧文 [ 高效计算数据流的中位数 ](https://labuladong.gitee.io/algo/2/19/46/) 中就提过今天的这个问题：

> 如果让你实现一个在二叉搜索树中通过排名计算对应元素的方法 ` select(int k) ` ，你会怎么设计？

如果按照我们刚才说的方法，利用「BST 中序遍历就是升序排序结果」这个性质，每次寻找第 ` k ` 小的元素都要中序遍历一次，最坏的时间复杂度是 `O(N) ` ， ` N ` 是 BST 的节点个数。

要知道 BST 性质是非常牛逼的，像红黑树这种改良的自平衡 BST，增删查改都是 ` O(logN) ` 的复杂度，让你算一个第 ` k `小元素，时间复杂度竟然要 ` O(N) ` ，有点低效了。

所以说，计算第 ` k ` 小元素，最好的算法肯定也是对数级别的复杂度，不过这个依赖于 BST 节点记录的信息有多少。

我们想一下 BST 的操作为什么这么高效？就拿搜索某一个元素来说，BST 能够在对数时间找到该元素的根本原因还是在 BST的定义里，左子树小右子树大嘛，所以每个节点都可以通过对比自身的值判断去左子树还是右子树搜索目标值，从而避免了全树遍历，达到对数级复杂度。

那么回到这个问题，想找到第 ` k ` 小的元素，或者说找到排名为 ` k ` 的元素，如果想达到对数级复杂度，关键也在于每个节点得知道他自己排第几。

比如说你让我查找排名为 ` k ` 的元素，当前节点知道自己排名第 ` m ` ，那么我可以比较 ` m ` 和 ` k ` 的大小：

1、如果 ` m == k ` ，显然就是找到了第 ` k ` 个元素，返回当前节点就行了。

2、如果 ` k < m ` ，那说明排名第 ` k ` 的元素在左子树，所以可以去左子树搜索第 ` k ` 个元素。

3、如果 ` k > m ` ，那说明排名第 ` k ` 的元素在右子树，所以可以去右子树搜索第 ` k - m - 1 ` 个元素。

这样就可以将时间复杂度降到 ` O(logN) ` 了。

那么，如何让每一个节点知道自己的排名呢？

这就是我们之前说的，需要在二叉树节点中维护额外信息。 **每个节点需要记录，以自己为根的这棵二叉树有多少个节点** 。

也就是说，我们 ` TreeNode ` 中的字段应该如下：

```java
    class TreeNode {
        int val;
        // 以该节点为根的树的节点总数
        int size;
        TreeNode left;
        TreeNode right;
    }

```

有了 ` size ` 字段，外加 BST 节点左小右大的性质，对于每个节点 ` node ` 就可以通过 ` node.left ` 推导出 ` node
` 的排名，从而做到我们刚才说到的对数级算法。

当然， ` size ` 字段需要在增删元素的时候需要被正确维护，力扣提供的 ` TreeNode ` 是没有 ` size `这个字段的，所以我们这道题就只能利用 BST 中序遍历的特性实现了，但是我们上面说到的优化思路是 BST 的常见操作，还是有必要理解的。

### BST 转化累加树

力扣第 538 题和 1038 题都是这道题，完全一样，你可以把它们一块做掉。看下题目：

![](https://labuladong.gitee.io/algo/images/BST1/title1.png)

题目应该不难理解，比如图中的节点 5，转化成累加树的话，比 5 大的节点有 6，7，8，加上 5 本身，所以累加树上这个节点的值应该是 5+6+7+8=26。

我们需要把 BST 转化成累加树，函数签名如下：

```java
    TreeNode convertBST(TreeNode root)

```

按照二叉树的通用思路，需要思考每个节点应该做什么，但是这道题上很难想到什么思路。

BST 的每个节点左小右大，这似乎是一个有用的信息，既然累加和是计算大于等于当前值的所有元素之和，那么每个节点都去计算右子树的和，不就行了吗？

这是不行的。对于一个节点来说，确实右子树都是比它大的元素，但问题是它的父节点也可能是比它大的元素呀？这个没法确定的，我们又没有触达父节点的指针，所以二叉树的通用思路在这里用不了。

**其实，正确的解法很简单，还是利用 BST 的中序遍历特性** 。

刚才我们说了 BST 的中序遍历代码可以升序打印节点的值：

```java
    void traverse(TreeNode root) {
        if (root == null) return;
        traverse(root.left);
        // 中序遍历代码位置
        print(root.val);
        traverse(root.right);
    }

```

那如果我想降序打印节点的值怎么办？

很简单，只要把递归顺序改一下就行了：

```java
    void traverse(TreeNode root) {
        if (root == null) return;
        // 先递归遍历右子树
        traverse(root.right);
        // 中序遍历代码位置
        print(root.val);
        // 后递归遍历左子树
        traverse(root.left);
    }

```

**这段代码可以降序打印 BST 节点的值，如果维护一个外部累加变量` sum ` ，然后把 ` sum ` 赋值给 BST 中的每一个节点，不就将 BST 转化成累加树了吗 ** ？

看下代码就明白了：

```java
    TreeNode convertBST(TreeNode root) {
        traverse(root);
        return root;
    }
    
    // 记录累加和
    int sum = 0;
    void traverse(TreeNode root) {
        if (root == null) {
            return;
        }
        traverse(root.right);
        // 维护累加和
        sum += root.val;
        // 将 BST 转化成累加树
        root.val = sum;
        traverse(root.left);
    }

```

这道题就解决了，核心还是 BST 的中序遍历特性，只不过我们修改了递归顺序，降序遍历 BST 的元素值，从而契合题目累加树的要求。

简单总结下吧，BST 相关的问题，要么利用 BST 左小右大的特性提升算法效率，要么利用中序遍历的特性满足题目的要求，也就这么些事儿吧。

最后调查下，经过这几篇二叉树相关的系列文章，大家刷题有没有点感觉了？可以留言和我交流。本文对你有帮助的话，请三连~

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


## 手把手带你刷二叉搜索树（第二期）


读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 450. 删除二叉搜索树中的节点（中等） ](https://leetcode-cn.com/problems/delete-node-in-a-
bst)

[ 701. 二叉搜索树中的插入操作（中等） ](https://leetcode-cn.com/problems/insert-into-a-
binary-search-tree)

[ 700. 二叉搜索树中的搜索（简单） ](https://leetcode-cn.com/problems/search-in-a-binary-
search-tree)

[ 98. 验证二叉搜索树（中等） ](https://leetcode-cn.com/problems/validate-binary-search-
tree)

**———–**

PS： [ 刷题插件 ](https://mp.weixin.qq.com/s/OE1zPVPj0V2o82N4HtLQbw)集成了手把手刷二叉树功能，按照公式和套路讲解了 150 道二叉树题目，可手把手带你刷完二叉树分类的题目，迅速掌握递归思维。

我们前文 [ 手把手刷二叉搜索树（第一期） ](https://labuladong.gitee.io/algo/2/17/24/) 主要是利用二叉搜索树「中序遍历有序」的特性来解决了几道题目，本文来实现 BST 的基础操作：判断 BST
的合法性、增、删、查。其中「删」和「判断合法性」略微复杂。

### BST 简介

所谓二叉搜索树（Binary Search Tree，简称 BST）大家应该都不陌生，它是一种特殊的二叉树。

特殊在哪里呢？简单来说就是：左小右大。

BST 的完整定义如下：

1、BST 中任意一个节点的左子树所有节点的值都小于该节点的值，右子树所有节点的值都大于该节点的值。

2、BST 中任意一个节点的左右子树都是 BST。

有了 BST 的这种特性，就可以在二叉树中做类似二分搜索的操作，搜索一个元素的效率很高。

比如下面这就是一棵合法的二叉树：

![](https://labuladong.gitee.io/algo/images/BST/0.png)

对于 BST 相关的问题，你可能会经常看到类似下面这样的代码逻辑：

```java
    void BST(TreeNode root, int target) {
        if (root.val == target)
            // 找到目标，做点什么
        if (root.val < target) 
            BST(root.right, target);
        if (root.val > target)
            BST(root.left, target);
    }

```

这个代码框架其实和二叉树的遍历框架差不多，无非就是利用了 BST 左小右大的特性而已。

接下来我们讲几道二叉搜索树的必知必会题目。

### 一、判断 BST 的合法性

这里是有坑的哦，我们按照刚才的思路，每个节点自己要做的事不就是比较自己和左右孩子吗？看起来应该这样写代码：

```java
    boolean isValidBST(TreeNode root) {
        if (root == null) return true;
        if (root.left != null && root.val <= root.left.val)
            return false;
        if (root.right != null && root.val >= root.right.val)
            return false;
    
        return isValidBST(root.left)
            && isValidBST(root.right);
    }

```

但是这个算法出现了错误，BST 的每个节点应该要小于右边子树的所有节点，下面这个二叉树显然不是 BST，因为节点 10 的右子树中有一个节点 6，但是我们的算法会把它判定为合法 BST：

![](https://labuladong.gitee.io/algo/images/BST/%e5%81%87BST.png)

**出现问题的原因在于，对于每一个节点` root ` ，代码值检查了它的左右孩子节点是否符合左小右大的原则；但是根据 BST 的定义， ` root `的整个左子树都要小于 ` root.val ` ，整个右子树都要大于 ` root.val ` ** 。

问题是，对于某一个节点 ` root ` ，他只能管得了自己的左右子节点，怎么把 ` root ` 的约束传递给左右子树呢？

请看正确的代码：

```java
    boolean isValidBST(TreeNode root) {
        return isValidBST(root, null, null);
    }
    
    /* 限定以 root 为根的子树节点必须满足 max.val > root.val > min.val */
    boolean isValidBST(TreeNode root, TreeNode min, TreeNode max) {
        // base case
        if (root == null) return true;
        // 若 root.val 不符合 max 和 min 的限制，说明不是合法 BST
        if (min != null && root.val <= min.val) return false;
        if (max != null && root.val >= max.val) return false;
        // 限定左子树的最大值是 root.val，右子树的最小值是 root.val
        return isValidBST(root.left, min, root) 
            && isValidBST(root.right, root, max);
    }

```

**我们通过使用辅助函数，增加函数参数列表，在参数中携带额外信息，将这种约束传递给子树的所有节点，这也是二叉树算法的一个小技巧吧** 。

### 在 BST 中搜索元素

力扣第 700 题「二叉搜索树中的搜索」就是让你在 BST 中搜索值为 ` target ` 的节点，函数签名如下：

```java
    TreeNode searchBST(TreeNode root, int target);

```

如果是在一棵普通的二叉树中寻找，可以这样写代码：

```java
    TreeNode searchBST(TreeNode root, int target);
        if (root == null) return null;
        if (root.val == target) return root;
        // 当前节点没找到就递归地去左右子树寻找
        TreeNode left = searchBST(root.left, target);
        TreeNode right = searchBST(root.right, target);
    
        return left != null ? left : right;
    }

```

这样写完全正确，但这段代码相当于穷举了所有节点，适用于所有普通二叉树。那么应该如何充分利用信息，把 BST 这个「左小右大」的特性用上？

很简单，其实不需要递归地搜索两边，类似二分查找思想，根据 ` target ` 和 ` root.val `的大小比较，就能排除一边。我们把上面的思路稍稍改动：

```java
    TreeNode searchBST(TreeNode root, int target) {
        if (root == null) {
            return null;
        }
        // 去左子树搜索
        if (root.val > target) {
            return searchBST(root.left, target);
        }
        // 去右子树搜索
        if (root.val < target) {
            return searchBST(root.right, target);
        }
        return root;
    }

```

### 在 BST 中插入一个数

对数据结构的操作无非遍历 + 访问，遍历就是「找」，访问就是「改」。具体到这个问题，插入一个数，就是先找到插入位置，然后进行插入操作。

上一个问题，我们总结了 BST 中的遍历框架，就是「找」的问题。直接套框架，加上「改」的操作即可。 **一旦涉及「改」，函数就要返回` TreeNode `类型，并且对递归调用的返回值进行接收 ** 。

```java
    TreeNode insertIntoBST(TreeNode root, int val) {
        // 找到空位置插入新节点
        if (root == null) return new TreeNode(val);
        // if (root.val == val)
        //     BST 中一般不会插入已存在元素
        if (root.val < val) 
            root.right = insertIntoBST(root.right, val);
        if (root.val > val) 
            root.left = insertIntoBST(root.left, val);
        return root;
    }

```

### 三、在 BST 中删除一个数

这个问题稍微复杂，跟插入操作类似，先「找」再「改」，先把框架写出来再说：

```java
    TreeNode deleteNode(TreeNode root, int key) {
        if (root.val == key) {
            // 找到啦，进行删除
        } else if (root.val > key) {
            // 去左子树找
            root.left = deleteNode(root.left, key);
        } else if (root.val < key) {
            // 去右子树找
            root.right = deleteNode(root.right, key);
        }
        return root;
    }

```

找到目标节点了，比方说是节点 ` A ` ，如何删除这个节点，这是难点。因为删除节点的同时不能破坏 BST 的性质。有三种情况，用图片来说明。

**情况 1** ： ` A ` 恰好是末端节点，两个子节点都为空，那么它可以当场去世了。

![](https://labuladong.gitee.io/algo/images/BST/bst_deletion_case_1.png)

```java
    if (root.left == null && root.right == null)
        return null;

```

**情况 2** ： ` A ` 只有一个非空子节点，那么它要让这个孩子接替自己的位置。

![](https://labuladong.gitee.io/algo/images/BST/bst_deletion_case_2.png)

```java
    // 排除了情况 1 之后
    if (root.left == null) return root.right;
    if (root.right == null) return root.left;

```

**情况 3** ： ` A ` 有两个子节点，麻烦了，为了不破坏 BST 的性质， ` A `必须找到左子树中最大的那个节点，或者右子树中最小的那个节点来接替自己。我们以第二种方式讲解。

![](https://labuladong.gitee.io/algo/images/BST/bst_deletion_case_3.png)

```java
    if (root.left != null && root.right != null) {
        // 找到右子树的最小节点
        TreeNode minNode = getMin(root.right);
        // 把 root 改成 minNode
        root.val = minNode.val;
        // 转而去删除 minNode
        root.right = deleteNode(root.right, minNode.val);
    }

```

三种情况分析完毕，填入框架，简化一下代码：

```java
    TreeNode deleteNode(TreeNode root, int key) {
        if (root == null) return null;
        if (root.val == key) {
            // 这两个 if 把情况 1 和 2 都正确处理了
            if (root.left == null) return root.right;
            if (root.right == null) return root.left;
            // 处理情况 3
            // 获得右子树最小的节点
            TreeNode minNode = getMin(root.right);
            // 删除右子树最小的节点
            root.right = deleteNode(root.right, minNode.val);
            // 用右子树最小的节点替换 root 节点
            minNode.left = root.left;
            minNode.right = root.right;
            root = minNode;
        } else if (root.val > key) {
            root.left = deleteNode(root.left, key);
        } else if (root.val < key) {
            root.right = deleteNode(root.right, key);
        }
        return root;
    }
    
    TreeNode getMin(TreeNode node) {
        // BST 最左边的就是最小的
        while (node.left != null) node = node.left;
        return node;
    }

```

这样，删除操作就完成了。

注意一下，上述代码在处理情况 3 时通过一系列略微复杂的链表操作交换 ` root ` 和 ` minNode ` 两个节点：

```java
    // 处理情况 3
    // 获得右子树最小的节点
    TreeNode minNode = getMin(root.right);
    // 删除右子树最小的节点
    root.right = deleteNode(root.right, minNode.val);
    // 用右子树最小的节点替换 root 节点
    minNode.left = root.left;
    minNode.right = root.right;
    root = minNode;

```

有的读者可能会疑惑，替换 ` root ` 节点为什么这么麻烦，直接改 ` val ` 字段不就行了？看起来还更简洁易懂：

```java
    // 处理情况 3
    // 获得右子树最小的节点
    TreeNode minNode = getMin(root.right);
    // 删除右子树最小的节点
    root.right = deleteNode(root.right, minNode.val);
    // 用右子树最小的节点替换 root 节点
    root.val = minNode.val;

```

仅对于这道算法题来说是可以的，但这样操作并不完美，我们一般不会通过修改节点内部的值来交换节点。

因为在实际应用中，BST 节点内部的数据域是用户自定义的，可以非常复杂，而 BST 作为数据结构（一个工具人），其操作应该和内部存储的数据域解耦，所以我们更倾向于使用指针操作来交换节点，根本没必要关心内部数据。

不过这里我们暂时忽略这个细节，旨在突出 BST 基本操作的共性，以及借助框架逐层细化问题的思维方式。

### 最后总结

通过这篇文章，我们总结出了如下几个技巧：

1、如果当前节点会对下面的子节点有整体影响，可以通过辅助函数增长参数列表，借助参数传递信息。

2、在二叉树递归框架之上，扩展出一套 BST 代码框架：

```java
    void BST(TreeNode root, int target) {
        if (root.val == target)
            // 找到目标，做点什么
        if (root.val < target) 
            BST(root.right, target);
        if (root.val > target)
            BST(root.left, target);
    }

```

3、根据代码框架掌握了 BST 的增删查改操作。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


## 手把手带你刷二叉搜索树（第三期）


读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 96. 不同的二叉搜索树（简单） ](https://leetcode-cn.com/problems/unique-binary-search-
trees)

[ 95. 不同的二叉搜索树II（中等） ](https://leetcode-cn.com/problems/unique-binary-search-
trees-ii)

**———–**

PS： [ 刷题插件 ](https://mp.weixin.qq.com/s/OE1zPVPj0V2o82N4HtLQbw)集成了手把手刷二叉树功能，按照公式和套路讲解了 150 道二叉树题目，可手把手带你刷完二叉树分类的题目，迅速掌握递归思维。

之前写了两篇手把手刷 BST 算法题的文章， [ 第一篇 ](https://labuladong.gitee.io/algo/2/17/24/) 讲了中序遍历对 BST 的重要意义， [ 第二篇](https://labuladong.gitee.io/algo/2/17/25/) 写了 BST 的基本操作。

本文就来写手把手刷 BST 系列的第三篇，循序渐进地讲两道题，如何计算所有合法 BST。

第一道题是力扣第 96 题「不同的二叉搜索树」，给你输入一个正整数 ` n ` ，请你计算，存储 ` {1,2,3...,n} ` 这些值共有多少种不同的 BST 结构。

函数签名如下：

```java
    int numTrees(int n);

```

比如说输入 ` n = 3 ` ，算法返回 5，因为共有如下 5 种不同的 BST 结构存储 ` {1,2,3} ` ：

![](https://labuladong.gitee.io/algo/images/BST3/2.jpg)

这就是一个正宗的穷举问题，那么什么方式能够正确地穷举合法 BST 的数量呢？

我们前文说过，不要小看「穷举」，这是一件看起来简单但是比较有技术含量的事情，问题的关键就是不能数漏，也不能数多，你咋整？

之前 [手把手刷二叉树第一期](http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247487126&idx=1&sn=4de13e66397bc35970963c5a1330ce18&chksm=9bd7f09eaca0798853c41fba05ad5fa958b31054eba18b69c785ae92f4bd8e4cc7a2179d7838&scene=21#wechat_redirect) 说过，二叉树算法的关键就在于明确根节点需要做什么，其实 BST 作为一种特殊的二叉树，核心思路也是一样的。

举个例子，比如给算法输入`n = 5`，也就是说用`{1,2,3,4,5}`这些数字去构造 BST。

首先，这棵 BST 的根节点总共有几种情况？

显然有 5 种情况对吧，因为每个数字都可以作为根节点。

比如说我们固定`3`作为根节点，这个前提下能有几种不同的 BST 呢？

根据 BST 的特性，根节点的左子树都比根节点的值小，右子树的值都比根节点的值大。

所以如果固定`3`作为根节点，左子树节点就是`{1,2}`的组合，右子树就是`{4,5}`的组合。

**左子树的组合数和右子树的组合数乘积**就是`3`作为根节点时的 BST 个数。

![图片](C:\python_repo\data_pretreatment\crawler\640.webp)

我们这是说了`3`为根节点这一种特殊情况，其实其他的节点也是一样的。

那你可能会问，我们可以一眼看出`{1,2}`和`{4,5}`有几种组合，但是怎么让算法进行计算呢？

其实很简单，只需要递归就行了，我们可以写这样一个函数：

```java
// 定义：闭区间 [lo, hi] 的数字能组成 count(lo, hi) 种 BST
int count(int lo, int hi);
```

根据这个函数的定义，结合刚才的分析，可以写出代码：

```java
/* 主函数 */
int numTrees(int n) {
    // 计算闭区间 [1, n] 组成的 BST 个数
    return count(1, n);
}

/* 计算闭区间 [lo, hi] 组成的 BST 个数 */
int count(int lo, int hi) {
    // base case
    if (lo > hi) return 1;

    int res = 0;
    for (int i = lo; i <= hi; i++) {
        // i 的值作为根节点 root
        int left = count(lo, i - 1);
        int right = count(i + 1, hi);
        // 左右子树的组合数乘积是 BST 的总数
        res += left * right;
    }

    return res;
}
```

注意 base case，显然当`lo > hi`闭区间`[lo, hi]`肯定是个空区间，也就对应着空节点 null，虽然是空节点，但是也是一种情况，所以要返回 1 而不能返回 0。

这样，题目的要求已经实现了，但是时间复杂度非常高，肯定存在重叠子问题。

前文动态规划相关的问题多次讲过消除重叠子问题的方法，无非就是加一个备忘录：

```java
// 备忘录
int[][] memo;

int numTrees(int n) {
    // 备忘录的值初始化为 0
    memo = new int[n + 1][n + 1];
    return count(1, n);
}

int count(int lo, int hi) {
    if (lo > hi) return 1;
    // 查备忘录
    if (memo[lo][hi] != 0) {
        return memo[lo][hi];
    }

    int res = 0;
    for (int mid = lo; mid <= hi; mid++) {
        int left = count(lo, mid - 1);
        int right = count(mid + 1, hi);
        res += left * right;
    }
    // 将结果存入备忘录
    memo[lo][hi] = res;

    return res;
}
```

这样，这道题就完全解决了。

那么，如果给一个进阶题目，不止让你计算有几个不同的 BST，而是要你构建出所有合法的 BST，如何实现这个算法呢？

这道题就是力扣第 95 题「不同的二叉搜索树 II」，让你构建所有 BST，函数签名如下：

```java
List<TreeNode> generateTrees(int n);
```

比如说输入`n = 3`，算法返回一个列表，列表中存储着如下五棵 BST 的根节点：

![图片](C:\python_repo\data_pretreatment\crawler\640-16423603904401.webp)

**明白了上道题构造合法 BST 的方法，这道题的思路也是一样的**：

1、穷举`root`节点的所有可能。

2、递归构造出左右子树的所有合法 BST。

3、给`root`节点穷举所有左右子树的组合。

我们可以直接看代码：

```java
/* 主函数 */
public List<TreeNode> generateTrees(int n) {
    if (n == 0) return new LinkedList<>();
    // 构造闭区间 [1, n] 组成的 BST 
    return build(1, n);
}

/* 构造闭区间 [lo, hi] 组成的 BST */
List<TreeNode> build(int lo, int hi) {
    List<TreeNode> res = new LinkedList<>();
    // base case
    if (lo > hi) {
        res.add(null);
        return res;
    }

    // 1、穷举 root 节点的所有可能。
    for (int i = lo; i <= hi; i++) {
        // 2、递归构造出左右子树的所有合法 BST。
        List<TreeNode> leftTree = build(lo, i - 1);
        List<TreeNode> rightTree = build(i + 1, hi);
        // 3、给 root 节点穷举所有左右子树的组合。
        for (TreeNode left : leftTree) {
            for (TreeNode right : rightTree) {
                // i 作为根节点 root 的值
                TreeNode root = new TreeNode(i);
                root.left = left;
                root.right = right;
                res.add(root);
            }
        }
    }

    return res;
}
```

这样，两道题都解决了。

希望二叉树和 BST 的系列文章对你有帮助。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**

应合作方要求，本文不便在此发布，请扫码关注回复关键词「BST」查看：

![](https://labuladong.gitee.io/algo/images/qrcode.jpg)

## 美团面试官：你对后序遍历一无所知


读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 1373. 二叉搜索子树的最大键值和（困难） ](https://leetcode-cn.com/problems/maximum-sum-bst-
in-binary-tree)

**———–**

PS： [ 刷题插件 ](https://mp.weixin.qq.com/s/OE1zPVPj0V2o82N4HtLQbw)集成了手把手刷二叉树功能，按照公式和套路讲解了 150 道二叉树题目，可手把手带你刷完二叉树分类的题目，迅速掌握递归思维。

其实二叉树的题目真的不难，无非就是前中后序遍历框架来回倒嘛，但是对于有的题目，不同的遍历顺序时间复杂度不同。

之前面试美团，就遇到一道二叉树算法题，当时我是把解法写出来了，面试官说如果用后序遍历，时间复杂度可以更低。

本文就来分析一道类似的题目，通过二叉树的后序遍历，来大幅降低算法的复杂度。

[ 手把手刷二叉树第一期 ](https://labuladong.gitee.io/algo/2/17/21/) 说过 **二叉树相关题目最核心的思路是明确当前节点需要做的事情是什么** 。

我们再看看后序遍历的代码框架：

```java
    void traverse(TreeNode root) {
        traverse(root.left);
        traverse(root.right);
        /* 后序遍历代码的位置 */
        /* 在这里处理当前节点 */
    }

```

看这个代码框架，你说后序遍历什么时候出现呢？

**如果当前节点要做的事情需要通过左右子树的计算结果推导出来，就要用到后序遍历** 。

很多时候，后序遍历用得好，可以大幅提升算法效率。

我们今天就要讲一个经典的算法问题，可以直观地体会到这一点。

这是力扣第 1373 题「二叉搜索子树的最大键值和」，函数签名如下：

```java
    int maxSumBST(TreeNode root);

```

题目会给你输入一棵二叉树，这棵二叉树的子树中可能包含 **二叉搜索树** 对吧，请你找到 **节点之和最大的** 那棵二叉搜索树，返回它的节点值之和。

二叉搜索树（简写作 BST）的性质不用我多介绍了吧，简单说就是「左小右大」，对于每个节点，整棵左子树都比该节点的值小，​整棵右子树都比该节点的值大。

比如题目给了这个例子：

![](https://labuladong.gitee.io/algo/images/%e5%90%8e%e5%ba%8f%e9%81%8d%e5%8e%86/1.png)

如果输入这棵二叉树，算法应该返回 20，也就是图中绿圈的那棵子树的节点值之和，因为它是一棵 BST，且节点之和最大。

那有的读者可能会问，根据 BST 的定义，有没有可能一棵二叉树中不存在 BST？

不会的，因为按照 BST 的定义，任何一个单独的节点肯定是 BST，也就是说，再不济，二叉树最下面的叶子节点肯定是 BST。

比如说如果输入下面这棵二叉树：

![](https://labuladong.gitee.io/algo/images/%e5%90%8e%e5%ba%8f%e9%81%8d%e5%8e%86/2.png)

两个叶子节点 ` 1 ` 和 ` 2 ` 就是 BST，比较一下节点之和，算法应该返回 2。

好了，到这里，题目应该解释地很清楚了，下面我们来分析一下这道题应该怎么做。

刚才说了， **二叉树相关题目最核心的思路是明确当前节点需要做的事情是什么** 。

**那么我们想计算子树中 BST 的最大和，站在当前节点的视角，需要做什么呢** ？

1、我肯定得知道左右子树是不是合法的 BST，如果这俩儿子有一个不是 BST，以我为根的这棵树肯定不会是 BST，对吧。

2、如果左右子树都是合法的 BST，我得瞅瞅左右子树加上自己还是不是合法的 BST 了。因为按照 BST 的定义，当前节点的值应该大于左子树的最大值，小于右子树的最小值，否则就破坏了 BST 的性质。

3、因为题目要计算最大的节点之和，如果左右子树加上我自己还是一棵合法的 BST，也就是说以我为根的整棵树是一棵 BST，那我需要知道我们这棵 BST 的所有节点值之和是多少，方便和别的 BST 争个高下，对吧。

**根据以上三点，站在当前节点的视角，需要知道以下具体信息** ：

1、左右子树是否是 BST。

2、左子树的最大值和右子树的最小值。

3、左右子树的节点值之和。

只有知道了这几个值，我们才能满足题目的要求，后面我们会想方设法计算这些值。

现在可以尝试用伪码写出算法的大致逻辑：

```java
    // 全局变量，记录 BST 最大节点之和
    int maxSum = 0;
    
    /* 主函数 */
    public int maxSumBST(TreeNode root) {
        traverse(root);
        return maxSum;
    }
    
    /* 遍历二叉树 */
    void traverse(TreeNode root) {
        if (root == null) {
            return;
        }
    
        /******* 前序遍历位置 *******/
        // 判断左右子树是不是 BST
        if (!isBST(root.left) || !isBST(root.right)) {
            goto next;
        }
        // 计算左子树的最大值和右子树的最小值
        int leftMax = findMax(root.left);
        int rightMin = findMin(root.right);
        // 判断以 root 节点为根的树是不是 BST
        if (root.val <= leftMax || root.val >= rightMin) {
            goto next;
        }
        // 如果条件都符合，计算当前 BST 的节点之和
        int leftSum = findSum(root.left);
        int rightSum = findSum(root.right);
        int rootSum = leftSum + rightSum + root.val;
        // 计算 BST 节点的最大和
        this.maxSum = Math.max(maxSum, rootSum);
        /**************************/
    
        // 递归左右子树
        next:
        traverse(root.left);
        traverse(root.right);
    }
    
    /* 计算以 root 为根的二叉树的最大值 */
    int findMax(TreeNode root) {}
    
    /* 计算以 root 为根的二叉树的最小值 */
    int findMin(TreeNode root) {}
    
    /* 计算以 root 为根的二叉树的节点和 */
    int findSum(TreeNode root) {}
    
    /* 判断以 root 为根的二叉树是否是 BST */
    boolean isBST(TreeNode root) {}

```

这个代码逻辑应该是不难理解的，代码在前序遍历的位置把之前的分析都实现了一遍。

其中有四个辅助函数比较简单，我就不具体实现了，其中只有判断合法 BST 的函数稍有技术含量，前文 [ 二叉搜索树操作集锦](https://labuladong.gitee.io/algo/2/17/25/) 写过，这里就不展开了。

**稍作分析就会发现，这几个辅助函数都是递归函数，都要遍历输入的二叉树，外加` traverse `函数本身的递归，可以说是递归上加递归，所以这个解法的复杂度是非常高的 ** 。

但是根据刚才的分析，像 ` leftMax ` 、 ` rootSum ` 这些变量又都得算出来，否则无法完成题目的要求。

我们希望既算出这些变量，又避免辅助函数带来的额外复杂度，鱼和熊掌全都要！

其实是可以的， **只要把前序遍历变成后序遍历，让` traverse ` 函数把辅助函数做的事情顺便做掉 ** 。

其他代码不变，我们让 ` traverse ` 函数做一些计算任务，返回一个数组：

```java
    // 全局变量，记录 BST 最大节点之和
    int maxSum = 0;
    
    /* 主函数 */
    public int maxSumBST(TreeNode root) {
        traverse(root);
        return maxSum;
    }
    
    // 函数返回 int[]{ isBST, min, max, sum}
    int[] traverse(TreeNode root) {
    
        int[] left = traverse(root.left);
        int[] right = traverse(root.right);
    
        /******* 后序遍历位置 *******/
        // 通过 left 和 right 推导返回值
        // 并且正确更新 maxSum 变量
        /**************************/
    }

```

` traverse(root) ` 返回一个大小为 4 的 int 数组，我们暂且称它为 ` res ` ，其中：

` res[0] ` 记录以 ` root ` 为根的二叉树是否是 BST，若为 1 则说明是 BST，若为 0 则说明不是 BST；

` res[1] ` 记录以 ` root ` 为根的二叉树所有节点中的最小值；

` res[2] ` 记录以 ` root ` 为根的二叉树所有节点中的最大值；

` res[3] ` 记录以 ` root ` 为根的二叉树所有节点值之和。

其实这就是把之前分析中说到的几个值放到了 ` res ` 数组中， **最重要的是，我们要试图通过` left ` 和 ` right ` 正确推导出 `res ` 数组 ** 。

直接看代码实现吧：

```java
    int[] traverse(TreeNode root) {
        // base case
        if (root == null) {
            return new int[] {
                1, Integer.MAX_VALUE, Integer.MIN_VALUE, 0
            };
        }
        
        // 递归计算左右子树
        int[] left = traverse(root.left);
        int[] right = traverse(root.right);
        
        /******* 后序遍历位置 *******/
        int[] res = new int[4];
        // 这个 if 在判断以 root 为根的二叉树是不是 BST
        if (left[0] == 1 && right[0] == 1 &&
            root.val > left[2] && root.val < right[1]) {
            // 以 root 为根的二叉树是 BST
            res[0] = 1;
            // 计算以 root 为根的这棵 BST 的最小值
            res[1] = Math.min(left[1], root.val);
            // 计算以 root 为根的这棵 BST 的最大值
            res[2] = Math.max(right[2], root.val);
            // 计算以 root 为根的这棵 BST 所有节点之和
            res[3] = left[3] + right[3] + root.val;
            // 更新全局变量
            maxSum = Math.max(maxSum, res[3]);
        } else {
            // 以 root 为根的二叉树不是 BST
            res[0] = 0;
            // 其他的值都没必要计算了，因为用不到
        }
        /**************************/
        
        return res;
    }

```

这样，这道题就解决了， ` traverse ` 函数在遍历二叉树的同时顺便把之前辅助函数做的事情都做了，避免了在递归函数中调用递归函数，时间复杂度只有 O(N)。

你看，这就是后序遍历的妙用，相对前序遍历的解法，现在的解法不仅效率高，而且代码量少，比较优美。

**那肯定有读者问，后序遍历这么好，是不是就应该尽可能多用后序遍历** ？

其实也不是，主要是看题目，就好比 BST 的中序遍历是有序的一样。

这道题为什么用后序遍历呢，因为我们需要的这些变量都是可以通过后序遍历得到的。

你计算以 ` root ` 为根的二叉树的节点之和，是不是可以通过左右子树的和加上 ` root.val ` 计算出来？

你计算以 ` root ` 为根的二叉树的最大值/最小值，是不是可以通过左右子树的最大值/最小值和 ` root.val ` 比较出来？

你判断以 ` root ` 为根的二叉树是不是 BST，是不是得先判断左右子树是不是 BST？是不是还得看看左右子树的最大值和最小值？

文章开头说过， **如果当前节点要做的事情需要通过左右子树的计算结果推导出来，就要用到后序遍历** 。

因为以上几点都可以通过后序遍历的方式计算出来，所以这道题使用后序遍历肯定是最高效的。

**以我的刷题经验，我们要尽可能避免递归函数中调用其他递归函数** ，如果出现这种情况，大概率是代码实现有瑕疵，可以进行类似本文的优化来避免递归套递归。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


## 二叉树的序列化，就那几个框架，枯燥至极


读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 297. 二叉树的序列化和反序列化（困难） ](https://leetcode-cn.com/problems/serialize-and-
deserialize-binary-tree)

**———–**

PS： [ 刷题插件 ](https://mp.weixin.qq.com/s/OE1zPVPj0V2o82N4HtLQbw)集成了手把手刷二叉树功能，按照公式和套路讲解了 150 道二叉树题目，可手把手带你刷完二叉树分类的题目，迅速掌握递归思维。

JSON 的运用非常广泛，比如我们经常将变成语言中的结构体序列化成 JSON 字符串，存入缓存或者通过网络发送给远端服务，消费者接受 JSON
字符串然后进行反序列化，就可以得到原始数据了。这就是「序列化」和「反序列化」的目的，以某种固定格式组织字符串，使得数据可以独立于编程语言。

那么假设现在有一棵用 Java 实现的二叉树，我想把它序列化字符串，然后用 C++ 读取这棵并还原这棵二叉树的结构，怎么办？这就需要对二叉树进行「序列化」和「反序列化」了。

**本文会用前序、中序、后序遍历的方式来序列化和反序列化二叉树，进一步，还会用迭代式的层级遍历来解决这个问题** 。

接下来就用二叉树的遍历框架来给你看看二叉树到底能玩出什么骚操作。

### 一、题目描述

「二叉树的序列化与反序列化」就是给你输入一棵二叉树的根节点 ` root ` ，要求你实现如下一个类：

```java
    public class Codec {
    
        // 把一棵二叉树序列化成字符串
        public String serialize(TreeNode root) {}
    
        // 把字符串反序列化成二叉树
        public TreeNode deserialize(String data) {}
    }

```

我们可以用 ` serialize ` 方法将二叉树序列化成字符串，用 ` deserialize `方法将序列化的字符串反序列化成二叉树，至于以什么格式序列化和反序列化，这个完全由你决定。

比如说输入如下这样一棵二叉树：

![](https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e5%ba%8f%e5%88%97%e5%8c%96/1.jpg)

` serialize ` 方法也许会把它序列化成字符串 ` 2,1,#,6,3,#,## ` ，其中 ` ## ` 表示 ` null `指针，那么把这个字符串再输入 ` deserialize `方法，依然可以还原出这棵二叉树。也就是说，这两个方法会成对儿使用，你只要保证他俩能够自洽就行了。

想象一下，二叉树结该是一个二维平面内的结构，而序列化出来的字符串是一个线性的一维结构。
**所谓的序列化不过就是把结构化的数据「打平」，其实就是在考察二叉树的遍历方式** 。

二叉树的遍历方式有哪些？递归遍历方式有前序遍历，中序遍历，后序遍历；迭代方式一般是层级遍历。本文就把这些方式都尝试一遍，来实现 ` serialize `方法和 ` deserialize ` 方法。

### 二、前序遍历解法

前文 [ 学习数据结构和算法的框架思维 ](https://labuladong.gitee.io/algo/1/2/) 说过了二叉树的几种遍历方式，前序遍历框架如下：

```java
    void traverse(TreeNode root) {
        if (root == null) return;
    
        // 前序遍历的代码
    
        traverse(root.left);
        traverse(root.right);
    }

```

真的很简单，在递归遍历两棵子树之前写的代码就是前序遍历代码，那么请你看一看如下伪码：

```java
    LinkedList<Integer> res;
    void traverse(TreeNode root) {
        if (root == null) {
            // 暂且用数字 -1 代表空指针 null
            res.addLast(-1);
            return;
        }
    
        /****** 前序遍历位置 ******/
        res.addLast(root.val);
        /***********************/
    
        traverse(root.left);
        traverse(root.right);
    }

```

调用 ` traverse ` 函数之后，你是否可以立即想出这个 ` res ` 列表中元素的顺序是怎样的？比如如下二叉树（ ` ## ` 代表空指针 null），可以直观看出前序遍历做的事情：

![](https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e5%ba%8f%e5%88%97%e5%8c%96/1.jpeg)

那么 ` res = [1,2,-1,4,-1,-1,3,-1,-1] ` ，这就是将二叉树「打平」到了一个列表中，其中 -1 代表 null。

那么，将二叉树打平到一个字符串中也是完全一样的：

```java
    // 代表分隔符的字符
    String SEP = ",";
    // 代表 null 空指针的字符
    String NULL = "#";
    // 用于拼接字符串
    StringBuilder sb = new StringBuilder();
    
    /* 将二叉树打平为字符串 */
    void traverse(TreeNode root, StringBuilder sb) {
        if (root == null) {
            sb.append(NULL).append(SEP);
            return;
        }
    
        /****** 前序遍历位置 ******/
        sb.append(root.val).append(SEP);
        /***********************/
    
        traverse(root.left, sb);
        traverse(root.right, sb);
    }

```

` StringBuilder ` 可以用于高效拼接字符串，所以也可以认为是一个列表，用 ` , ` 作为分隔符，用 ` ## ` 表示空指针 null，调用完 ` traverse ` 函数后， ` StringBuilder `中的字符串应该是 ` 1,2,#,4,#,#,3,#,#, ` 。

至此，我们已经可以写出序列化函数 ` serialize ` 的代码了：

```java
    String SEP = ",";
    String NULL = "#";
    
    /* 主函数，将二叉树序列化为字符串 */
    String serialize(TreeNode root) {
        StringBuilder sb = new StringBuilder();
        serialize(root, sb);
        return sb.toString();
    }
    
    /* 辅助函数，将二叉树存入 StringBuilder */
    void serialize(TreeNode root, StringBuilder sb) {
        if (root == null) {
            sb.append(NULL).append(SEP);
            return;
        }
    
        /****** 前序遍历位置 ******/
        sb.append(root.val).append(SEP);
        /***********************/
    
        serialize(root.left, sb);
        serialize(root.right, sb);
    }

```

现在，思考一下如何写 ` deserialize ` 函数，将字符串反过来构造二叉树。

首先我们可以把字符串转化成列表：

```java
    String data = "1,2,#,4,#,#,3,#,#,";
    String[] nodes = data.split(",");

```

这样， ` nodes ` 列表就是二叉树的前序遍历结果，问题转化为：如何通过二叉树的前序遍历结果还原一棵二叉树？

> PS：一般语境下，单单前序遍历结果是不能还原二叉树结构的，因为缺少空指针的信息，至少要得到前、中、后序遍历中的两种才能还原二叉树。但是这里的 `> node ` 列表包含空指针的信息，所以只使用 ` node ` 列表就可以还原二叉树。

根据我们刚才的分析， ` nodes ` 列表就是一棵打平的二叉树：

![](https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e5%ba%8f%e5%88%97%e5%8c%96/1.jpeg)

那么，反序列化过程也是一样， **先确定根节点` root ` ，然后遵循前序遍历的规则，递归生成左右子树即可 ** ：

**＿＿＿＿＿＿＿＿＿＿＿＿＿**

应合作方要求，本文不便在此发布，请扫码关注回复关键词「序列化」查看：

![](https://labuladong.gitee.io/algo/images/qrcode.jpg)

## 题目不让我干什么，我偏要干什么


读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 341. 扁平化嵌套列表迭代器（中等） ](https://leetcode-cn.com/problems/flatten-nested-list-
iterator)

**———–**

PS： [ 刷题插件 ](https://mp.weixin.qq.com/s/OE1zPVPj0V2o82N4HtLQbw)集成了手把手刷二叉树功能，按照公式和套路讲解了 150 道二叉树题目，可手把手带你刷完二叉树分类的题目，迅速掌握递归思维。

今天来讲一道非常有启发性的设计题目，为什么说它有启发性，我们后面再说。

### 一、题目描述

这是 LeetCode 第 341 题扁平化嵌套列表迭代器，我来描述一下题目：

首先，现在有一种数据结构 ` NestedInteger ` ， **这个结构中存的数据可能是一个` Integer ` 整数，也可能是一个 `NestedInteger ` 列表 ** 。注意，这个列表里面装着的是 ` NestedInteger `，也就是说这个列表中的每一个元素可能是个整数，可能又是个列表，这样无限递归嵌套下去……

` NestedInteger ` 有如下 API：

```java
    public class NestedInteger {
        // 如果其中存的是一个整数，则返回 true，否则返回 false
        public boolean isInteger();
    
        // 如果其中存的是一个整数，则返回这个整数，否则返回 null
        public Integer getInteger();
    
        // 如果其中存的是一个列表，则返回这个列表，否则返回 null
        public List<NestedInteger> getList();
    }

```

我们的算法会被输入一个 ` NestedInteger ` 列表，我们需要做的就是写一个迭代器类，将这个带有嵌套结构 ` NestedInteger `的列表「拍平」：

```java
    public class NestedIterator implements Iterator<Integer> {
        // 构造器输入一个 NestedInteger 列表
        public NestedIterator(List<NestedInteger> nestedList) {}
        
        // 返回下一个整数
        public Integer next() {}
    
        // 是否还有下一个元素？
        public boolean hasNext() {}
    }

```

我们写的这个类会被这样调用， **先调用` hasNext ` 方法，后调用 ` next ` 方法 ** ：

```java
    NestedIterator i = new NestedIterator(nestedList);
    while (i.hasNext())
        print(i.next());

```

![](https://labuladong.gitee.io/algo/images/nestedList/title.jpg)

比如示例 1，输入的列表里有三个 ` NestedInteger ` ，两个列表型的 ` NestedInteger ` 和一个整数型的 `NestedInteger ` 。

学过设计模式的朋友应该知道，迭代器也是设计模式的一种，目的就是为调用者屏蔽底层数据结构的细节，简单地通过 ` hasNext ` 和 ` next `方法有序地进行遍历。

为什么说这个题目很有启发性呢？因为我最近在用一款类似印象笔记的软件，叫做 Notion（挺有名的）。这个软件的一个亮点就是「万物皆 block」，比如说标题、页面、表格都是 block。有的 block
甚至可以无限嵌套，这就打破了传统笔记本「文件夹」->「笔记本」->「笔记」的三层结构。

回想这个算法问题， ` NestedInteger ` 结构实际上也是一种支持无限嵌套的结构，而且可以同时表示整数和列表两种不同类型，我想 Notion 的核心数据结构 block 估计也是这样的一种设计思路。

那么话说回来，对于这个算法问题，我们怎么解决呢？ ` NestedInteger `结构可以无限嵌套，怎么把这个结构「打平」，为迭代器的调用者屏蔽底层细节，得到扁平化的输出呢？

**＿＿＿＿＿＿＿＿＿＿＿＿＿**

应合作方要求，本文不便在此发布，请扫码关注回复关键词「迭代器」查看：

![](https://labuladong.gitee.io/algo/images/qrcode.jpg)

## Git原理之最近公共祖先


读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 236. 二叉树的最近公共祖先（中等） ](https://leetcode-cn.com/problems/lowest-common-
ancestor-of-a-binary-tree/)

**———–**

PS： [ 刷题插件 ](https://mp.weixin.qq.com/s/OE1zPVPj0V2o82N4HtLQbw)集成了手把手刷二叉树功能，按照公式和套路讲解了 150 道二叉树题目，可手把手带你刷完二叉树分类的题目，迅速掌握递归思维。

如果说笔试的时候喜欢考各种动归回溯的骚操作，面试其实最喜欢考比较经典的问题，难度不算太大，而且也比较实用。

上篇文章 [ 四个命令玩转 Git ](https://labuladong.gitee.io/algo/5/40/) 写了 Git 最常用的命令，没有提分支合并，其实分支合并没什么困难的，主要就是 `merge ` 和 ` rebase ` 两种方式。本文就用 Git 的 ` rebase ` 工作方式引出一个经典的算法问题：最近公共祖先（Lowest Common Ancestor，简称 LCA）。

比如 ` git pull ` 这个命令，我们经常会用，它默认是使用 ` merge ` 方式将远端别人的修改拉到本地；如果带上参数 ` git pull -r ` ，就会使用 ` rebase ` 的方式将远端修改拉到本地。

这二者最直观的区别就是： ` merge ` 方式合并的分支会有很多「分叉」，而 ` rebase ` 方式合并的分支就是一条直线。

**对于多人协作，` merge ` 方式并不好 ** ，举例来说，之前有很多朋友参加了在 GitHub 上的仓库翻译工作，GitHub 的 Pull Request 功能是使用 ` merge ` 方式，所以你看
fucking-algorithm 仓库的 Git 历史：

![](https://labuladong.gitee.io/algo/images/%e5%85%ac%e5%85%b1%e7%a5%96%e5%85%88/git.jpg)

画面看起来很炫酷，但实际上我们并不希望出现这种情形的。你想想，光是合并别人的代码就这般群魔乱舞，如果说你本地还有多个开发分支，那画面肯定更杂乱，杂乱就意味着很容易出问题，
**所以一般来说，实际工作中更推荐使用` rebase ` 方式合并代码 ** 。

那么问题来了， ` rebase ` 是如何将两条不同的分支合并到同一条分支的呢：

![](https://labuladong.gitee.io/algo/images/%e5%85%ac%e5%85%b1%e7%a5%96%e5%85%88/1.jpeg)

上图的情况是，我站在 ` dev ` 分支，使用 ` git rebase master ` ，然后就会把 ` dev ` 接到 ` master `分支之上。Git 是这么做的：

**首先，找到这两条分支的最近公共祖先` LCA ` ，然后从 ` master ` 节点开始，重演 ` LCA ` 到 ` dev ` 几个 `commit ` 的修改 ** ，如果这些修改和 ` LCA ` 到 ` master ` 的 ` commit `有冲突，就会提示你手动解决冲突，最后的结果就是把 ` dev ` 的分支完全接到 ` master ` 上面。

那么，Git 是如何找到两条不同分支的最近公共祖先的呢？这就是一个经典的算法问题了，下面来详解。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**

应合作方要求，本文不便在此发布，请扫码关注回复关键词「lca」查看：

![](https://labuladong.gitee.io/algo/images/qrcode.jpg)

## 如何计算完全二叉树的节点数


读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 222. 完全二叉树的节点个数（中等） ](https://leetcode-cn.com/problems/count-complete-tree-
nodes)

**———–**

如果让你数一下一棵普通二叉树有多少个节点，这很简单，只要在二叉树的遍历框架上加一点代码就行了。

但是，如果给你一棵完全二叉树，让你计算它的节点个数，你会不会？算法的时间复杂度是多少？这个算法的时间复杂度应该是 O(logN*logN)，如果你心中的算法没有达到高效，那么本文就是给你写的。

首先要明确一下两个关于二叉树的名词「完全二叉树」和「满二叉树」。

我们说的 **完全二叉树** 如下图，每一层都是紧凑靠左排列的：

![](https://labuladong.gitee.io/algo/images/complete_tree/complete.png)

我们说的 **满二叉树** 如下图，是一种特殊的完全二叉树，每层都是是满的，像一个稳定的三角形：

![](https://labuladong.gitee.io/algo/images/complete_tree/perfect.png)

说句题外话，关于这两个定义，中文语境和英文语境似乎有点区别，我们说的完全二叉树对应英文 Complete Binary Tree，没有问题。但是我们说的满二叉树对应英文 Perfect Binary Tree，而英文中的 Full
Binary Tree 是指一棵二叉树的所有节点要么没有孩子节点，要么有两个孩子节点。如下：

![](https://labuladong.gitee.io/algo/images/complete_tree/trees.png)

以上定义出自 wikipedia，这里就是顺便一提，其实名词叫什么都无所谓，重要的是算法操作。
**本文就按我们中文的语境，记住「满二叉树」和「完全二叉树」的区别，等会会用到** 。

### 一、思路分析

现在回归正题，如何求一棵完全二叉树的节点个数呢？

```java
    // 输入一棵完全二叉树，返回节点总数
    int countNodes(TreeNode root);

```

如果是一个 **普通** 二叉树，显然只要向下面这样遍历一边即可，时间复杂度 O(N)：

```java
    public int countNodes(TreeNode root) {
        if (root == null) return 0;
        return 1 + countNodes(root.left) + countNodes(root.right);
    }

```

那如果是一棵 **满** 二叉树，节点总数就和树的高度呈指数关系：

```java
    public int countNodes(TreeNode root) {
        int h = 0;
        // 计算树的高度
        while (root != null) {
            root = root.left;
            h++;
        }
        // 节点总数就是 2^h - 1
        return (int)Math.pow(2, h) - 1;
    }

```

**完全** 二叉树比普通二叉树特殊，但又没有满二叉树那么特殊，计算它的节点总数，可以说是普通二叉树和完全二叉树的结合版，先看代码：

```java
    public int countNodes(TreeNode root) {
        TreeNode l = root, r = root;
        // 记录左、右子树的高度
        int hl = 0, hr = 0;
        while (l != null) {
            l = l.left;
            hl++;
        }
        while (r != null) {
            r = r.right;
            hr++;
        }
        // 如果左右子树的高度相同，则是一棵满二叉树
        if (hl == hr) {
            return (int)Math.pow(2, hl) - 1;
        }
        // 如果左右高度不同，则按照普通二叉树的逻辑计算
        return 1 + countNodes(root.left) + countNodes(root.right);
    }

```

结合刚才针对满二叉树和普通二叉树的算法，上面这段代码应该不难理解，就是一个结合版，但是 **其中降低时间复杂度的技巧是非常微妙的** 。

### 二、复杂度分析

开头说了，这个算法的时间复杂度是 O(logN*logN)，这是怎么算出来的呢？

直觉感觉好像最坏情况下是 O(N*logN) 吧，因为之前的 while 需要 logN 的时间，最后要 O(N) 的时间向左右子树递归：

```java
    return 1 + countNodes(root.left) + countNodes(root.right);

```

**关键点在于，这两个递归只有一个会真的递归下去，另一个一定会触发` hl == hr ` 而立即返回，不会递归下去 ** 。

为什么呢？原因如下：

**一棵完全二叉树的两棵子树，至少有一棵是满二叉树** ：

![](https://labuladong.gitee.io/algo/images/complete_tree/1.jpg)

看图就明显了吧，由于完全二叉树的性质，其子树一定有一棵是满的，所以一定会触发 ` hl == hr ` ，只消耗 O(logN) 的复杂度而不会继续递归。

综上，算法的递归深度就是树的高度 O(logN)，每次递归所花费的时间就是 while 循环，需要 O(logN)，所以总体的时间复杂度是 O(logN*logN)。

所以说，「完全二叉树」这个概念还是有它存在的原因的，不仅适用于数组实现二叉堆，而且连计算节点总数这种看起来简单的操作都有高效的算法实现。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


## 二叉树八股文：递归改迭代


**———–**

PS： [ 刷题插件 ](https://mp.weixin.qq.com/s/OE1zPVPj0V2o82N4HtLQbw)集成了手把手刷二叉树功能，按照公式和套路讲解了 150 道二叉树题目，可手把手带你刷完二叉树分类的题目，迅速掌握递归思维。

之前经常讲涉及递归的算法题，我说过写递归算法的一个技巧就是不要试图跳进递归细节，而是从递归框架上思考，从函数定义去理解递归函数到底该怎么实现。

而且我们前文 [ 学习数据结构和算法的框架思维 ](https://labuladong.gitee.io/algo/1/2/)特别强调过，练习递归的框架思维最好方式就是从二叉树相关题目开始刷，前文也有好几篇手把手带你刷二叉树和二叉搜索树的文章：

* [ 手把手带你刷二叉树（第一期） ](https://labuladong.gitee.io/algo/2/17/21/)
* [ 手把手带你刷二叉树（第二期） ](https://labuladong.gitee.io/algo/2/17/22/)
* [ 手把手带你刷二叉树（第三期） ](https://labuladong.gitee.io/algo/2/17/23/)
* [ 手把手带你刷二叉搜索树（第一期） ](https://labuladong.gitee.io/algo/2/17/24/)
* [ 手把手带你刷二叉搜索树（第二期） ](https://labuladong.gitee.io/algo/2/17/25/)
* [ 手把手带你刷二叉搜索树（第三期） ](https://labuladong.gitee.io/algo/2/17/26/)

之前的文章全部都是运用二叉树的递归框架，帮你透过现象看本质，明白二叉树的各种题目本质都是前中后序遍历衍生出来的。

前文 [ BFS 算法框架详解 ](https://labuladong.gitee.io/algo/4/28/110/) 是利用队列迭代地遍历二叉树，不过使用的是层级遍历，没有递归遍历中的前中后序之分。

由于现在面试越来越卷，很多读者在后台问我如何将前中后序的递归框架改写成迭代形式。

我以前背过一些迭代实现二叉树前中后序遍历的代码模板，比较短小，容易记，但通用性较差。

通用性较差的意思是说，模板只是针对「用迭代的方式返回二叉树前/中/后序的遍历结果」这个问题，函数签名类似这样，返回一个 ` TreeNode ` 列表：

```java
    List<TreeNode> traverse(TreeNode root);

```

如果给一些稍微复杂的二叉树问题，比如 [ 最近公共祖先 ](https://labuladong.gitee.io/algo/2/17/30/) ， [ 二叉搜索子树的最大键值和](https://labuladong.gitee.io/algo/2/17/27/) ，想把这些递归解法改成迭代，就无能为力了。

**而我想要的是一个万能的模板，可以把一切二叉树递归算法都改成迭代** 。

换句话说，类似二叉树的递归框架：

```java
    void traverse(TreeNode root) {
        if (root == null) return;
        /* 前序遍历代码位置 */
        traverse(root.left);
        /* 中序遍历代码位置 */
        traverse(root.right);
        /* 后序遍历代码位置 */
    }

```

迭代框架也应该有前中后序代码的位置：

```java
    void traverse(TreeNode root) {
        while (...) {
            if (...) {
              /* 前序遍历代码位置 */
            }
            if (...) {
              /* 中序遍历代码位置 */
            }
            if (...) {
              /* 后序遍历代码位置 */
            }
        }
    }

```

我如果想把递归改成迭代，直接把递归解法中前中后序对应位置的代码复制粘贴到迭代框架里，就可以直接运行，得到正确的结果。

理论上，所有递归算法都可以利用栈改成迭代的形式，因为计算机本质上就是借助栈来迭代地执行递归函数的。

**所以本文就来利用「栈」模拟函数递归的过程，总结一套二叉树通用迭代遍历框架** 。

### 递归框架改为迭代

参加过我的二叉树专项训练的读者应该知道，二叉树的递归框架中，前中后序遍历位置就是几个特殊的时间点：

前序遍历位置的代码，会在刚遍历到当前节点 ` root ` ，遍历 ` root ` 的左右子树之前执行；

中序遍历位置的代码，会在在遍历完当前节点 ` root ` 的左子树，即将开始遍历 ` root ` 的右子树的时候执行；

后序遍历位置的代码，会在遍历完以当前节点 ` root ` 为根的整棵子树之后执行。

![](https://labuladong.gitee.io/algo/images/%e8%bf%ad%e4%bb%a3%e9%81%8d%e5%8e%86%e4%ba%8c%e5%8f%89%e6%a0%91/1.jpeg)

如果从递归代码上来看，上述结论是很容易理解的：

```java
    void traverse(TreeNode root) {
        if (root == null) return;
        /* 前序遍历代码位置 */
        traverse(root.left);
        /* 中序遍历代码位置 */
        traverse(root.right);
        /* 后序遍历代码位置 */
    }

```

**不过，如果我们想将递归算法改为迭代算法，就不能从框架上理解算法的逻辑，而要深入细节，思考计算机是如何进行递归的** 。

假设计算机运行函数 ` A ` ，就会把 ` A ` 放到调用栈里面，如果 ` A ` 又调用了函数 ` B ` ，则把 ` B ` 压在 ` A `上面，如果 ` B ` 又调用了 ` C ` ，那就再把 ` C ` 压到 ` B ` 上面……

当 ` C ` 执行结束后， ` C ` 出栈，返回值传给 ` B ` ， ` B ` 执行完后出栈，返回值传给 ` A ` ，最后等 ` A `执行完，返回结果并出栈，此时调用栈为空，整个函数调用链结束。

我们递归遍历二叉树的函数也是一样的，当函数被调用时，被压入调用栈，当函数结束时，从调用栈中弹出。

那么我们可以写出下面这段代码模拟递归调用的过程：

```java
    // 模拟系统的函数调用栈
    Stack<TreeNode> stk = new Stack<>();
    
    void traverse(TreeNode root) {
        if (root == null) return;
        // 函数开始时压入调用栈
        stk.push(root);
        traverse(root.left);
        traverse(root.right);
        // 函数结束时离开调用栈
        stk.pop();
    }

```

如果在前序遍历的位置入栈，后序遍历的位置出栈， ` stk ` 中的节点变化情况就反映了 ` traverse `函数的递归过程（绿色节点就是被压入栈中的节点，灰色节点就是弹出栈的节点）：

![](https://labuladong.gitee.io/algo/images/%e8%bf%ad%e4%bb%a3%e9%81%8d%e5%8e%86%e4%ba%8c%e5%8f%89%e6%a0%91/1.gif)

简单说就是这样一个流程：

**1、拿到一个节点，就一路向左遍历（因为` traverse(root.left) ` 排在前面），把路上的节点都压到栈里 ** 。

**2、往左走到头之后就开始退栈，看看栈顶节点的右指针，非空的话就重复第 1 步** 。

写成迭代代码就是这样：

```java
    private Stack<TreeNode> stk = new Stack<>();
    
    public List<Integer> traverse(TreeNode root) {
        pushLeftBranch(root);
        
        while (!stk.isEmpty()) {
            TreeNode p = stk.pop();
            pushLeftBranch(p.right);
        }
    }
    
    // 左侧树枝一撸到底，都放入栈中
    private void pushLeftBranch(TreeNode p) {
        while (p != null) {
            stk.push(p);
            p = p.left;
        }
    }

```

上述代码虽然已经可以模拟出递归函数的运行过程，不过还没有找到递归代码中的前中后序代码位置，所以需要进一步修改。

### 迭代代码框架

想在迭代代码中体现前中后序遍历，关键点在哪里？

**当我从栈中拿出一个节点` p ` ，我应该想办法搞清楚这个节点 ` p ` 左右子树的遍历情况 ** 。

如果 ` p ` 的左右子树都没有被遍历，那么现在对 ` p ` 进行操作就属于前序遍历代码。

如果 ` p ` 的左子树被遍历过了，而右子树没有被遍历过，那么现在对 ` p ` 进行操作就属于中序遍历代码。

如果 ` p ` 的左右子树都被遍历过了，那么现在对 ` p ` 进行操作就属于后序遍历代码。

上述逻辑写成伪码如下：

```java
    private Stack<TreeNode> stk = new Stack<>();
    
    public List<Integer> traverse(TreeNode root) {
        pushLeftBranch(root);
        
        while (!stk.isEmpty()) {
            TreeNode p = stk.peek();
            
            if (p 的左子树被遍历完了) {
                /*******************/
                /** 中序遍历代码位置 **/
                /*******************/
                // 去遍历 p 的右子树
                pushLeftBranch(p.right);
            }
    
            if (p 的右子树被遍历完了) {
                /*******************/
                /** 后序遍历代码位置 **/
                /*******************/
                // 以 p 为根的树遍历完了，出栈
                stk.pop();
            }
        }
    }
    
    private void pushLeftBranch(TreeNode p) {
        while (p != null) {
            /*******************/
            /** 前序遍历代码位置 **/
            /*******************/
            stk.push(p);
            p = p.left;
        }
    }

```

有刚才的铺垫，这段代码应该是不难理解的，关键是如何判断 ` p ` 的左右子树到底被遍历过没有呢？

其实很简单，我们只需要维护一个 ` visited ` 指针，指向「上一次遍历完成的根节点」，就可以判断 ` p ` 的左右子树遍历情况了

**下面是迭代遍历二叉树的完整代码框架** ：

```java
    // 模拟函数调用栈
    private Stack<TreeNode> stk = new Stack<>();
    
    // 左侧树枝一撸到底
    private void pushLeftBranch(TreeNode p) {
        while (p != null) {
            /*******************/
            /** 前序遍历代码位置 **/
            /*******************/
            stk.push(p);
            p = p.left;
        }
    }
    
    public List<Integer> traverse(TreeNode root) {
        // 指向上一次遍历完的子树根节点
        TreeNode visited = new TreeNode(-1);
        // 开始遍历整棵树
        pushLeftBranch(root);
        
        while (!stk.isEmpty()) {
            TreeNode p = stk.peek();
            
            // p 的左子树被遍历完了，且右子树没有被遍历过
            if ((p.left == null || p.left == visited) 
              && p.right != visited) {
                /*******************/
                /** 中序遍历代码位置 **/
                /*******************/
                // 去遍历 p 的右子树
                pushLeftBranch(p.right);
            }
            // p 的右子树被遍历完了
            if (p.right == null || p.right == visited) {
                /*******************/
                /** 后序遍历代码位置 **/
                /*******************/
                // 以 p 为根的子树被遍历完了，出栈
                // visited 指针指向 p
                visited = stk.pop();
            }
        }
    }

```

代码中最有技巧性的是这个 ` visited ` 指针，它记录最近一次遍历完的子树根节点（最近一次 ` pop​ ` 出栈的节点），我们可以根据对比 ` p
` 的左右指针和 ` visited ` 是否相同来判断节点 ` p ` 的左右子树是否被遍历过，进而分离出前中后序的代码位置。

> PS： ` visited ` 指针初始化指向一个新 new 出来的二叉树节点，相当于一个特殊值，目的是避免和输入二叉树中的节点重复。

**只需把递归算法中的前中后序位置的代码复制粘贴到上述框架的对应位置，就可以把任意递归的二叉树算法改写成迭代形式了** 。

比如，让你返回二叉树后序遍历的结果，你就可以这样写：

```java
    private Stack<TreeNode> stk = new Stack<>();
    
    public List<Integer> postorderTraversal(TreeNode root) {
        // 记录后序遍历的结果
        List<Integer> postorder = new ArrayList<>();
        TreeNode visited = new TreeNode(-1);
    
        pushLeftBranch(root);
        while (!stk.isEmpty()) {
            TreeNode p = stk.peek();
    
            if ((p.left == null || p.left == visited) 
              && p.right != visited) {
                pushLeftBranch(p.right);
            }
    
            if (p.right == null || p.right == visited) {
                // 后序遍历代码位置
                postorder.add(p.val);
                visited = stk.pop();
            }
        }
    
        return postorder;
    }
    
    private void pushLeftBranch(TreeNode p) {
        while (p != null) {
            stk.push(p);
            p = p.left;
        }
    }

```

当然，任何一个二叉树的算法，如果你想把递归改成迭代，都可以套用这个框架，只要把递归的前中后序位置的代码对应过来就行了。

迭代解法到这里就搞定了， **不过我还是想强调，除了 BFS 层级遍历之外，二叉树的题目还是用递归的方式来做，因为递归是最符合二叉树结构特点的** 。

说到底，这个迭代解法就是在用栈模拟递归调用，所以对照着递归解法，应该不难理解和记忆。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


# 手把手刷图算法

1、《算法秘籍》和《刷题笔记》两本 PDF 下载 [ 点这里](https://mp.weixin.qq.com/s/X-fE9sR4BLi6T9pn7xP4pg) 。

2、刷题插件下载及使用手册 [ 点这里 ](https://mp.weixin.qq.com/s/wIxflO1dvXzDlibhEcENcQ) 。

3、公众号菜单栏参与 [ 21 天算法挑战活动 ](https://mp.weixin.qq.com/s/eUG2OOzY3k_ZTz-CFvtv5Q) 。

## 图论基础


读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 797. 所有可能的路径（中等） ](https://leetcode-cn.com/problems/all-paths-from-source-
to-target/)

**———–**

经常有读者问我「图」这种数据结构，其实我在 [ 学习数据结构和算法的框架思维 ](https://labuladong.gitee.io/algo/1/2/)中说过，虽然图可以玩出更多的算法，解决更复杂的问题，但本质上图可以认为是多叉树的延伸。

面试笔试很少出现图相关的问题，就算有，大多也是简单的遍历问题，基本上可以完全照搬多叉树的遍历。

那么，本文依然秉持我们号的风格，只讲「图」最实用的，离我们最近的部分，让你心里对图有个直观的认识，文末我给出了其他经典图论算法，理解本文后应该都可以拿下的。

### 图的逻辑结构和具体实现

一幅图是由 **节点** 和 **边** 构成的，逻辑结构如下：

![](https://labuladong.gitee.io/algo/images/%e5%9b%be/0.jpg)

**什么叫「逻辑结构」？就是说为了方便研究，我们把图抽象成这个样子** 。

根据这个逻辑结构，我们可以认为每个节点的实现如下：

```java
    /* 图节点的逻辑结构 */
    class Vertex {
        int id;
        Vertex[] neighbors;
    }

```

看到这个实现，你有没有很熟悉？它和我们之前说的多叉树节点几乎完全一样：

```java
    /* 基本的 N 叉树节点 */
    class TreeNode {
        int val;
        TreeNode[] children;
    }

```

所以说，图真的没啥高深的，就是高级点的多叉树而已。

不过呢，上面的这种实现是「逻辑上的」，实际上我们很少用这个 ` Vertex ` 类实现图，而是用常说的 **邻接表和邻接矩阵** 来实现。

比如还是刚才那幅图：

![](https://labuladong.gitee.io/algo/images/%e5%9b%be/0.jpg)

用邻接表和邻接矩阵的存储方式如下：

![](https://labuladong.gitee.io/algo/images/%e5%9b%be/2.jpeg)

邻接表很直观，我把每个节点 ` x ` 的邻居都存到一个列表里，然后把 ` x ` 和这个列表关联起来，这样就可以通过一个节点 ` x `找到它的所有相邻节点。

邻接矩阵则是一个二维布尔数组，我们权且称为 ` matrix ` ，如果节点 ` x ` 和 ` y ` 是相连的，那么就把 ` matrix[x][y]
` 设为 ` true ` （上图中绿色的方格代表 ` true ` ）。如果想找节点 ` x ` 的邻居，去扫一圈 ` matrix[x][..] `就行了。

如果用代码的形式来表现，邻接表和邻接矩阵大概长这样：

```java
    // 邻接矩阵
    // graph[x] 存储 x 的所有邻居节点
    List<Integer>[] graph;
    
    // 邻接矩阵
    // matrix[x][y] 记录 x 是否有一条指向 y 的边
    boolean[][] matrix;

```

**那么，为什么有这两种存储图的方式呢？肯定是因为他们各有优劣** 。

对于邻接表，好处是占用的空间少。

你看邻接矩阵里面空着那么多位置，肯定需要更多的存储空间。

但是，邻接表无法快速判断两个节点是否相邻。

比如说我想判断节点 ` 1 ` 是否和节点 ` 3 ` 相邻，我要去邻接表里 ` 1 ` 对应的邻居列表里查找 ` 3 `是否存在。但对于邻接矩阵就简单了，只要看看 ` matrix[1][3] ` 就知道了，效率高。

所以说，使用哪一种方式实现图，要看具体情况。

好了，对于「图」这种数据结构，能看懂上面这些就绰绰够用了。

那你可能会问，我们这个图的模型仅仅是「有向无权图」，不是还有什么加权图，无向图，等等……

**其实，这些更复杂的模型都是基于这个最简单的图衍生出来的** 。

**有向加权图怎么实现** ？很简单呀：

如果是邻接表，我们不仅仅存储某个节点 ` x ` 的所有邻居节点，还存储 ` x ` 到每个邻居的权重，不就实现加权有向图了吗？

如果是邻接矩阵， ` matrix[x][y] ` 不再是布尔值，而是一个 int 值，0 表示没有连接，其他值表示权重，不就变成加权有向图了吗？

如果用代码的形式来表现，大概长这样：

```java
    // 邻接矩阵
    // graph[x] 存储 x 的所有邻居节点以及对应的权重
    List<int[]>[] graph;
    
    // 邻接矩阵
    // matrix[x][y] 记录 x 指向 y 的边的权重，0 表示不相邻
    int[][] matrix;

```

**无向图怎么实现** ？也很简单，所谓的「无向」，是不是等同于「双向」？

![](https://labuladong.gitee.io/algo/images/%e5%9b%be/3.jpeg)

如果连接无向图中的节点 ` x ` 和 ` y ` ，把 ` matrix[x][y] ` 和 ` matrix[y][x] ` 都变成 ` true `不就行了；邻接表也是类似的操作，在 ` x ` 的邻居列表里添加 ` y ` ，同时在 ` y ` 的邻居列表里添加 ` x ` 。

把上面的技巧合起来，就变成了无向加权图……

好了，关于图的基本介绍就到这里，现在不管来什么乱七八糟的图，你心里应该都有底了。

下面来看看所有数据结构都逃不过的问题：遍历。

### 图的遍历

**[ 学习数据结构和算法的框架思维 ](https://labuladong.gitee.io/algo/1/2/) 说过，各种数据结构被发明出来无非就是为了遍历和访问，所以「遍历」是所有数据结构的基础

** 。

图怎么遍历？还是那句话，参考多叉树，多叉树的遍历框架如下：

```java
    /* 多叉树遍历框架 */
    void traverse(TreeNode root) {
        if (root == null) return;
    
        for (TreeNode child : root.children) {
            traverse(child);
        }
    }

```

图和多叉树最大的区别是，图是可能包含环的，你从图的某一个节点开始遍历，有可能走了一圈又回到这个节点。

所以，如果图包含环，遍历框架就要一个 ` visited ` 数组进行辅助：

```java
    // 记录被遍历过的节点
    boolean[] visited;
    // 记录从起点到当前节点的路径
    boolean[] onPath;
    
    /* 图遍历框架 */
    void traverse(Graph graph, int s) {
        if (visited[s]) return;
        // 经过节点 s，标记为已遍历
        visited[s] = true;
        // 做选择：标记节点 s 在路径上
        onPath[s] = true;
        for (int neighbor : graph.neighbors(s)) {
            traverse(graph, neighbor);
        }
        // 撤销选择：节点 s 离开路径
        onPath[s] = false;
    }

```

注意 ` visited ` 数组和 ` onPath ` 数组的区别，因为二叉树算是特殊的图，所以用遍历二叉树的过程来理解下这两个数组的区别：

![](https://labuladong.gitee.io/algo/images/%e8%bf%ad%e4%bb%a3%e9%81%8d%e5%8e%86%e4%ba%8c%e5%8f%89%e6%a0%91/1.gif)

**上述 GIF 描述了递归遍历二叉树的过程，在` visited ` 中被标记为 true 的节点用灰色表示，在 ` onPath ` 中被标记为 true 的节点用绿色表示 ** ，这下你可以理解它们二者的区别了吧。

如果让你处理路径相关的问题，这个 ` onPath ` 变量是肯定会被用到的，比如 [ 拓扑排序 ](https://labuladong.gitee.io/algo/2/18/35/) 中就有运用。

另外，你应该注意到了，这个 ` onPath ` 数组的操作很像 [ 回溯算法核心套路 ](https://labuladong.gitee.io/algo/4/28/105/)中做「做选择」和「撤销选择」，区别在于位置：回溯算法的「做选择」和「撤销选择」在 for 循环里面，而对 ` onPath ` 数组的操作在 for 循环外面。

在 for 循环里面和外面唯一的区别就是对根节点的处理。

比如下面两种多叉树的遍历：

```java
    void traverse(TreeNode root) {
        if (root == null) return;
        System.out.println("enter: " + root.val);
        for (TreeNode child : root.children) {
            traverse(child);
        }
        System.out.println("leave: " + root.val);
    }
    
    void traverse(TreeNode root) {
        if (root == null) return;
        for (TreeNode child : root.children) {
            System.out.println("enter: " + child.val);
            traverse(child);
            System.out.println("leave: " + child.val);
        }
    }

```

前者会正确打印所有节点的进入和离开信息，而后者唯独会少打印整棵树根节点的进入和离开信息。

为什么回溯算法框架会用后者？因为回溯算法关注的不是节点，而是树枝，不信你看 [ 回溯算法核心套路 ](https://labuladong.gitee.io/algo/4/28/105/) 里面的图。

显然，对于这里「图」的遍历，我们应该把 ` onPath ` 的操作放到 for 循环外面，否则会漏掉记录起始点的遍历。

说了这么多 ` onPath ` 数组，再说下 ` visited ` 数组，其目的很明显了，由于图可能含有环， ` visited `数组就是防止递归重复遍历同一个节点进入死循环的。

当然，如果题目告诉你图中不含环，可以把 ` visited ` 数组都省掉，基本就是多叉树的遍历。

### 题目实践

下面我们来看力扣第 797 题「所有可能路径」，函数签名如下：

```java
    List<List<Integer>> allPathsSourceTarget(int[][] graph);

```

题目输入一幅 **有向无环图** ，这个图包含 ` n ` 个节点，标号为 ` 0, 1, 2,..., n - 1 ` ，请你计算所有从节点 ` 0 `到节点 ` n - 1 ` 的路径。

输入的这个 ` graph ` 其实就是「邻接表」表示的一幅图， ` graph[i] ` 存储这节点 ` i ` 的所有邻居节点。

比如输入 ` graph = [[1,2],[3],[3],[]] ` ，就代表下面这幅图：

![](https://labuladong.gitee.io/algo/images/%e5%9b%be/1.jpg)

算法应该返回 ` [[0,1,3],[0,2,3]] ` ，即 ` 0 ` 到 ` 3 ` 的所有路径。

**解法很简单，以` 0 ` 为起点遍历图，同时记录遍历过的路径，当遍历到终点时将路径记录下来即可 ** 。

既然输入的图是无环的，我们就不需要 ` visited ` 数组辅助了，直接套用图的遍历框架：

```java
    // 记录所有路径
    List<List<Integer>> res = new LinkedList<>();
        
    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
        // 维护递归过程中经过的路径
        LinkedList<Integer> path = new LinkedList<>();
        traverse(graph, 0, path);
        return res;
    }
    
    /* 图的遍历框架 */
    void traverse(int[][] graph, int s, LinkedList<Integer> path) {
    
        // 添加节点 s 到路径
        path.addLast(s);
    
        int n = graph.length;
        if (s == n - 1) {
            // 到达终点
            res.add(new LinkedList<>(path));
            path.removeLast();
            return;
        }
    
        // 递归每个相邻节点
        for (int v : graph[s]) {
            traverse(graph, v, path);
        }
        
        // 从路径移出节点 s
        path.removeLast();
    }

```

这道题就这样解决了，注意 Java 的语言特性，向 ` res ` 中添加 ` path ` 时需要拷贝一个新的列表，否则最终 ` res `中的列表都是空的。

最后总结一下，图的存储方式主要有邻接表和邻接矩阵，无论什么花里胡哨的图，都可以用这两种方式存储。

在笔试中，最常考的算法是图的遍历，和多叉树的遍历框架是非常类似的。

当然，图还会有很多其他的有趣算法，比如 [ 二分图判定 ](https://labuladong.gitee.io/algo/2/18/36/) ， [ 环检测和拓扑排序](https://labuladong.gitee.io/algo/2/18/35/) （编译器循环引用检测就是类似的算法）， [ 最小生成树 ](https://labuladong.gitee.io/algo/2/18/39/) ， [
Dijkstra 最短路径算法 ](https://labuladong.gitee.io/algo/2/18/41/) 等等，有兴趣的读者可以去看看，本文就到这了。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


## 拓扑排序，YYDS！


读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 207. 课程表 ](https://leetcode-cn.com/problems/course-schedule/)

[ 210. 课程表 II ](https://leetcode-cn.com/problems/course-schedule-ii/)

**———–**

很多读者留言说要看「图」相关的算法，那就满足大家，结合算法题把图相关的技巧给大家过一遍。

前文 [ 学习数据结构的框架思维 ](https://labuladong.gitee.io/algo/1/2/) 说了，数据结构相关的算法无非两点：遍历 + 访问。那么图的基本遍历方法也很简单，前文 [
图算法基础 ](https://labuladong.gitee.io/algo/2/18/34/) 就讲了如何从多叉树的遍历框架扩展到图的遍历。

图这种数据结构还有一些比较特殊的算法，比如二分图判断，有环图无环图的判断，拓扑排序，以及最经典的最小生成树，单源最短路径问题，更难的就是类似网络流这样的问题。

不过以我的经验呢，像网络流这种问题，你又不是打竞赛的，除非自己特别有兴趣，否则就没必要学了；像最小生成树和最短路径问题，虽然从刷题的角度用到的不多，但它们属于经典算法，学有余力可以掌握一下；像拓扑排序这一类，属于比较基本且有用的算法，应该比较熟练地掌握。

那么本文就结合具体的算法题，来说两个图论算法：有向图的环检测、拓扑排序算法。

### 判断有向图是否存在环

先来看看力扣第 207 题「课程表」：

![](https://labuladong.gitee.io/algo/images/%e6%8b%93%e6%89%91%e6%8e%92%e5%ba%8f/title1.jpg)

函数签名如下：

```java
    int[] findOrder(int numCourses, int[][] prerequisites);

```

题目应该不难理解，什么时候无法修完所有课程？当存在循环依赖的时候。

其实这种场景在现实生活中也十分常见，比如我们写代码 import 包也是一个例子，必须合理设计代码目录结构，否则会出现循环依赖，编译器会报错，所以编译器实际上也使用了类似算法来判断你的代码是否能够成功编译。

**看到依赖问题，首先想到的就是把问题转化成「有向图」这种数据结构，只要图中存在环，那就说明存在循环依赖** 。

具体来说，我们首先可以把课程看成「有向图」中的节点，节点编号分别是 ` 0, 1, ..., numCourses-1 `，把课程之间的依赖关系看做节点之间的有向边。

比如说必须修完课程 ` 1 ` 才能去修课程 ` 3 ` ，那么就有一条有向边从节点 ` 1 ` 指向 ` 3 ` 。

所以我们可以根据题目输入的 ` prerequisites ` 数组生成一幅类似这样的图：

![](https://labuladong.gitee.io/algo/images/%e6%8b%93%e6%89%91%e6%8e%92%e5%ba%8f/1.jpeg)

**如果发现这幅有向图中存在环，那就说明课程之间存在循环依赖，肯定没办法全部上完；反之，如果没有环，那么肯定能上完全部课程** 。

好，那么想解决这个问题，首先我们要把题目的输入转化成一幅有向图，然后再判断图中是否存在环。

如何转换成图呢？我们前文 [ 图论基础 ](https://labuladong.gitee.io/algo/2/18/34/) 写过图的两种存储形式，邻接矩阵和邻接表。

以我刷题的经验，常见的存储方式是使用邻接表，比如下面这种结构：

```java
    List<Integer>[] graph;

```

**` graph[s] ` 是一个列表，存储着节点 ` s ` 所指向的节点 ** 。

所以我们首先可以写一个建图函数：

```java
    List<Integer>[] buildGraph(int numCourses, int[][] prerequisites) {
        // 图中共有 numCourses 个节点
        List<Integer>[] graph = new LinkedList[numCourses];
        for (int i = 0; i < numCourses; i++) {
            graph[i] = new LinkedList<>();
        }
        for (int[] edge : prerequisites) {
            int from = edge[1];
            int to = edge[0];
            // 修完课程 from 才能修课程 to
            // 在图中添加一条从 from 指向 to 的有向边
            graph[from].add(to);
        }
        return graph;
    }

```

图建出来了，怎么判断图中有没有环呢？

**先不要急，我们先来思考如何遍历这幅图，只要会遍历，就可以判断图中是否存在环了** 。

前文 [ 图论基础 ](https://labuladong.gitee.io/algo/2/18/34/) 写了 DFS 算法遍历图的框架，无非就是从多叉树遍历框架扩展出来的，加了个 ` visited
` 数组罢了：

```java
    // 防止重复遍历同一个节点
    boolean[] visited;
    // 从节点 s 开始 DFS 遍历，将遍历过的节点标记为 true
    void traverse(List<Integer>[] graph, int s) {
        if (visited[s]) {
            return;
        }
        /* 前序遍历代码位置 */
        // 将当前节点标记为已遍历
        visited[s] = true;
        for (int t : graph[s]) {
            traverse(graph, t);
        }
        /* 后序遍历代码位置 */
    }

```

那么我们就可以直接套用这个遍历代码：

```java
    // 防止重复遍历同一个节点
    boolean[] visited;
    
    boolean canFinish(int numCourses, int[][] prerequisites) {
        List<Integer>[] graph = buildGraph(numCourses, prerequisites);
        
        visited = new boolean[numCourses];
        for (int i = 0; i < numCourses; i++) {
            traverse(graph, i);
        }
    }
    
    void traverse(List<Integer>[] graph, int s) {
        // 代码见上文
    }

```

注意图中并不是所有节点都相连，所以要用一个 for 循环将所有节点都作为起点调用一次 DFS 搜索算法。

这样，就能遍历这幅图中的所有节点了，你打印一下 ` visited ` 数组，应该全是 true。

前文 [ 学习数据结构和算法的框架思维 ](https://labuladong.gitee.io/algo/1/2/) 说过，图的遍历和遍历多叉树差不多，所以到这里你应该都能很容易理解。

现在可以思考如何判断这幅图中是否存在环。

我们前文 [ 回溯算法核心套路详解 ](https://labuladong.gitee.io/algo/4/28/105/) 说过，你可以把递归函数看成一个在递归树上游走的指针，这里也是类似的：

你也可以把 ` traverse ` 看做在图中节点上游走的指针，只需要再添加一个布尔数组 ` onPath ` 记录当前 ` traverse `经过的路径：

```java
    boolean[] onPath;
    
    boolean hasCycle = false;
    boolean[] visited;
    
    void traverse(List<Integer>[] graph, int s) {
        if (onPath[s]) {
            // 发现环！！！
            hasCycle = true;
        }
        if (visited[s]) {
            return;
        }
        // 将节点 s 标记为已遍历
        visited[s] = true;
        // 开始遍历节点 s
        onPath[s] = true;
        for (int t : graph[s]) {
            traverse(graph, t);
        }
        // 节点 s 遍历完成
        onPath[s] = false;
    }

```

这里就有点回溯算法的味道了，在进入节点 ` s ` 的时候将 ` onPath[s] ` 标记为 true，离开时标记回 false，如果发现 `onPath[s] ` 已经被标记，说明出现了环。

> **PS：参考贪吃蛇没绕过弯儿咬到自己的场景** 。

这样，就可以在遍历图的过程中顺便判断是否存在环了，完整代码如下：

```java
    // 记录一次 traverse 递归经过的节点
    boolean[] onPath;
    // 记录遍历过的节点，防止走回头路
    boolean[] visited;
    // 记录图中是否有环
    boolean hasCycle = false;
    
    boolean canFinish(int numCourses, int[][] prerequisites) {
        List<Integer>[] graph = buildGraph(numCourses, prerequisites);
        
        visited = new boolean[numCourses];
        onPath = new boolean[numCourses];
        
        for (int i = 0; i < numCourses; i++) {
            // 遍历图中的所有节点
            traverse(graph, i);
        }
        // 只要没有循环依赖可以完成所有课程
        return !hasCycle;
    }
    
    void traverse(List<Integer>[] graph, int s) {
        if (onPath[s]) {
            // 出现环
            hasCycle = true;
        }
        
        if (visited[s] || hasCycle) {
            // 如果已经找到了环，也不用再遍历了
            return;
        }
        // 前序遍历代码位置
        visited[s] = true;
        onPath[s] = true;
        for (int t : graph[s]) {
            traverse(graph, t);
        }
        // 后序遍历代码位置
        onPath[s] = false;
    }
    
    List<Integer>[] buildGraph(int numCourses, int[][] prerequisites) {
        // 代码见前文
    }

```

这道题就解决了，核心就是判断一幅有向图中是否存在环。

不过如果出题人继续恶心你，让你不仅要判断是否存在环，还要返回这个环具体有哪些节点，怎么办？

你可能说， ` onPath ` 里面为 true 的索引，不就是组成环的节点编号吗？

不是的，假设下图中绿色的节点是递归的路径，它们在 ` onPath ` 中的值都是 true，但显然成环的节点只是其中的一部分：

![](https://labuladong.gitee.io/algo/images/%e6%8b%93%e6%89%91%e6%8e%92%e5%ba%8f/4.jpeg)

这个问题留给大家思考，我会在公众号留言区置顶正确的答案。

**那么接下来，我们来再讲一个经典的图算法：拓扑排序** 。

### 拓扑排序

看下力扣第 210 题「课程表 II」：

![](https://labuladong.gitee.io/algo/images/%e6%8b%93%e6%89%91%e6%8e%92%e5%ba%8f/title2.jpg)

这道题就是上道题的进阶版，不是仅仅让你判断是否可以完成所有课程，而是进一步让你返回一个合理的上课顺序，保证开始修每个课程时，前置的课程都已经修完。

函数签名如下：

```java
    int[] findOrder(int numCourses, int[][] prerequisites);

```

这里我先说一下拓扑排序（Topological Sorting）这个名词，网上搜出来的定义很数学，这里干脆用百度百科的一幅图来让你直观地感受下：

![](https://labuladong.gitee.io/algo/images/%e6%8b%93%e6%89%91%e6%8e%92%e5%ba%8f/top.jpg)

**直观地说就是，让你把一幅图「拉平」，而且这个「拉平」的图里面，所有箭头方向都是一致的** ，比如上图所有箭头都是朝右的。

很显然，如果一幅有向图中存在环，是无法进行拓扑排序的，因为肯定做不到所有箭头方向一致；反过来，如果一幅图是「有向无环图」，那么一定可以进行拓扑排序。

但是我们这道题和拓扑排序有什么关系呢？

**其实也不难看出来，如果把课程抽象成节点，课程之间的依赖关系抽象成有向边，那么这幅图的拓扑排序结果就是上课顺序** 。

首先，我们先判断一下题目输入的课程依赖是否成环，成环的话是无法进行拓扑排序的，所以我们可以复用上一道题的主函数：

```java
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        if (!canFinish(numCourses, prerequisites)) {
            // 不可能完成所有课程
            return new int[]{};
        }
        // ...
    }

```

那么关键问题来了，如何进行拓扑排序？是不是又要秀什么高大上的技巧了？

**其实特别简单，将后序遍历的结果进行反转，就是拓扑排序的结果** 。

直接看解法代码吧，在上一题环检测的代码基础上添加了记录后序遍历结果的逻辑：

```java
    // 记录后序遍历结果
    List<Integer> postorder = new ArrayList<>();
    // 记录是否存在环
    boolean hasCycle = false;
    boolean[] visited, onPath;
    
    // 主函数
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        List<Integer>[] graph = buildGraph(numCourses, prerequisites);
        visited = new boolean[numCourses];
        onPath = new boolean[numCourses];
        // 遍历图
        for (int i = 0; i < numCourses; i++) {
            traverse(graph, i);
        }
        // 有环图无法进行拓扑排序
        if (hasCycle) {
            return new int[]{};
        }
        // 逆后序遍历结果即为拓扑排序结果
        Collections.reverse(postorder);
        int[] res = new int[numCourses];
        for (int i = 0; i < numCourses; i++) {
            res[i] = postorder.get(i);
        }
        return res;
    }
    
    // 图遍历函数
    void traverse(List<Integer>[] graph, int s) {
        if (onPath[s]) {
            // 发现环
            hasCycle = true;
        }
        if (visited[s] || hasCycle) {
            return;
        }
        // 前序遍历位置
        onPath[s] = true;
        visited[s] = true;
        for (int t : graph[s]) {
            traverse(graph, t);
        }
        // 后序遍历位置
        postorder.add(s);
        onPath[s] = false;
    }
    
    // 建图函数
    List<Integer>[] buildGraph(int numCourses, int[][] prerequisites) {
        // 图中共有 numCourses 个节点
        List<Integer>[] graph = new LinkedList[numCourses];
        for (int i = 0; i < numCourses; i++) {
            graph[i] = new LinkedList<>();
        }
        for (int[] edge : prerequisites) {
            int from = edge[1];
            int to = edge[0];
            // 修完课程 from 才能修课程 to
            // 在图中添加一条从 from 指向 to 的有向边
            graph[from].add(to);
        }
        return graph;
    }

```

代码虽然看起来多，但是逻辑应该是很清楚的，只要图中无环，那么我们就调用 ` traverse ` 函数对图进行 DFS 遍历，记录后序遍历结果，最后把后序遍历结果反转，作为最终的答案。

**那么为什么后序遍历的反转结果就是拓扑排序呢** ？

我这里也避免数学证明，用一个直观地例子来解释，我们就说二叉树，这是我们说过很多次的二叉树遍历框架：

```java
    void traverse(TreeNode root) {
        // 前序遍历代码位置
        traverse(root.left)
        // 中序遍历代码位置
        traverse(root.right)
        // 后序遍历代码位置
    }

```

二叉树的后序遍历是什么时候？遍历完左右子树之后才会执行后序遍历位置的代码。换句话说，当左右子树的节点都被装到结果列表里面了，根节点才会被装进去。

**后序遍历的这一特点很重要，之所以拓扑排序的基础是后序遍历，是因为一个任务必须在等到所有的依赖任务都完成之后才能开始开始执行** 。

你把每个任务理解成二叉树里面的节点，这个任务所依赖的任务理解成子节点，那你是不是应该先把所有子节点处理完再处理父节点？这是不是就是后序遍历？

![](https://labuladong.gitee.io/algo/images/%e6%8b%93%e6%89%91%e6%8e%92%e5%ba%8f/2.jpeg)

再说一说为什么还要把后序遍历结果反转，才是最终的拓扑排序结果。

我们说一个节点可以理解为一个任务，这个节点的子节点理解为这个任务的依赖，但你注意我们之前说的依赖关系的表示：如果做完 ` A ` 才能去做 ` B `，那么就有一条从 ` A ` 指向 ` B ` 的有向边，表示 ` B ` 依赖 ` A ` 。

那么，父节点依赖子节点，体现在二叉树里面应该是这样的：

![](https://labuladong.gitee.io/algo/images/%e6%8b%93%e6%89%91%e6%8e%92%e5%ba%8f/3.jpeg)

**是不是和我们正常的二叉树指针指向反过来了？所以正常的后序遍历结果应该进行反转，才是拓扑排序的结果** 。

以上，我简单解释了一下为什么「拓扑排序的结果就是反转之后的后序遍历结果」，当然，我的解释虽然比较直观，但并没有严格的数学证明，有兴趣的读者可以自己查一下。

总之，你记住拓扑排序就是后序遍历反转之后的结果，且拓扑排序只能针对有向无环图，进行拓扑排序之前要进行环检测，这些知识点已经足够了。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


## 二分图判定


读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 785. 判断二分图（中等） ](https://leetcode-cn.com/problems/is-graph-bipartite)

[ 886. 可能的二分法（中等） ](https://leetcode-cn.com/problems/possible-bipartition)

**———–**

我之前写了好几篇图论相关的文章：

[ 图遍历算法 ](https://labuladong.gitee.io/algo/2/18/34/)

[ 名流问题 ](https://labuladong.gitee.io/algo/2/18/40/)

[ 并查集算法计算连通分量 ](https://labuladong.gitee.io/algo/2/18/37/)

[ 环检测和拓扑排序 ](https://labuladong.gitee.io/algo/2/18/35/)

[ Dijkstra 最短路径算法 ](https://labuladong.gitee.io/algo/2/18/41/)

今天继续来讲一个经典图论算法：二分图判定。

### 二分图简介

在讲二分图的判定算法之前，我们先来看下百度百科对「二分图」的定义：

> 二分图的顶点集可分割为两个互不相交的子集，图中每条边依附的两个顶点都分属于这两个子集，且两个子集内的顶点不相邻。

![](https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%88%86%e5%9b%be/0.png)

其实图论里面很多术语的定义都比较拗口，不容易理解。我们甭看这个死板的定义了，来玩个游戏吧：

**给你一幅「图」，请你用两种颜色将图中的所有顶点着色，且使得任意一条边的两个端点的颜色都不相同，你能做到吗** ？

这就是图的「双色问题」，其实这个问题就等同于二分图的判定问题，如果你能够成功地将图染色，那么这幅图就是一幅二分图，反之则不是：

![](https://labuladong.gitee.io/algo/images/algo4/1.jpg)

在具体讲解二分图判定算法之前，我们先来说说计算机大佬们闲着无聊解决双色问题的目的是什么。

首先，二分图作为一种特殊的图模型，会被很多高级图算法（比如最大流算法）用到，不过这些高级算法我们不是特别有必要去掌握，有兴趣的读者可以自行搜索。

从简单实用的角度来看，二分图结构在某些场景可以更高效地存储数据。

比如前文 [ 介绍《算法 4》 ](https://mp.weixin.qq.com/s/zO6daR7CB76R2JUUcZ863A)文章中的例子，如何存储电影演员和电影之间的关系？

如果用哈希表存储，需要两个哈希表分别存储「每个演员到电影列表」的映射和「每部电影到演员列表」的映射。

但如果用「图」结构存储，将电影和参演的演员连接，很自然地就成为了一幅二分图：

![](https://labuladong.gitee.io/algo/images/algo4/2.jpg)

每个电影节点的相邻节点就是参演该电影的所有演员，每个演员的相邻节点就是该演员参演过的所有电影，非常方便直观。

类比这个例子，其实生活中不少实体的关系都能自然地形成二分图结构，所以在某些场景下图结构也可以作为存储键值对的数据结构（符号表）。

好了，接下来进入正题，说说如何判定一幅图是否是二分图。

### 二分图判定思路

判定二分图的算法很简单，就是用代码解决「双色问题」。

**说白了就是遍历一遍图，一边遍历一边染色，看看能不能用两种颜色给所有节点染色，且相邻节点的颜色都不相同** 。

既然说到遍历图，也不涉及最短路径之类的，当然是 DFS 算法和 BFS 皆可了，DFS 算法相对更常用些，所以我们先来看看如何用 DFS 算法判定双色图。

首先，基于 [ 学习数据结构和算法的框架思维 ](https://labuladong.gitee.io/algo/1/2/) 写出图的遍历框架：

```java
    /* 二叉树遍历框架 */
    void traverse(TreeNode root) {
        if (root == null) return;
        traverse(root.left);
        traverse(root.right);
    }
    
    /* 多叉树遍历框架 */
    void traverse(Node root) {
        if (root == null) return;
        for (Node child : root.children)
            traverse(child);
    }
    
    /* 图遍历框架 */
    boolean[] visited;
    void traverse(Graph graph, int v) {
        // 防止走回头路进入死循环
        if (visited[v]) return;
        // 前序遍历位置，标记节点 v 已访问
        visited[v] = true;
        for (TreeNode neighbor : graph.neighbors(v))
            traverse(graph, neighbor);
    }

```

因为图中可能存在环，所以用 ` visited ` 数组防止走回头路。

**这里可以看到我习惯把 return 语句都放在函数开头，因为一般 return 语句都是 base case，集中放在一起可以让算法结构更清晰** 。

其实，如果你愿意，也可以把 if 判断放到其它地方，比如图遍历框架可以稍微改改：

```java
    /* 图遍历框架 */
    boolean[] visited;
    void traverse(Graph graph, int v) {
        // 前序遍历位置，标记节点 v 已访问
        visited[v] = true;
        for (int neighbor : graph.neighbors(v)) {
            if (!visited[neighbor]) {
                // 只遍历没标记过的相邻节点
                traverse(graph, neighbor);
            }
        }
    }

```

这种写法把对 ` visited ` 的判断放到递归调用之前，和之前的写法唯一的不同就是，你需要保证调用 ` traverse(v) ` 的时候， `visited[v] == false ` 。

为什么要特别说这种写法呢？因为我们判断二分图的算法会用到这种写法。

**回顾一下二分图怎么判断，其实就是让` traverse ` 函数一边遍历节点，一边给节点染色，尝试让每对相邻节点的颜色都不一样 ** 。

所以，判定二分图的代码逻辑可以这样写：

```java
    /* 图遍历框架 */
    void traverse(Graph graph, boolean[] visited, int v) {
        visited[v] = true;
        // 遍历节点 v 的所有相邻节点 neighbor
        for (int neighbor : graph.neighbors(v)) {
            if (!visited[neighbor]) {
                // 相邻节点 neighbor 没有被访问过
                // 那么应该给节点 neighbor 涂上和节点 v 不同的颜色
                traverse(graph, visited, neighbor);
            } else {
                // 相邻节点 neighbor 已经被访问过
                // 那么应该比较节点 neighbor 和节点 v 的颜色
                // 若相同，则此图不是二分图
            }
        }
    }

```

如果你能看懂上面这段代码，就能写出二分图判定的具体代码了，接下来看两道具体的算法题来实操一下。

### 题目实践

力扣第 785 题「判断二分图」就是原题，题目给你输入一个 [ 邻接表 ](https://labuladong.gitee.io/algo/2/18/34/)表示一幅无向图，请你判断这幅图是否是二分图。

函数签名如下：

```java
    boolean isBipartite(int[][] graph);

```

比如题目给的例子，输入的邻接表 ` graph = [[1,2,3],[0,2],[0,1,3],[0,2]] ` ，也就是这样一幅图：

![](https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%88%86%e5%9b%be/1.png)

显然无法对节点着色使得每两个相邻节点的颜色都不相同，所以算法返回 false。

但如果输入 ` graph = [[1,3],[0,2],[1,3],[0,2]] ` ，也就是这样一幅图：

![](https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%88%86%e5%9b%be/2.png)

如果把节点 ` {0, 2} ` 涂一个颜色，节点 ` {1, 3} ` 涂另一个颜色，就可以解决「双色问题」，所以这是一幅二分图，算法返回 true。

结合之前的代码框架，我们可以额外使用一个 ` color ` 数组来记录每个节点的颜色，从而写出解法代码：

```java
    // 记录图是否符合二分图性质
    private boolean ok = true;
    // 记录图中节点的颜色，false 和 true 代表两种不同颜色
    private boolean[] color;
    // 记录图中节点是否被访问过
    private boolean[] visited;
    
    // 主函数，输入邻接表，判断是否是二分图
    public boolean isBipartite(int[][] graph) {
        int n = graph.length;
        color =  new boolean[n];
        visited =  new boolean[n];
        // 因为图不一定是联通的，可能存在多个子图
        // 所以要把每个节点都作为起点进行一次遍历
        // 如果发现任何一个子图不是二分图，整幅图都不算二分图
        for (int v = 0; v < n; v++) {
            if (!visited[v]) {
                traverse(graph, v);
            }
        }
        return ok;
    }
    
    // DFS 遍历框架
    private void traverse(int[][] graph, int v) {
        // 如果已经确定不是二分图了，就不用浪费时间再递归遍历了
        if (!ok) return;
    
        visited[v] = true;
        for (int w : graph[v]) {
            if (!visited[w]) {
                // 相邻节点 w 没有被访问过
                // 那么应该给节点 w 涂上和节点 v 不同的颜色
                color[w] = !color[v];
                // 继续遍历 w
                traverse(graph, w);
            } else {
                // 相邻节点 w 已经被访问过
                // 根据 v 和 w 的颜色判断是否是二分图
                if (color[w] == color[v]) {
                    // 若相同，则此图不是二分图
                    ok = false;
                }
            }
        }
    }

```

这就是解决「双色问题」的代码，如果能成功对整幅图染色，则说明这是一幅二分图，否则就不是二分图。

接下来看一下 BFS 算法的逻辑：

```java
    // 记录图是否符合二分图性质
    private boolean ok = true;
    // 记录图中节点的颜色，false 和 true 代表两种不同颜色
    private boolean[] color;
    // 记录图中节点是否被访问过
    private boolean[] visited;
    
    public boolean isBipartite(int[][] graph) {
        int n = graph.length;
        color =  new boolean[n];
        visited =  new boolean[n];
        
        for (int v = 0; v < n; v++) {
            if (!visited[v]) {
                // 改为使用 BFS 函数
                bfs(graph, v);
            }
        }
        
        return ok;
    }
    
    // 从 start 节点开始进行 BFS 遍历
    private void bfs(int[][] graph, int start) {
        Queue<Integer> q = new LinkedList<>();
        visited[start] = true;
        q.offer(start);
        
        while (!q.isEmpty() && ok) {
            int v = q.poll();
            // 从节点 v 向所有相邻节点扩散
            for (int w : graph[v]) {
                if (!visited[w]) {
                    // 相邻节点 w 没有被访问过
                    // 那么应该给节点 w 涂上和节点 v 不同的颜色
                    color[w] = !color[v];
                    // 标记 w 节点，并放入队列
                    visited[w] = true;
                    q.offer(w);
                } else {
                    // 相邻节点 w 已经被访问过
                    // 根据 v 和 w 的颜色判断是否是二分图
                    if (color[w] == color[v]) {
                        // 若相同，则此图不是二分图
                        ok = false;
                    }
                }
            }
        }
    }

```

核心逻辑和刚才实现的 ` traverse ` 函数（DFS 算法）完全一样，也是根据相邻节点 ` v ` 和 ` w ` 的颜色来进行判断的。关于 BFS
算法框架的探讨，详见前文 [ BFS 算法框架 ](https://labuladong.gitee.io/algo/4/28/110/) 和 [ Dijkstra 算法模板](https://labuladong.gitee.io/algo/2/18/41/) ，这里就不展开了。

最后再来看看力扣第 886 题「可能的二分法」：

![](https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%88%86%e5%9b%be/title.png)

函数签名如下：

```java
    boolean possibleBipartition(int n, int[][] dislikes);

```

**其实这题考察的就是二分图的判定** ：

如果你把每个人看做图中的节点，相互讨厌的关系看做图中的边，那么 ` dislikes ` 数组就可以构成一幅图；

又因为题目说互相讨厌的人不能放在同一组里，相当于图中的所有相邻节点都要放进两个不同的组；

那就回到了「双色问题」，如果能够用两种颜色着色所有节点，且相邻节点颜色都不同，那么你按照颜色把这些节点分成两组不就行了嘛。

所以解法就出来了，我们把 ` dislikes ` 构造成一幅图，然后执行二分图的判定算法即可：

```java
    private boolean ok = true;
    private boolean[] color;
    private boolean[] visited;
    
    public boolean possibleBipartition(int n, int[][] dislikes) {
        // 图节点编号从 1 开始
        color = new boolean[n + 1];
        visited = new boolean[n + 1];
        // 转化成邻接表表示图结构
        List<Integer>[] graph = buildGraph(n, dislikes);
        
        for (int v = 1; v <= n; v++) {
            if (!visited[v]) {
                traverse(graph, v);
            }
        }
        
        return ok;
    }
    
    // 建图函数
    private List<Integer>[] buildGraph(int n, int[][] dislikes) {
        // 图节点编号为 1...n
        List<Integer>[] graph = new LinkedList[n + 1];
        for (int i = 1; i <= n; i++) {
            graph[i] = new LinkedList<>();
        }
        for (int[] edge : dislikes) {
            int v = edge[1];
            int w = edge[0];
            // 「无向图」相当于「双向图」
            // v -> w
            graph[v].add(w);
            // w -> v
            graph[w].add(v);
        }
        return graph;
    }
    
    // 和之前的 traverse 函数完全相同
    private void traverse(List<Integer>[] graph, int v) {
        if (!ok) return;
        visited[v] = true;
        for (int w : graph[v]) {
            if (!visited[w]) {
                color[w] = !color[v];
                traverse(graph, w);
            } else {
                if (color[w] == color[v]) {
                    ok = false;
                }
            }
        }
    }

```

至此，这道题也使用 DFS 算法解决了，如果你想用 BFS 算法，和之前写的解法是完全一样的，可以自己尝试实现。

二分图的判定算法就讲到这里，更多二分图的高级算法，敬请期待。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


## Union-Find算法详解


读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 323. 无向图中的连通分量数目（中等） ](https://leetcode-cn.com/problems/number-of-connected-
components-in-an-undirected-graph/)

**———–**

今天讲讲 Union-Find 算法，也就是常说的并查集算法，主要是解决图论中「动态连通性」问题的。名词很高端，其实特别好理解，等会解释，另外这个算法的应用都非常有趣。

说起这个 Union-Find，应该算是我的「启蒙算法」了，因为《算法4》的开头就介绍了这款算法，可是把我秀翻了，感觉好精妙啊！

后来刷了 LeetCode，并查集相关的算法题目都非常有意思，而且《算法4》给的解法竟然还可以进一步优化，只要加一个微小的修改就可以把时间复杂度降到 O(1)。

废话不多说，直接上干货，先解释一下什么叫动态连通性吧。

### 一、问题介绍

简单说，动态连通性其实可以抽象成给一幅图连线。比如下面这幅图，总共有 10 个节点，他们互不相连，分别用 0~9 标记：

![](https://labuladong.gitee.io/algo/images/unionfind/1.jpg)

现在我们的 Union-Find 算法主要需要实现这两个 API：

```java
    class UF {
        /* 将 p 和 q 连接 */
        public void union(int p, int q);
        /* 判断 p 和 q 是否连通 */
        public boolean connected(int p, int q);
        /* 返回图中有多少个连通分量 */
        public int count();
    }

```

这里所说的「连通」是一种等价关系，也就是说具有如下三个性质：

1、自反性：节点 ` p ` 和 ` p ` 是连通的。

2、对称性：如果节点 ` p ` 和 ` q ` 连通，那么 ` q ` 和 ` p ` 也连通。

3、传递性：如果节点 ` p ` 和 ` q ` 连通， ` q ` 和 ` r ` 连通，那么 ` p ` 和 ` r ` 也连通。

比如说之前那幅图，0～9 任意两个 **不同** 的点都不连通，调用 ` connected ` 都会返回 false，连通分量为 10 个。

如果现在调用 ` union(0, 1) ` ，那么 0 和 1 被连通，连通分量降为 9 个。

再调用 ` union(1, 2) ` ，这时 0,1,2 都被连通，调用 ` connected(0, 2) ` 也会返回 true，连通分量变为 8 个。

![](https://labuladong.gitee.io/algo/images/unionfind/2.jpg)

判断这种「等价关系」非常实用，比如说编译器判断同一个变量的不同引用，比如社交网络中的朋友圈计算等等。

这样，你应该大概明白什么是动态连通性了，Union-Find 算法的关键就在于 ` union ` 和 ` connected `函数的效率。那么用什么模型来表示这幅图的连通状态呢？用什么数据结构来实现代码呢？

### 二、基本思路

注意我刚才把「模型」和具体的「数据结构」分开说，这么做是有原因的。因为我们使用森林（若干棵树）来表示图的动态连通性，用数组来具体实现这个森林。

怎么用森林来表示连通性呢？我们设定树的每个节点有一个指针指向其父节点，如果是根节点的话，这个指针指向自己。比如说刚才那幅 10 个节点的图，一开始的时候没有相互连通，就是这样：

![](https://labuladong.gitee.io/algo/images/unionfind/3.jpg)

```java
    class UF {
        // 记录连通分量
        private int count;
        // 节点 x 的节点是 parent[x]
        private int[] parent;
    
        /* 构造函数，n 为图的节点总数 */
        public UF(int n) {
            // 一开始互不连通
            this.count = n;
            // 父节点指针初始指向自己
            parent = new int[n];
            for (int i = 0; i < n; i++)
                parent[i] = i;
        }
    
        /* 其他函数 */
    }

```

**如果某两个节点被连通，则让其中的（任意）一个节点的根节点接到另一个节点的根节点上** ：

![](https://labuladong.gitee.io/algo/images/unionfind/4.jpg)

```java
    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ)
            return;
        // 将两棵树合并为一棵
        parent[rootP] = rootQ;
        // parent[rootQ] = rootP 也一样
        count--; // 两个分量合二为一
    }
    
    /* 返回某个节点 x 的根节点 */
    private int find(int x) {
        // 根节点的 parent[x] == x
        while (parent[x] != x)
            x = parent[x];
        return x;
    }
    
    /* 返回当前的连通分量个数 */
    public int count() { 
        return count;
    }

```

**这样，如果节点` p ` 和 ` q ` 连通的话，它们一定拥有相同的根节点 ** ：

![](https://labuladong.gitee.io/algo/images/unionfind/5.jpg)

```java
    public boolean connected(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        return rootP == rootQ;
    }

```

至此，Union-Find 算法就基本完成了。是不是很神奇？竟然可以这样使用数组来模拟出一个森林，如此巧妙的解决这个比较复杂的问题！

那么这个算法的复杂度是多少呢？我们发现，主要 API ` connected ` 和 ` union ` 中的复杂度都是 ` find `函数造成的，所以说它们的复杂度和 ` find ` 一样。

` find ` 主要功能就是从某个节点向上遍历到树根，其时间复杂度就是树的高度。我们可能习惯性地认为树的高度就是 ` logN ` ，但这并不一定。 `logN ` 的高度只存在于平衡二叉树，对于一般的树可能出现极端不平衡的情况，使得「树」几乎退化成「链表」，树的高度最坏情况下可能变成 ` N ` 。

![](https://labuladong.gitee.io/algo/images/unionfind/6.jpg)

所以说上面这种解法， ` find ` , ` union ` , ` connected ` 的时间复杂度都是 O(N)。这个复杂度很不理想的，你想图论解决的都是诸如社交网络这样数据规模巨大的问题，对于 ` union `和 ` connected `的调用非常频繁，每次调用需要线性时间完全不可忍受。

**问题的关键在于，如何想办法避免树的不平衡呢** ？只需要略施小计即可。

### 三、平衡性优化

我们要知道哪种情况下可能出现不平衡现象，关键在于 ` union ` 过程：

```java
    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ)
            return;
        // 将两棵树合并为一棵
        parent[rootP] = rootQ;
        // parent[rootQ] = rootP 也可以
        count--;

```

我们一开始就是简单粗暴的把 ` p ` 所在的树接到 ` q ` 所在的树的根节点下面，那么这里就可能出现「头重脚轻」的不平衡状况，比如下面这种局面：

![](https://labuladong.gitee.io/algo/images/unionfind/7.jpg)

长此以往，树可能生长得很不平衡。 **我们其实是希望，小一些的树接到大一些的树下面，这样就能避免头重脚轻，更平衡一些** 。解决方法是额外使用一个 `size ` 数组，记录每棵树包含的节点数，我们不妨称为「重量」：

```java
    class UF {
        private int count;
        private int[] parent;
        // 新增一个数组记录树的“重量”
        private int[] size;
    
        public UF(int n) {
            this.count = n;
            parent = new int[n];
            // 最初每棵树只有一个节点
            // 重量应该初始化 1
            size = new int[n];
            for (int i = 0; i < n; i++) {
                parent[i] = i;
                size[i] = 1;
            }
        }
        /* 其他函数 */
    }

```

比如说 ` size[3] = 5 ` 表示，以节点 ` 3 ` 为根的那棵树，总共有 ` 5 ` 个节点。这样我们可以修改一下 ` union ` 方法：

```java
    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ)
            return;
        
        // 小树接到大树下面，较平衡
        if (size[rootP] > size[rootQ]) {
            parent[rootQ] = rootP;
            size[rootP] += size[rootQ];
        } else {
            parent[rootP] = rootQ;
            size[rootQ] += size[rootP];
        }
        count--;
    }

```

这样，通过比较树的重量，就可以保证树的生长相对平衡，树的高度大致在 ` logN ` 这个数量级，极大提升执行效率。

此时， ` find ` , ` union ` , ` connected ` 的时间复杂度都下降为 O(logN)，即便数据规模上亿，所需时间也非常少。

### 四、路径压缩

这步优化特别简单，所以非常巧妙。我们能不能进一步压缩每棵树的高度，使树高始终保持为常数？

![](https://labuladong.gitee.io/algo/images/unionfind/8.jpg)

这样 ` find ` 就能以 O(1) 的时间找到某一节点的根节点，相应的， ` connected ` 和 ` union ` 复杂度都下降为 O(1)。

要做到这一点，非常简单，只需要在 ` find ` 中加一行代码：

```java
    private int find(int x) {
        while (parent[x] != x) {
            // 进行路径压缩
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }

```

这个操作有点匪夷所思，看个 GIF 就明白它的作用了（为清晰起见，这棵树比较极端）：

![](https://labuladong.gitee.io/algo/images/unionfind/9.gif)

可见，调用 ` find ` 函数每次向树根遍历的同时，顺手将树高缩短了，最终所有树高都不会超过 3（ ` union ` 的时候树高可能达到 3）。

> PS：读者可能会问，这个 GIF 图的find过程完成之后，树高恰好等于 3 了，但是如果更高的树，压缩后高度依然会大于 3 呀？不能这么想。这个
> GIF 的情景是我编出来方便大家理解路径压缩的，但是实际中，每次find都会进行路径压缩，所以树本来就不可能增长到这么高，你的这种担心应该是多余的。

### 五、最后总结

我们先来看一下完整代码：

```java
    class UF {
        // 连通分量个数
        private int count;
        // 存储一棵树
        private int[] parent;
        // 记录树的「重量」
        private int[] size;
    
        // n 为图中节点的个数
        public UF(int n) {
            this.count = n;
            parent = new int[n];
            size = new int[n];
            for (int i = 0; i < n; i++) {
                parent[i] = i;
                size[i] = 1;
            }
        }
        
        // 将节点 p 和节点 q 连通
        public void union(int p, int q) {
            int rootP = find(p);
            int rootQ = find(q);
            if (rootP == rootQ)
                return;
            
            // 小树接到大树下面，较平衡
            if (size[rootP] > size[rootQ]) {
                parent[rootQ] = rootP;
                size[rootP] += size[rootQ];
            } else {
                parent[rootP] = rootQ;
                size[rootQ] += size[rootP];
            }
            // 两个连通分量合并成一个连通分量
            count--;
        }
    
        // 判断节点 p 和节点 q 是否连通
        public boolean connected(int p, int q) {
            int rootP = find(p);
            int rootQ = find(q);
            return rootP == rootQ;
        }
    
        // 返回节点 x 的连通分量根节点
        private int find(int x) {
            while (parent[x] != x) {
                // 进行路径压缩
                parent[x] = parent[parent[x]];
                x = parent[x];
            }
            return x;
        }
    
        // 返回图中的连通分量个数
        public int count() {
            return count;
        }
    }

```

Union-Find 算法的复杂度可以这样分析：构造函数初始化数据结构需要 O(N) 的时间和空间复杂度；连通两个节点 ` union `、判断两个节点的连通性 ` connected ` 、计算连通分量 ` count ` 所需的时间复杂度均为 O(1)。

好了，本文就讲到这里，相信你已经掌握了 Union-Find 算法的核心逻辑。

接下来可阅读：

* [ Union-Find算法应用 ](https://labuladong.gitee.io/algo/2/18/38/)

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


## Union-Find算法应用


读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 130. 被围绕的区域（中等） ](https://leetcode-cn.com/problems/surrounded-regions/)

[ 990. 等式方程的可满足性（中等） ](https://leetcode-cn.com/problems/satisfiability-of-
equality-equations/)

**———–**

上篇文章 [ Union Find 并查集算法原理 ](https://labuladong.gitee.io/algo/2/18/37/) 很多读者表示对 Union-Find 算法的应用表示很感兴趣，这篇文章就拿几道 LeetCode 题目来讲讲这个算法的巧妙用法。

首先，复习一下，Union-Find 算法解决的是图的动态连通性问题，这个算法本身不难，能不能应用出来主要是看你抽象问题的能力，是否能够把原始问题抽象成一个有关图论的问题。

先复习一下上篇文章写的算法代码，回答读者提出的几个问题：

```java
    class UF {
        // 记录连通分量个数
        private int count;
        // 存储若干棵树
        private int[] parent;
        // 记录树的“重量”
        private int[] size;
    
        public UF(int n) {
            this.count = n;
            parent = new int[n];
            size = new int[n];
            for (int i = 0; i < n; i++) {
                parent[i] = i;
                size[i] = 1;
            }
        }
        
        /* 将 p 和 q 连通 */
        public void union(int p, int q) {
            int rootP = find(p);
            int rootQ = find(q);
            if (rootP == rootQ)
                return;
            
            // 小树接到大树下面，较平衡
            if (size[rootP] > size[rootQ]) {
                parent[rootQ] = rootP;
                size[rootP] += size[rootQ];
            } else {
                parent[rootP] = rootQ;
                size[rootQ] += size[rootP];
            }
            count--;
        }
    
        /* 判断 p 和 q 是否互相连通 */
        public boolean connected(int p, int q) {
            int rootP = find(p);
            int rootQ = find(q);
            // 处于同一棵树上的节点，相互连通
            return rootP == rootQ;
        }
    
        /* 返回节点 x 的根节点 */
        private int find(int x) {
            while (parent[x] != x) {
                // 进行路径压缩
                parent[x] = parent[parent[x]];
                x = parent[x];
            }
            return x;
        }
        
        public int count() {
            return count;
        }
    }

```

算法的关键点有 3 个：

1、用 ` parent ` 数组记录每个节点的父节点，相当于指向父节点的指针，所以 ` parent ` 数组内实际存储着一个森林（若干棵多叉树）。

2、用 ` size ` 数组记录着每棵树的重量，目的是让 ` union ` 后树依然拥有平衡性，而不会退化成链表，影响操作效率。

3、在 ` find ` 函数中进行路径压缩，保证任意树的高度保持在常数，使得 ` union ` 和 ` connected ` API 时间复杂度为 O(1)。

有的读者问， **既然有了路径压缩，` size ` 数组的重量平衡还需要吗 ** ？这个问题很有意思，因为路径压缩保证了树高为常数（不超过 3），那么树就算不平衡，高度也是常数，基本没什么影响。

我认为，论时间复杂度的话，确实，不需要重量平衡也是 O(1)。但是如果加上 ` size ` 数组辅助，效率还是略微高一些，比如下面这种情况：

![](https://labuladong.gitee.io/algo/images/unionfind%e5%ba%94%e7%94%a8/1.jpg)

如果带有重量平衡优化，一定会得到情况一，而不带重量优化，可能出现情况二。高度为 3 时才会触发路径压缩那个 ` while `循环，所以情况一根本不会触发路径压缩，而情况二会多执行很多次路径压缩，将第三层节点压缩到第二层。

也就是说，去掉重量平衡，虽然对于单个的 ` find ` 函数调用，时间复杂度依然是 O(1)，但是对于 API 调用的整个过程，效率会有一定的下降。当然，好处就是减少了一些空间，不过对于 Big O 表示法来说，时空复杂度都没变。

下面言归正传，来看看这个算法有什么实际应用。

### 一、DFS 的替代方案

很多使用 DFS 深度优先算法解决的问题，也可以用 Union-Find 算法解决。

比如第 130 题，被围绕的区域：给你一个 M×N 的二维矩阵，其中包含字符 ` X ` 和 ` O ` ，让你找到矩阵中 **四面** 被 ` X `围住的 ` O ` ，并且把它们替换成 ` X ` 。

```java
    void solve(char[][] board);

```

注意哦，必须是四面被围的 ` O ` 才能被换成 ` X ` ，也就是说边角上的 ` O ` 一定不会被围，进一步，与边角上的 ` O ` 相连的 ` O
` 也不会被 ` X ` 围四面，也不会被替换。

![](https://labuladong.gitee.io/algo/images/unionfind%e5%ba%94%e7%94%a8/2.jpg)

>PS：这让我想起小时候玩的棋类游戏「黑白棋」，只要你用两个棋子把对方的棋子夹在中间，对方的子就被替换成你的子。可见，占据四角的棋子是无敌的，与其相连的边棋子也是无敌的（无法被夹掉）。

解决这个问题的传统方法也不困难，先用 for 循环遍历棋盘的 **四边** ，用 DFS 算法把那些与边界相连的 ` O ` 换成一个特殊字符，比如 ` #
` ；然后再遍历整个棋盘，把剩下的 ` O ` 换成 ` X ` ，把 ` ## ` 恢复成 ` O ` 。这样就能完成题目的要求，时间复杂度 O(MN)。

这个问题也可以用 Union-Find 算法解决，虽然实现复杂一些，甚至效率也略低，但这是使用 Union-Find 算法的通用思想，值得一学。

**你可以把那些不需要被替换的` O ` 看成一个拥有独门绝技的门派，它们有一个共同祖师爷叫 ` dummy ` ，这些 ` O ` 和 ` dummy `互相连通，而那些需要被替换的 ` O ` 与 ` dummy ` 不连通 ** 。

![](https://labuladong.gitee.io/algo/images/unionfind%e5%ba%94%e7%94%a8/3.jpg)

这就是 Union-Find 的核心思路，明白这个图，就很容易看懂代码了。

首先要解决的是，根据我们的实现，Union-Find 底层用的是一维数组，构造函数需要传入这个数组的大小，而题目给的是一个二维棋盘。

这个很简单，二维坐标 ` (x,y) ` 可以转换成 ` x * n + y ` 这个数（ ` m ` 是棋盘的行数， ` n ` 是棋盘的列数）。敲黑板，
**这是将二维坐标映射到一维的常用技巧** 。

其次，我们之前描述的「祖师爷」是虚构的，需要给他老人家留个位置。索引 ` [0.. m*n-1] ` 都是棋盘内坐标的一维映射，那就让这个虚拟的 `dummy ` 节点占据索引 ` m * n ` 好了。

```java
    void solve(char[][] board) {
        if (board.length == 0) return;
    
        int m = board.length;
        int n = board[0].length;
        // 给 dummy 留一个额外位置
        UF uf = new UF(m * n + 1);
        int dummy = m * n;
        // 将首列和末列的 O 与 dummy 连通
        for (int i = 0; i < m; i++) {
            if (board[i][0] == 'O')
                uf.union(i * n, dummy);
            if (board[i][n - 1] == 'O')
                uf.union(i * n + n - 1, dummy);
        }
        // 将首行和末行的 O 与 dummy 连通
        for (int j = 0; j < n; j++) {
            if (board[0][j] == 'O')
                uf.union(j, dummy);
            if (board[m - 1][j] == 'O')
                uf.union(n * (m - 1) + j, dummy);
        }
        // 方向数组 d 是上下左右搜索的常用手法
        int[][] d = new int[][]{{1,0}, {0,1}, {0,-1}, {-1,0}};
        for (int i = 1; i < m - 1; i++) 
            for (int j = 1; j < n - 1; j++) 
                if (board[i][j] == 'O')
                    // 将此 O 与上下左右的 O 连通
                    for (int k = 0; k < 4; k++) {
                        int x = i + d[k][0];
                        int y = j + d[k][1];
                        if (board[x][y] == 'O')
                            uf.union(x * n + y, i * n + j);
                    }
        // 所有不和 dummy 连通的 O，都要被替换
        for (int i = 1; i < m - 1; i++) 
            for (int j = 1; j < n - 1; j++) 
                if (!uf.connected(dummy, i * n + j))
                    board[i][j] = 'X';
    }

```

这段代码很长，其实就是刚才的思路实现，只有和边界 ` O ` 相连的 ` O ` 才具有和 ` dummy ` 的连通性，他们不会被替换。

说实话，Union-Find 算法解决这个简单的问题有点杀鸡用牛刀，它可以解决更复杂，更具有技巧性的问题，
**主要思路是适时增加虚拟节点，想办法让元素「分门别类」，建立动态连通关系** 。

### 二、判定合法等式

这个问题用 Union-Find 算法就显得十分优美了。题目是这样：

给你一个数组 ` equations ` ，装着若干字符串表示的算式。每个算式 ` equations[i] ` 长度都是 4，而且只有这两种情况： `a==b ` 或者 ` a!=b ` ，其中 ` a,b ` 可以是任意小写字母。你写一个算法，如果 ` equations `中所有算式都不会互相冲突，返回 true，否则返回 false。

比如说，输入 ` ["a==b","b!=c","c==a"] ` ，算法返回 false，因为这三个算式不可能同时正确。

再比如，输入 ` ["c==c","b==d","x!=z"] ` ，算法返回 true，因为这三个算式并不会造成逻辑冲突。

我们前文说过，动态连通性其实就是一种等价关系，具有「自反性」「传递性」和「对称性」，其实 ` == ` 关系也是一种等价关系，具有这些性质。所以这个问题用 Union-Find 算法就很自然。

核心思想是， **将` equations ` 中的算式根据 ` == ` 和 ` != ` 分成两部分，先处理 ` == `算式，使得他们通过相等关系各自勾结成门派（连通分量）；然后处理 ` != ` 算式，检查不等关系是否破坏了相等关系的连通性 ** 。

```java
    boolean equationsPossible(String[] equations) {
        // 26 个英文字母
        UF uf = new UF(26);
        // 先让相等的字母形成连通分量
        for (String eq : equations) {
            if (eq.charAt(1) == '=') {
                char x = eq.charAt(0);
                char y = eq.charAt(3);
                uf.union(x - 'a', y - 'a');
            }
        }
        // 检查不等关系是否打破相等关系的连通性
        for (String eq : equations) {
            if (eq.charAt(1) == '!') {
                char x = eq.charAt(0);
                char y = eq.charAt(3);
                // 如果相等关系成立，就是逻辑冲突
                if (uf.connected(x - 'a', y - 'a'))
                    return false;
            }
        }
        return true;
    }

```

至此，这道判断算式合法性的问题就解决了，借助 Union-Find 算法，是不是很简单呢？

### 三、简单总结

使用 Union-Find 算法，主要是如何把原问题转化成图的动态连通性问题。对于算式合法性问题，可以直接利用等价关系，对于棋盘包围问题，则是利用一个虚拟节点，营造出动态连通特性。

另外，将二维数组映射到一维数组，利用方向数组 ` d ` 来简化代码量，都是在写算法时常用的一些小技巧，如果没见过可以注意一下。

很多更复杂的 DFS 算法问题，都可以利用 Union-Find 算法更漂亮的解决。LeetCode 上 Union-Find 相关的问题也就二十多道，有兴趣的读者可以去做一做。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


## Kruskal 最小生成树算法


读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 261. 以图判树（中等） ](https://leetcode-cn.com/problems/graph-valid-tree/)

[ 1135. 最低成本联通所有城市（中等） ](https://leetcode-cn.com/problems/connecting-cities-
with-minimum-cost/)

[ 1584. 连接所有点的最小费用（中等） ](https://leetcode-cn.com/problems/min-cost-to-connect-
all-points/)

**———–**

图论中知名度比较高的算法应该就是 [ Dijkstra 最短路径算法 ](https://labuladong.gitee.io/algo/2/18/41/) ， [ 环检测和拓扑排序](https://labuladong.gitee.io/algo/2/18/35/) ， [ 二分图判定算法 ](https://labuladong.gitee.io/algo/2/18/36/) 以及今天要讲的最小生成树（Minimum Spanning Tree）算法了。

最小生成树算法主要有 Prim 算法（普里姆算法）和 Kruskal 算法（克鲁斯卡尔算法）两种，这两种算法虽然都运用了贪心思想，但从实现上来说差异还是蛮大的，本文先来讲 Kruskal 算法，Prim 算法另起一篇文章写。

Kruskal 算法其实很容易理解和记忆，其关键是要熟悉并查集算法，如果不熟悉，建议先看下前文 [ Union-Find 并查集算法](https://labuladong.gitee.io/algo/2/18/37/) 。

接下来，我们从最小生成树的定义说起。

### 什么是最小生成树

**先说「树」和「图」的根本区别：树不会包含环，图可以包含环** 。

如果一幅图没有环，完全可以拉伸成一棵树的模样。说的专业一点，树就是「无环连通图」。

那么什么是图的「生成树」呢，其实按字面意思也好理解，就是在图中找一棵包含图中的所有节点的树。专业点说，生成树是含有图中所有顶点的「无环连通子图」。

容易想到，一幅图可以有很多不同的生成树，比如下面这幅图，红色的边就组成了两棵不同的生成树：

![](https://labuladong.gitee.io/algo/images/kruskal/1.png)

对于加权图，每条边都有权重，所以每棵生成树都有一个权重和。比如上图，右侧生成树的权重和显然比左侧生成树的权重和要小。

**那么最小生成树很好理解了，所有可能的生成树中，权重和最小的那棵生成树就叫「最小生成树」** 。

> PS：一般来说，我们都是在 **无向加权图** 中计算最小生成树的，所以使用最小生成树算法的现实场景中，图的边权重一般代表成本、距离这样的标量。

在讲 Kruskal 算法之前，需要回顾一下 Union-Find 并查集算法。

### Union-Find 并查集算法

刚才说了，图的生成树是含有其所有顶点的「无环连通子图」，最小生成树是权重和最小的生成树。

那么说到连通性，相信老读者应该可以想到 Union-Find 并查集算法，用来高效处理图中联通分量的问题。

前文 [ Union-Find 并查集算法详解 ](https://labuladong.gitee.io/algo/2/18/37/) 详细介绍了 Union-Find 算法的实现原理，主要运用 `size ` 数组和路径压缩技巧提高连通分量的判断效率。

如果不了解 Union-Find 算法的读者可以去看前文，为了节约篇幅，本文直接给出 Union-Find 算法的实现：

```java
    class UF {
        // 连通分量个数
        private int count;
        // 存储一棵树
        private int[] parent;
        // 记录树的「重量」
        private int[] size;
    
        // n 为图中节点的个数
        public UF(int n) {
            this.count = n;
            parent = new int[n];
            size = new int[n];
            for (int i = 0; i < n; i++) {
                parent[i] = i;
                size[i] = 1;
            }
        }
        
        // 将节点 p 和节点 q 连通
        public void union(int p, int q) {
            int rootP = find(p);
            int rootQ = find(q);
            if (rootP == rootQ)
                return;
            
            // 小树接到大树下面，较平衡
            if (size[rootP] > size[rootQ]) {
                parent[rootQ] = rootP;
                size[rootP] += size[rootQ];
            } else {
                parent[rootP] = rootQ;
                size[rootQ] += size[rootP];
            }
            // 两个连通分量合并成一个连通分量
            count--;
        }
    
        // 判断节点 p 和节点 q 是否连通
        public boolean connected(int p, int q) {
            int rootP = find(p);
            int rootQ = find(q);
            return rootP == rootQ;
        }
    
        // 返回节点 x 的连通分量根节点
        private int find(int x) {
            while (parent[x] != x) {
                // 进行路径压缩
                parent[x] = parent[parent[x]];
                x = parent[x];
            }
            return x;
        }
    
        // 返回图中的连通分量个数
        public int count() {
            return count;
        }
    }

```

前文 [ Union-Find 并查集算法运用 ](https://labuladong.gitee.io/algo/2/18/38/) 介绍过 Union-Find 算法的一些算法场景，而它在 Kruskal 算法中的主要作用是保证最小生成树的合法性。

因为在构造最小生成树的过程中，你首先得保证生成的那玩意是棵树（不包含环）对吧，那么 Union-Find 算法就是帮你干这个事儿的。

怎么做到的呢？先来看看力扣第 261 题「以图判树」，我描述下题目：

给你输入编号从 ` 0 ` 到 ` n - 1 ` 的 ` n ` 个结点，和一个无向边列表 ` edges `（每条边用节点二元组表示），请你判断输入的这些边组成的结构是否是一棵树。

函数签名如下：

```java
    boolean validTree(int n, int[][] edges);

```

比如输入如下：

```java
    n = 5
    edges = [[0,1], [0,2], [0,3], [1,4]]

```

这些边构成的是一棵树，算法应该返回 true：

![](https://labuladong.gitee.io/algo/images/kruskal/2.png)

但如果输入：

```java
    n = 5
    edges = [[0,1],[1,2],[2,3],[1,3],[1,4]]

```

形成的就不是树结构了，因为包含环：

![](https://labuladong.gitee.io/algo/images/kruskal/3.png)

**对于这道题，我们可以思考一下，什么情况下加入一条边会使得树变成图（出现环）** ？

显然，像下面这样添加边会出现环：

![](https://labuladong.gitee.io/algo/images/kruskal/4.png)

而这样添加边则不会出现环：

![](https://labuladong.gitee.io/algo/images/kruskal/5.png)

总结一下规律就是：

**对于添加的这条边，如果该边的两个节点本来就在同一连通分量里，那么添加这条边会产生环；反之，如果该边的两个节点不在同一连通分量里，则添加这条边不会产生环**。

而判断两个节点是否连通（是否在同一个连通分量中）就是 Union-Find 算法的拿手绝活，所以这道题的解法代码如下：

```java
    // 判断输入的若干条边是否能构造出一棵树结构
    boolean validTree(int n, int[][] edges) {
        // 初始化 0...n-1 共 n 个节点
        UF uf = new UF(n);
        // 遍历所有边，将组成边的两个节点进行连接
        for (int[] edge : edges) {
            int u = edge[0];
            int v = edge[1];
            // 若两个节点已经在同一连通分量中，会产生环
            if (uf.connected(u, v)) {
                return false;
            }
            // 这条边不会产生环，可以是树的一部分
            uf.union(u, v);
        }
        // 要保证最后只形成了一棵树，即只有一个连通分量
        return uf.count() == 1;
    }
    
    class UF {
        // 见上文代码实现
    }

```

如果你能够看懂这道题的解法思路，那么掌握 Kruskal 算法就很简单了。

### Kruskal 算法

所谓最小生成树，就是图中若干边的集合（我们后文称这个集合为 ` mst ` ，最小生成树的英文缩写），你要保证这些边：

1、包含图中的所有节点。

2、形成的结构是树结构（即不存在环）。

3、权重和最小。

有之前题目的铺垫，前两条其实可以很容易地利用 Union-Find 算法做到，关键在于第 3 点，如何保证得到的这棵生成树是权重和最小的。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**

应合作方要求，本文不便在此发布，请扫码关注回复关键词「生成树」查看：

![](https://labuladong.gitee.io/algo/images/qrcode.jpg)

## 众里寻他千百度：名流问题


读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 277. 搜索名人（中等） ](https://leetcode-cn.com/problems/find-the-celebrity/)

**———–**

今天来讨论经典的「名流问题」：

给你 ` n ` 个人的社交关系（你知道任意两个人之间是否认识），然后请你找出这些人中的「名人」。

所谓「名人」有两个条件：

1、所有其他人都认识「名人」。

2、「名人」不认识任何其他人。

这是一个图相关的算法问题，社交关系嘛，本质上就可以抽象成一幅图。

如果把每个人看做图中的节点，「认识」这种关系看做是节点之间的有向边，那么名人就是这幅图中一个特殊的节点：

![](https://labuladong.gitee.io/algo/images/%e5%90%8d%e4%ba%ba%e9%97%ae%e9%a2%98/1.jpeg)

**这个节点没有一条指向其他节点的有向边；且其他所有节点都有一条指向这个节点的有向边** 。

或者说的专业一点，名人节点的出度为 0，入度为 ` n - 1 ` 。

那么，这 ` n ` 个人的社交关系是如何表示的呢？

前文 [ 图论算法基础 ](https://labuladong.gitee.io/algo/2/18/34/)说过，图有两种存储形式，一种是邻接表，一种是邻接矩阵，邻接表的主要优势是节约存储空间；邻接矩阵的主要优势是可以迅速判断两个节点是否相邻。

对于名人问题，显然会经常需要判断两个人之间是否认识，也就是两个节点是否相邻，所以我们可以用邻接表来表示人和人之间的社交关系。

那么，把名流问题描述成算法的形式就是这样的：

给你输入一个大小为 ` n x n ` 的二维数组（邻接矩阵） ` graph ` 表示一幅有 ` n ` 个节点的图，每个人都是图中的一个节点，编号为 `0 ` 到 ` n - 1 ` 。

如果 ` graph[i][j] == 1 ` 代表第 ` i ` 个人认识第 ` j ` 个人，如果 ` graph[i][j] == 0 ` 代表第 `i ` 个人不认识第 ` j ` 个人。

有了这幅图表示人与人之间的关系，请你计算，这 ` n ` 个人中，是否存在「名人」？

如果存在，算法返回这个名人的编号，如果不存在，算法返回 -1。

函数签名如下：

```java
    int findCelebrity(int[][] graph);

```

比如输入的邻接矩阵长这样：

![](https://labuladong.gitee.io/algo/images/%e5%90%8d%e4%ba%ba%e9%97%ae%e9%a2%98/2.jpeg)

那么算法应该返回 2。

力扣第 277 题「搜寻名人」就是这个经典问题，不过并不是直接把邻接矩阵传给你，而是只告诉你总人数 ` n ` ，同时提供一个 API ` knows `来查询人和人之间的社交关系：

```java
    // 可以直接调用，能够返回 i 是否认识 j
    boolean knows(int i, int j);
    
    // 请你实现：返回「名人」的编号
    int findCelebrity(int n) {
        // todo
    }

```

很明显， ` knows ` API 本质上还是在访问邻接矩阵。为了简单起见，我们后面就按力扣的题目形式来探讨一下这个经典问题。

### 暴力解法

我们拍拍脑袋就能写出一个简单粗暴的算法：

```java
    int findCelebrity(int n) {
        for (int cand = 0; cand < n; cand++) {
            int other;
            for (other = 0; other < n; other++) {
                if (cand == other) continue;
                // 保证其他人都认识 cand，且 cand 不认识任何其他人
                // 否则 cand 就不可能是名人
                if (knows(cand, other) || !knows(other, cand)) {
                    break;
                }
            }
            if (other == n) {
                // 找到名人
                return cand;
            }
        }
        // 没有一个人符合名人特性
        return -1;
    }

```

` cand ` 是候选人（candidate）的缩写，我们的暴力算法就是从头开始穷举，把每个人都视为候选人，判断是否符合「名人」的条件。

刚才也说了， ` knows ` 函数底层就是在访问一个二维的邻接矩阵，一次调用的时间复杂度是 O(1)，所以这个暴力解法整体的最坏时间复杂度是 O(N^2)。

那么，是否有其他高明的办法来优化时间复杂度呢？其实是有优化空间的，你想想，我们现在最耗时的地方在哪里？

对于每一个候选人 ` cand ` ，我们都要用一个内层 for 循环去判断这个 ` cand ` 到底符不符合「名人」的条件。

这个内层 for 循环看起来就蠢，虽然判断一个人「是名人」必须用一个 for 循环，但判断一个人「不是名人」就不用这么麻烦了。

**因为「名人」的定义保证了「名人」的唯一性，所以我们可以利用排除法，先排除那些显然不是「名人」的人，从而避免 for 循环的嵌套，降低时间复杂度** 。

### 优化解法

我再重复一遍所谓「名人」的定义：

1、所有其他人都认识名人。

2、名人不认识任何其他人。

这个定义就很有意思，它保证了人群中最多有一个名人。

这很好理解，如果有两个人同时是名人，那么这两条定义就自相矛盾了。

**换句话说，只要观察任意两个候选人的关系，我一定能确定其中的一个人不是名人，把他排除** 。

至于另一个候选人是不是名人，只看两个人的关系肯定是不能确定的，但这不重要，重要的是排除掉一个必然不是名人的候选人，缩小了包围圈。

这是优化的核心，也是比较难理解的，所以我们先来说说为什么观察任意两个候选人的关系，就能排除掉一个。

你想想，两个人之间的关系可能是什么样的？

无非就是四种：你认识我我不认识你，我认识你你不认识我，咱俩互相认识，咱两互相不认识。

如果把人比作节点，红色的有向边表示不认识，绿色的有向边表示认识，那么两个人的关系无非是如下四种情况：

![](https://labuladong.gitee.io/algo/images/%e5%90%8d%e4%ba%ba%e9%97%ae%e9%a2%98/3.jpeg)

不妨认为这两个人的编号分别是 ` cand ` 和 ` other ` ，然后我们逐一分析每种情况，看看怎么排除掉一个人。

对于情况一， ` cand ` 认识 ` other ` ，所以 ` cand ` 肯定不是名人，排除。因为名人不可能认识别人。

对于情况二， ` other ` 认识 ` cand ` ，所以 ` other ` 肯定不是名人，排除。

对于情况三，他俩互相认识，肯定都不是名人，可以随便排除一个。

对于情况四，他俩互不认识，肯定都不是名人，可以随便排除一个。因为名人应该被所有其他人认识。

综上，只要观察任意两个之间的关系，就至少能确定一个人不是名人，上述情况判断可以用如下代码表示：

```java
    if (knows(cand, other) || !knows(other, cand)) {
        // cand 不可能是名人
    } else {
        // other 不可能是名人
    }

```

如果能够理解这一个特点，那么写出优化解法就简单了。

**我们可以不断从候选人中选两个出来，然后排除掉一个，直到最后只剩下一个候选人，这时候再使用一个 for 循环判断这个候选人是否是货真价实的「名人」** 。

这个思路的完整代码如下：

```java
    int findCelebrity(int n) {
        if (n == 1) return 0;
        // 将所有候选人装进队列
        LinkedList<Integer> q = new LinkedList<>();
        for (int i = 0; i < n; i++) {
            q.addLast(i);
        }
        // 一直排除，直到只剩下一个候选人停止循环
        while (q.size() >= 2) {
            // 每次取出两个候选人，排除一个
            int cand = q.removeFirst();
            int other = q.removeFirst();
            if (knows(cand, other) || !knows(other, cand)) {
                // cand 不可能是名人，排除，让 other 归队
                q.addFirst(other);
            } else {
                // other 不可能是名人，排除，让 cand 归队
                q.addFirst(cand);
            }
        }
    
        // 现在排除得只剩一个候选人，判断他是否真的是名人
        int cand = q.removeFirst();
        for (int other = 0; other < n; other++) {
            if (other == cand) {
                continue;
            }
            // 保证其他人都认识 cand，且 cand 不认识任何其他人
            if (!knows(other, cand) || knows(cand, other)) {
                return -1;
            }
        }
        // cand 是名人
        return cand;
    }

```

这个算法避免了嵌套 for 循环，时间复杂度降为 O(N) 了，不过引入了一个队列来存储候选人集合，使用了 O(N) 的空间复杂度。

> PS： ` LinkedList `> 的作用只是充当一个容器把候选人装起来，每次找出两个进行比较和淘汰，但至于具体找出哪两个，都是无所谓的，也就是说候选人归队的顺序无所谓，我们用的是 `> addFirst ` 只是方便后续的优化，你完全可以用 ` addLast ` ，结果都是一样的。

是否可以进一步优化，把空间复杂度也优化掉？

### 最终解法

如果你能够理解上面的优化解法，其实可以不需要额外的空间解决这个问题，代码如下：

```java
    int findCelebrity(int n) {
        // 先假设 cand 是名人
        int cand = 0;
        for (int other = 1; other < n; other++) {
            if (!knows(other, cand) || knows(cand, other)) {
                // cand 不可能是名人，排除
                // 假设 other 是名人
                cand = other;
            } else {
                // other 不可能是名人，排除
                // 什么都不用做，继续假设 cand 是名人
            }
        }
    
        // 现在的 cand 是排除的最后结果，但不能保证一定是名人
        for (int other = 0; other < n; other++) {
            if (cand == other) continue;
            // 需要保证其他人都认识 cand，且 cand 不认识任何其他人
            if (!knows(other, cand) || knows(cand, other)) {
                return -1;
            }
        }
    
        return cand;
    }

```

我们之前的解法用到了 ` LinkedList ` 充当一个队列，用于存储候选人集合，而这个优化解法利用 ` other ` 和 ` cand `的交替变化，模拟了我们之前操作队列的过程，避免了使用额外的存储空间。

现在，解决名人问题的解法时间复杂度为 O(N)，空间复杂度为 O(1)，已经是最优解法了。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


## 我写了一个模板，把 Dijkstra 算法变成了默写题


读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 743. 网络延迟时间（中等） ](https://leetcode-cn.com/problems/network-delay-time)

[ 1514. 概率最大的路径（中等） ](https://leetcode-cn.com/problems/path-with-maximum-
probability)

[ 1631. 最小体力消耗路径（中等） ](https://leetcode-cn.com/problems/path-with-minimum-
effort)

**———–**

其实，很多算法的底层原理异常简单，无非就是一步一步延伸，变得 **看起来** 好像特别复杂，特别牛逼。

但如果你看过历史文章，应该可以对算法形成自己的理解，就会发现很多算法都是换汤不换药，毫无新意，非常枯燥。

比如，我们说二叉树非常重要，你把这个结构掌握了，就会发现 [ 动态规划 ](https://labuladong.gitee.io/algo/3/22/66/) ， [ 分治算法](https://labuladong.gitee.io/algo/4/30/125/) ， [ 回溯（DFS）算法 ](https://labuladong.gitee.io/algo/4/28/105/) ， [ BFS 算法框架](https://labuladong.gitee.io/algo/4/28/110/) ， [ Union-Find 并查集算法 ](https://labuladong.gitee.io/algo/2/18/38/) ， [ 二叉堆实现优先级队列](https://labuladong.gitee.io/algo/2/19/50/) 就是把二叉树翻来覆去的运用。

那么本文又要告诉你，Dijkstra 算法（一般音译成迪杰斯特拉算法）无非就是一个 BFS 算法的加强版，它们都是从二叉树的层序遍历衍生出来的。

这也是为什么我在 [ 学习数据结构和算法的框架思维 ](https://labuladong.gitee.io/algo/1/2/) 中这么强调二叉树的原因。

**下面我们由浅入深，从二叉树的层序遍历聊到 Dijkstra 算法，给出 Dijkstra 算法的代码框架，顺手秒杀几道运用 Dijkstra 算法的题目** 。

### 图的抽象

前文 [ 图论第一期：遍历基础 ](https://labuladong.gitee.io/algo/2/18/34/)说过「图」这种数据结构的基本实现，图中的节点一般就抽象成一个数字（索引），图的具体实现一般是「邻接矩阵」或者「邻接表」。

![](https://labuladong.gitee.io/algo/images/%e5%9b%be/0.jpg)

比如上图这幅图用邻接表和邻接矩阵的存储方式如下：

![](https://labuladong.gitee.io/algo/images/%e5%9b%be/2.jpeg)

前文 [ 图论第二期：拓扑排序 ](https://labuladong.gitee.io/algo/2/18/35/) 告诉你，我们用邻接表的场景更多，结合上图，一幅图可以用如下 Java 代码表示：

```java
    // graph[s] 存储节点 s 指向的节点（出度）
    List<Integer>[] graph;

```

**如果你想把一个问题抽象成「图」的问题，那么首先要实现一个 API` adj ` ** ：

```java
    // 输入节点 s 返回 s 的相邻节点
    List<Integer> adj(int s);

```

类似多叉树节点中的 ` children ` 字段记录当前节点的所有子节点， ` adj(s) ` 就是计算一个节点 ` s ` 的相邻节点。

比如上面说的用邻接表表示「图」的方式， ` adj ` 函数就可以这样表示：

```java
    List<Integer>[] graph;
    
    // 输入节点 s，返回 s 的相邻节点
    List<Integer> adj(int s) {
        return graph[s];
    }

```

当然，对于「加权图」，我们需要知道两个节点之间的边权重是多少，所以还可以抽象出一个 ` weight ` 方法：

```java
    // 返回节点 from 到节点 to 之间的边的权重
    int weight(int from, int to);

```

这个 ` weight ` 方法可以根据实际情况而定，因为不同的算法题，题目给的「权重」含义可能不一样，我们存储权重的方式也不一样。

有了上述基础知识，就可以搞定 Dijkstra 算法了，下面我给你从二叉树的层序遍历开始推演出 Dijkstra 算法的实现。

### 二叉树层级遍历和 BFS 算法

我们之前说过二叉树的层级遍历框架：

```java
    // 输入一棵二叉树的根节点，层序遍历这棵二叉树
    void levelTraverse(TreeNode root) {
        if (root == null) return 0;
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);
    
        int depth = 1;
        // 从上到下遍历二叉树的每一层
        while (!q.isEmpty()) {
            int sz = q.size();
            // 从左到右遍历每一层的每个节点
            for (int i = 0; i < sz; i++) {
                TreeNode cur = q.poll();
                printf("节点 %s 在第 %s 层", cur, depth);
    
                // 将下一层节点放入队列
                if (cur.left != null) {
                    q.offer(cur.left);
                }
                if (cur.right != null) {
                    q.offer(cur.right);
                }
            }
            depth++;
        }
    }

```

我们先来思考一个问题，注意二叉树的层级遍历 ` while ` 循环里面还套了个 ` for ` 循环，为什么要这样？

` while ` 循环和 ` for ` 循环的配合正是这个遍历框架设计的巧妙之处：

![](https://labuladong.gitee.io/algo/images/dijkstra/1.jpeg)

**` while ` 循环控制一层一层往下走， ` for ` 循环利用 ` sz ` 变量控制从左到右遍历每一层二叉树节点 ** 。

注意我们代码框架中的 ` depth ` 变量，其实就记录了当前遍历到的层数。换句话说，每当我们遍历到一个节点 ` cur ` ，都知道这个节点属于第几层。

算法题经常会问二叉树的最大深度呀，最小深度呀，层序遍历结果呀，等等问题，所以记录下来这个深度 ` depth ` 是有必要的。

基于二叉树的遍历框架，我们又可以扩展出多叉树的层序遍历框架：

```java
    // 输入一棵多叉树的根节点，层序遍历这棵多叉树
    void levelTraverse(TreeNode root) {
        if (root == null) return;
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);
    
        int depth = 1;
        // 从上到下遍历多叉树的每一层
        while (!q.isEmpty()) {
            int sz = q.size();
            // 从左到右遍历每一层的每个节点
            for (int i = 0; i < sz; i++) {
                TreeNode cur = q.poll();
                printf("节点 %s 在第 %s 层", cur, depth);
    
                // 将下一层节点放入队列
                for (TreeNode child : cur.children) {
                    q.offer(child);
                }
            }
            depth++;
        }
    }

```

基于多叉树的遍历框架，我们又可以扩展出 BFS（广度优先搜索）的算法框架：

```java
    // 输入起点，进行 BFS 搜索
    int BFS(Node start) {
        Queue<Node> q; // 核心数据结构
        Set<Node> visited; // 避免走回头路
        
        q.offer(start); // 将起点加入队列
        visited.add(start);
    
        int step = 0; // 记录搜索的步数
        while (q not empty) {
            int sz = q.size();
            /* 将当前队列中的所有节点向四周扩散一步 */
            for (int i = 0; i < sz; i++) {
                Node cur = q.poll();
                printf("从 %s 到 %s 的最短距离是 %s", start, cur, step);
    
                /* 将 cur 的相邻节点加入队列 */
                for (Node x : cur.adj()) {
                    if (x not in visited) {
                        q.offer(x);
                        visited.add(x);
                    }
                }
            }
            step++;
        }
    }

```

如果对 BFS 算法不熟悉，可以看前文 [ BFS 算法框架 ](https://labuladong.gitee.io/algo/4/28/110/) ，这里只是为了让你做个对比，所谓 BFS 算法，就是把算法问题抽象成一幅「无权图」，然后继续玩二叉树层级遍历那一套罢了。

**注意，我们的 BFS 算法框架也是` while ` 循环嵌套 ` for ` 循环的形式，也用了一个 ` step ` 变量记录 ` for `循环执行的次数，无非就是多用了一个 ` visited ` 集合记录走过的节点，防止走回头路罢了 ** 。

为什么这样呢？

所谓「无权图」，与其说每条「边」没有权重，不如说每条「边」的权重都是 1，从起点 ` start `到任意一个节点之间的路径权重就是它们之间「边」的条数，那可不就是 ` step ` 变量记录的值么？

再加上 BFS 算法利用 ` for ` 循环一层一层向外扩散的逻辑和 ` visited ` 集合防止走回头路的逻辑，当你每次从队列中拿出节点 ` cur
` 的时候，从 ` start ` 到 ` cur ` 的最短权重就是 ` step ` 记录的步数。

但是，到了「加权图」的场景，事情就没有这么简单了，因为你不能默认每条边的「权重」都是 1 了，这个权重可以是任意正数（Dijkstra 算法要求不能存在负权重边），比如下图的例子：

![](https://labuladong.gitee.io/algo/images/dijkstra/2.jpeg)

如果沿用 BFS 算法中的 ` step `变量记录「步数」，显然红色路径一步就可以走到终点，但是这一步的权重很大；正确的最小权重路径应该是绿色的路径，虽然需要走很多步，但是路径权重依然很小。

其实 Dijkstra 和 BFS 算法差不多，不过在讲解 Dijkstra 算法框架之前，我们首先需要对之前的框架进行如下改造：

**想办法去掉` while ` 循环里面的 ` for ` 循环 ** 。

为什么？有了刚才的铺垫，这个不难理解，刚才说 ` for ` 循环是干什么用的来着？

是为了让二叉树一层一层往下遍历，让 BFS 算法一步一步向外扩散，因为这个层数 ` depth ` ，或者这个步数 ` step ` ，在之前的场景中有用。

但现在我们想解决「加权图」中的最短路径问题，「步数」已经没有参考意义了，「路径的权重之和」才有意义，所以这个 ` for ` 循环可以被去掉。

怎么去掉？就拿二叉树的层级遍历来说，其实你可以直接去掉 ` for ` 循环相关的代码：

```java
    // 输入一棵二叉树的根节点，遍历这棵二叉树所有节点
    void levelTraverse(TreeNode root) {
        if (root == null) return 0;
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);
    
        // 遍历二叉树的每一个节点
        while (!q.isEmpty()) {
            TreeNode cur = q.poll();
            printf("我不知道节点 %s 在第几层", cur);
    
            // 将子节点放入队列
            if (cur.left != null) {
                q.offer(cur.left);
            }
            if (cur.right != null) {
                q.offer(cur.right);
            }
        }
    }

```

但问题是，没有 ` for ` 循环，你也没办法维护 ` depth ` 变量了。

如果你想同时维护 ` depth ` 变量，让每个节点 ` cur ` 知道自己在第几层，可以想其他办法，比如新建一个 ` State `类，记录每个节点所在的层数：

```java
    class State {
        // 记录 node 节点的深度
        int depth;
        TreeNode node;
    
        State(TreeNode node, int depth) {
            this.depth = depth;
            this.node = node;
        }
    }
    
    // 输入一棵二叉树的根节点，遍历这棵二叉树所有节点
    void levelTraverse(TreeNode root) {
        if (root == null) return 0;
        Queue<State> q = new LinkedList<>();
        q.offer(new State(root, 1));
    
        // 遍历二叉树的每一个节点
        while (!q.isEmpty()) {
            State cur = q.poll();
            TreeNode cur_node = cur.node;
            int cur_depth = cur.depth;
            printf("节点 %s 在第 %s 层", cur_node, cur_depth);
    
            // 将子节点放入队列
            if (cur_node.left != null) {
                q.offer(new State(cur_node.left, cur_depth + 1));
            }
            if (cur_node.right != null) {
                q.offer(new State(cur_node.right, cur_depth + 1));
            }
        }
    }

```

这样，我们就可以不使用 ` for ` 循环也确切地知道每个二叉树节点的深度了。

**如果你能够理解上面这段代码，我们就可以来看 Dijkstra 算法的代码框架了** 。

### Dijkstra 算法框架

**首先，我们先看一下 Dijkstra 算法的签名** ：

```java
    // 输入一幅图和一个起点 start，计算 start 到其他节点的最短距离
    int[] dijkstra(int start, List<Integer>[] graph);

```

输入是一幅图 ` graph ` 和一个起点 ` start ` ，返回是一个记录最短路径权重的数组。

比方说，输入起点 ` start = 3 ` ，函数返回一个 ` int[] ` 数组，假设赋值给 ` distTo ` 变量，那么从起点 ` 3 `到节点 ` 6 ` 的最短路径权重的值就是 ` distTo[6] ` 。

是的，标准的 Dijkstra 算法会把从起点 ` start ` 到所有其他节点的最短路径都算出来。

当然，如果你的需求只是计算从起点 ` start ` 到某一个终点 ` end ` 的最短路径，那么在标准 Dijkstra 算法上稍作修改就可以更高效地完成这个需求，这个我们后面再说。

**其次，我们也需要一个` State ` 类来辅助算法的运行 ** ：

```java
    class State {
        // 图节点的 id
        int id;
        // 从 start 节点到当前节点的距离
        int distFromStart;
    
        State(int id, int distFromStart) {
            this.id = id;
            this.distFromStart = distFromStart;
        }
    }

```

类似刚才二叉树的层序遍历，我们也需要用 ` State ` 类记录一些额外信息，也就是使用 ` distFromStart ` 变量记录从起点 `start ` 到当前这个节点的距离。

刚才说普通 BFS 算法中，根据 BFS 的逻辑和无权图的特点，第一次遇到某个节点所走的步数就是最短距离，所以用一个 ` visited `数组防止走回头路，每个节点只会经过一次。

加权图中的 Dijkstra 算法和无权图中的普通 BFS 算法不同，在 Dijkstra 算法中，你第一次经过某个节点时的路径权重，不见得就是最小的，所以对于同一个节点，我们可能会经过多次，而且每次的 ` distFromStart `可能都不一样，比如下图：

![](https://labuladong.gitee.io/algo/images/dijkstra/3.jpeg)

我会经过节点 ` 5 ` 三次，每次的 ` distFromStart ` 值都不一样，那我取 ` distFromStart ` 最小的那次，不就是从起点
` start ` 到节点 ` 5 ` 的最短路径权重了么？

好了，明白上面的几点，我们可以来看看 Dijkstra 算法的代码模板。

**其实，Dijkstra 可以理解成一个带 dp table（或者说备忘录）的 BFS 算法，伪码如下** ：

```java
    // 返回节点 from 到节点 to 之间的边的权重
    int weight(int from, int to);
    
    // 输入节点 s 返回 s 的相邻节点
    List<Integer> adj(int s);
    
    // 输入一幅图和一个起点 start，计算 start 到其他节点的最短距离
    int[] dijkstra(int start, List<Integer>[] graph) {
        // 图中节点的个数
        int V = graph.length;
        // 记录最短路径的权重，你可以理解为 dp table
        // 定义：distTo[i] 的值就是节点 start 到达节点 i 的最短路径权重
        int[] distTo = new int[V];
        // 求最小值，所以 dp table 初始化为正无穷
        Arrays.fill(distTo, Integer.MAX_VALUE);
        // base case，start 到 start 的最短距离就是 0
        distTo[start] = 0;
    
        // 优先级队列，distFromStart 较小的排在前面
        Queue<State> pq = new PriorityQueue<>((a, b) -> {
            return a.distFromStart - b.distFromStart;
        });
    
        // 从起点 start 开始进行 BFS
        pq.offer(new State(start, 0));
    
        while (!pq.isEmpty()) {
            State curState = pq.poll();
            int curNodeID = curState.id;
            int curDistFromStart = curState.distFromStart;
    
            if (curDistFromStart > distTo[curNodeID]) {
                // 已经有一条更短的路径到达 curNode 节点了
                continue;
            }
            // 将 curNode 的相邻节点装入队列
            for (int nextNodeID : adj(curNodeID)) {
                // 看看从 curNode 达到 nextNode 的距离是否会更短
                int distToNextNode = distTo[curNodeID] + weight(curNodeID, nextNodeID);
                if (distTo[nextNodeID] > distToNextNode) {
                    // 更新 dp table
                    distTo[nextNodeID] = distToNextNode;
                    // 将这个节点以及距离放入队列
                    pq.offer(new State(nextNodeID, distToNextNode));
                }
            }
        }
        return distTo;
    }

```

**对比普通的 BFS 算法，你可能会有以下疑问** ：

**1、没有` visited ` 集合记录已访问的节点，所以一个节点会被访问多次，会被多次加入队列，那会不会导致队列永远不为空，造成死循环 ** ？

**2、为什么用优先级队列` PriorityQueue ` 而不是 ` LinkedList ` 实现的普通队列？为什么要按照 `distFromStart ` 的值来排序 ** ？

**3、如果我只想计算起点` start ` 到某一个终点 ` end ` 的最短路径，是否可以修改算法，提升一些效率 ** ？

我们先回答第一个问题，为什么这个算法不用 ` visited ` 集合也不会死循环。

对于这类问题，我教你一个思考方法：

循环结束的条件是队列为空，那么你就要注意看什么时候往队列里放元素（调用 ` offer ` ）方法，再注意看什么时候从队列往外拿元素（调用 ` poll `方法）。

` while ` 循环每执行一次，都会往外拿一个元素，但想往队列里放元素，可就有很多限制了，必须满足下面这个条件：

```java
    // 看看从 curNode 达到 nextNode 的距离是否会更短
    if (distTo[nextNodeID] > distToNextNode) {
        // 更新 dp table
        distTo[nextNodeID] = distToNextNode;
        pq.offer(new State(nextNodeID, distToNextNode));
    }

```

这也是为什么我说 ` distTo ` 数组可以理解成我们熟悉的 dp table，因为这个算法逻辑就是在不断的最小化 ` distTo ` 数组中的元素：

如果你能让到达 ` nextNodeID ` 的距离更短，那就更新 ` distTo[nextNodeID] ` 的值，让你入队，否则的话对不起，不让入队。

**因为两个节点之间的最短距离（路径权重）肯定是一个确定的值，不可能无限减小下去，所以队列一定会空，队列空了之后，` distTo ` 数组中记录的就是从
` start ` 到其他节点的最短距离 ** 。

接下来解答第二个问题，为什么要用 ` PriorityQueue ` 而不是 ` LinkedList ` 实现的普通队列？

如果你非要用普通队列，其实也没问题的，你可以直接把 ` PriorityQueue ` 改成 ` LinkedList `，也能得到正确答案，但是效率会低很多。

**Dijkstra 算法使用优先级队列，主要是为了效率上的优化，类似一种贪心算法的思路** 。

为什么说是一种贪心思路呢，比如说下面这种情况，你想计算从起点 ` start ` 到终点 ` end ` 的最短路径权重：

![](https://labuladong.gitee.io/algo/images/dijkstra/4.jpeg)

假设你当前只遍历了图中的这几个节点，那么你下一步准备遍历那个节点？这三条路径都可能成为最短路径的一部分，
**但你觉得哪条路径更有「潜力」成为最短路径中的一部分** ？

从目前的情况来看，显然橙色路径的可能性更大嘛，所以我们希望节点 ` 2 ` 排在队列靠前的位置，优先被拿出来向后遍历。

所以我们使用 ` PriorityQueue ` 作为队列，让 ` distFromStart ` 的值较小的节点排在前面，这就类似我们之前讲 [ 贪心算法](https://labuladong.gitee.io/algo/3/26/102/) 说到的贪心思路，可以很大程度上优化算法的效率。

大家应该听过 Bellman-Ford 算法，这个算法是一种更通用的最短路径算法，因为它可以处理带有负权重边的图，Bellman-Ford 算法逻辑和 Dijkstra 算法非常类似，用到的就是普通队列，本文就提一句，后面有空再具体写。

接下来说第三个问题，如果只关心起点 ` start ` 到某一个终点 ` end ` 的最短路径，是否可以修改代码提升算法效率。

肯定可以的，因为我们标准 Dijkstra 算法会算出 ` start ` 到所有其他节点的最短路径，你只想计算到 ` end `的最短路径，相当于减少计算量，当然可以提升效率。

需要在代码中做的修改也非常少，只要改改函数签名，再加个 if 判断就行了：

```java
    // 输入起点 start 和终点 end，计算起点到终点的最短距离
    int dijkstra(int start, int end, List<Integer>[] graph) {
    
        // ...
    
        while (!pq.isEmpty()) {
            State curState = pq.poll();
            int curNodeID = curState.id;
            int curDistFromStart = curState.distFromStart;
    
            // 在这里加一个判断就行了，其他代码不用改
            if (curNodeID == end) {
                return curDistFromStart;
            }
    
            if (curDistFromStart > distTo[curNodeID]) {
                continue;
            }
    
            // ...
        }
    
        // 如果运行到这里，说明从 start 无法走到 end
        return Integer.MAX_VALUE;
    }

```

因为优先级队列自动排序的性质， **每次** 从队列里面拿出来的都是 ` distFromStart ` 值最小的，所以当你 **第一次**
从队列中拿出终点 ` end ` 时，此时的 ` distFromStart ` 对应的值就是从 ` start ` 到 ` end ` 的最短距离。

这个算法较之前的实现提前 return 了，所以效率有一定的提高。

### 时间复杂度分析

Dijkstra 算法的时间复杂度是多少？你去网上查，可能会告诉你是 ` O(ElogV) ` ，其中 ` E ` 代表图中边的条数， ` V `代表图中节点的个数。

因为理想情况下优先级队列中最多装 ` V ` 个节点，对优先级队列的操作次数和 ` E ` 成正比，所以整体的时间复杂度就是 ` O(ElogV) ` 。

不过这是理想情况，Dijkstra 算法的代码实现有很多版本，不同编程语言或者不同数据结构 API 都会导致算法的时间复杂度发生一些改变。

比如本文实现的 Dijkstra 算法，使用了 Java 的 ` PriorityQueue `这个数据结构，这个容器类底层使用二叉堆实现，但没有提供通过索引操作队列中元素的 API，所以队列中会有重复的节点，最多可能有 ` E ` 个节点存在队列中。

所以本文实现的 Dijkstra 算法复杂度并不是理想情况下的 ` O(ElogV) ` ，而是 ` O(ElogE) `，可能会略大一些，因为图中边的条数一般是大于节点的个数的。

不过就对数函数来说，就算真数大一些，对数函数的结果也大不了多少，所以这个算法实现的实际运行效率也是很高的，以上只是理论层面的时间复杂度分析，供大家参考。

### 秒杀三道题目

以上说了 Dijkstra 算法的框架，下面我们套用这个框架做几道题，实践出真知。

第一题是力扣第 743 题「网络延迟时间」，题目如下：

![](https://labuladong.gitee.io/algo/images/dijkstra/title1.jpg)

函数签名如下：

```java
    // times 记录边和权重，n 为节点个数（从 1 开始），k 为起点
    // 计算从 k 发出的信号至少需要多久传遍整幅图
    int networkDelayTime(int[][] times, int n, int k)

```

让你求所有节点都收到信号的时间，你把所谓的传递时间看做距离，实际上就是问你「从节点 ` k `到其他所有节点的最短路径中，最长的那条最短路径距离是多少」，说白了就是让你算从节点 ` k ` 出发到其他所有节点的最短路径，就是标准的 Dijkstra 算法。

在用 Dijkstra 之前，别忘了要满足一些条件，加权有向图，没有负权重边，OK，可以用 Dijkstra 算法计算最短路径。

根据我们之前 Dijkstra 算法的框架，我们可以写出下面代码：

```java
    int networkDelayTime(int[][] times, int n, int k) {
        // 节点编号是从 1 开始的，所以要一个大小为 n + 1 的邻接表
        List<int[]>[] graph = new LinkedList[n + 1];
        for (int i = 1; i <= n; i++) {
            graph[i] = new LinkedList<>();
        }
        // 构造图
        for (int[] edge : times) {
            int from = edge[0];
            int to = edge[1];
            int weight = edge[2];
            // from -> List<(to, weight)>
            // 邻接表存储图结构，同时存储权重信息
            graph[from].add(new int[]{to, weight});
        }
        // 启动 dijkstra 算法计算以节点 k 为起点到其他节点的最短路径
        int[] distTo = dijkstra(k, graph);
    
        // 找到最长的那一条最短路径
        int res = 0;
        for (int i = 1; i < distTo.length; i++) {
            if (distTo[i] == Integer.MAX_VALUE) {
                // 有节点不可达，返回 -1
                return -1;
            }
            res = Math.max(res, distTo[i]);
        }
        return res;
    }
    
    // 输入一个起点 start，计算从 start 到其他节点的最短距离
    int[] dijkstra(int start, List<int[]>[] graph) {}

```

上述代码首先利用题目输入的数据转化成邻接表表示一幅图，接下来我们可以直接套用 Dijkstra 算法的框架：

```java
    class State {
        // 图节点的 id
        int id;
        // 从 start 节点到当前节点的距离
        int distFromStart;
    
        State(int id, int distFromStart) {
            this.id = id;
            this.distFromStart = distFromStart;
        }
    }
    
    // 输入一个起点 start，计算从 start 到其他节点的最短距离
    int[] dijkstra(int start, List<int[]>[] graph) {
        // 定义：distTo[i] 的值就是起点 start 到达节点 i 的最短路径权重
        int[] distTo = new int[graph.length];
        Arrays.fill(distTo, Integer.MAX_VALUE);
        // base case，start 到 start 的最短距离就是 0
        distTo[start] = 0;
    
        // 优先级队列，distFromStart 较小的排在前面
        Queue<State> pq = new PriorityQueue<>((a, b) -> {
            return a.distFromStart - b.distFromStart;
        });
        // 从起点 start 开始进行 BFS
        pq.offer(new State(start, 0));
    
        while (!pq.isEmpty()) {
            State curState = pq.poll();
            int curNodeID = curState.id;
            int curDistFromStart = curState.distFromStart;
    
            if (curDistFromStart > distTo[curNodeID]) {
                continue;
            }
    
            // 将 curNode 的相邻节点装入队列
            for (int[] neighbor : graph[curNodeID]) {
                int nextNodeID = neighbor[0];
                int distToNextNode = distTo[curNodeID] + neighbor[1];
                // 更新 dp table
                if (distTo[nextNodeID] > distToNextNode) {
                    distTo[nextNodeID] = distToNextNode;
                    pq.offer(new State(nextNodeID, distToNextNode));
                }
            }
        }
        return distTo;
    }

```

你对比之前说的代码框架，只要稍稍修改，就可以把这道题目解决了。

感觉这道题完全没有难度，下面我们再看一道题目，力扣第 1631 题「最小体力消耗路径」：

![](https://labuladong.gitee.io/algo/images/dijkstra/title2.jpg)

函数签名如下：

```java
    // 输入一个二维矩阵，计算从左上角到右下角的最小体力消耗
    int minimumEffortPath(int[][] heights);

```

我们常见的二维矩阵题目，如果让你从左上角走到右下角，比较简单的题一般都会限制你只能向右或向下走，但这道题可没有限制哦，你可以上下左右随便走，只要路径的「体力消耗」最小就行。

如果你把二维数组中每个 ` (x, y) `坐标看做一个节点，它的上下左右坐标就是相邻节点，它对应的值和相邻坐标对应的值之差的绝对值就是题目说的「体力消耗」，你就可以理解为边的权重。

这样一想，是不是就在让你以左上角坐标为起点，以右下角坐标为终点，计算起点到终点的最短路径？Dijkstra 算法是不是可以做到？

```java
    // 输入起点 start 和终点 end，计算起点到终点的最短距离
    int dijkstra(int start, int end, List<Integer>[] graph)

```

**只不过，这道题中评判一条路径是长还是短的标准不再是路径经过的权重总和，而是路径经过的权重最大值** 。

明白这一点，再想一下使用 Dijkstra 算法的前提，加权有向图，没有负权重边，求最短路径，OK，可以使用，咱们来套框架。

二维矩阵抽象成图，我们先实现一下图的 ` adj ` 方法，之后的主要逻辑会清晰一些：

```java
    // 方向数组，上下左右的坐标偏移量
    int[][] dirs = new int[][]{{0,1}, {1,0}, {0,-1}, {-1,0}};
    
    // 返回坐标 (x, y) 的上下左右相邻坐标
    List<int[]> adj(int[][] matrix, int x, int y) {
        int m = matrix.length, n = matrix[0].length;
        // 存储相邻节点
        List<int[]> neighbors = new ArrayList<>();
        for (int[] dir : dirs) {
            int nx = x + dir[0];
            int ny = y + dir[1];
            if (nx >= m || nx < 0 || ny >= n || ny < 0) {
                // 索引越界
                continue;
            }
            neighbors.add(new int[]{nx, ny});
        }
        return neighbors;
    }

```

类似的，我们现在认为一个二维坐标 ` (x, y) ` 是图中的一个节点，所以这个 ` State ` 类也需要修改一下：

```java
    class State {
        // 矩阵中的一个位置
        int x, y;
        // 从起点 (0, 0) 到当前位置的最小体力消耗（距离）
        int effortFromStart;
    
        State(int x, int y, int effortFromStart) {
            this.x = x;
            this.y = y;
            this.effortFromStart = effortFromStart;
        }
    }

```

接下来，就可以套用 Dijkstra 算法的代码模板了：

```java
    // Dijkstra 算法，计算 (0, 0) 到 (m - 1, n - 1) 的最小体力消耗
    int minimumEffortPath(int[][] heights) {
        int m = heights.length, n = heights[0].length;
        // 定义：从 (0, 0) 到 (i, j) 的最小体力消耗是 effortTo[i][j]
        int[][] effortTo = new int[m][n];
        // dp table 初始化为正无穷
        for (int i = 0; i < m; i++) {
            Arrays.fill(effortTo[i], Integer.MAX_VALUE);
        }
        // base case，起点到起点的最小消耗就是 0
        effortTo[0][0] = 0;
    
        // 优先级队列，effortFromStart 较小的排在前面
        Queue<State> pq = new PriorityQueue<>((a, b) -> {
            return a.effortFromStart - b.effortFromStart;
        });
        
        // 从起点 (0, 0) 开始进行 BFS
        pq.offer(new State(0, 0, 0));
    
        while (!pq.isEmpty()) {
            State curState = pq.poll();
            int curX = curState.x;
            int curY = curState.y;
            int curEffortFromStart = curState.effortFromStart;
            
            // 到达终点提前结束
            if (curX == m - 1 && curY == n - 1) {
                return curEffortFromStart;
            }
            
            if (curEffortFromStart > effortTo[curX][curY]) {
                continue;
            }
            // 将 (curX, curY) 的相邻坐标装入队列
            for (int[] neighbor : adj(heights, curX, curY)) {
                int nextX = neighbor[0];
                int nextY = neighbor[1];
                // 计算从 (curX, curY) 达到 (nextX, nextY) 的消耗
                int effortToNextNode = Math.max(
                    effortTo[curX][curY], 
                    Math.abs(heights[curX][curY] - heights[nextX][nextY])
                );
                // 更新 dp table
                if (effortTo[nextX][nextY] > effortToNextNode) {
                    effortTo[nextX][nextY] = effortToNextNode;
                    pq.offer(new State(nextX, nextY, effortToNextNode));
                }
            }
        }
        // 正常情况不会达到这个 return
        return -1;
    }

```

你看，稍微改一改代码模板，这道题就解决了。

最后看一道题吧，力扣第 1514 题「概率最大的路径」，看下题目：

![](https://labuladong.gitee.io/algo/images/dijkstra/title3.jpg)

函数签名如下：

```java
    // 输入一幅无向图，边上的权重代表概率，返回从 start 到达 end 最大的概率
    double maxProbability(int n, int[][] edges, double[] succProb, int start, int end)

```

我说这题一看就是 Dijkstra 算法，但聪明的你肯定会反驳我：

**1、这题给的是无向图，也可以用 Dijkstra 算法吗** ？

**2、更重要的是，Dijkstra 算法计算的是最短路径，计算的是最小值，这题让你计算最大概率是一个最大值，怎么可能用 Dijkstra 算法呢** ？

问得好！

首先关于有向图和无向图，前文 [ 图算法基础 ](https://labuladong.gitee.io/algo/2/18/34/) 说过，无向图本质上可以认为是「双向图」，从而转化成有向图。

重点说说最大值和最小值这个问题，其实 Dijkstra 和很多最优化算法一样，计算的是「最优值」，这个最优值可能是最大值，也可能是最小值。

标准 Dijkstra 算法是计算最短路径的，但你有想过为什么 Dijkstra 算法不允许存在负权重边么？

**因为 Dijkstra 计算最短路径的正确性依赖一个前提：路径中每增加一条边，路径的总权重就会增加** 。

这个前提的数学证明大家有兴趣可以自己搜索一下，我这里只说结论，其实你把这个结论反过来也是 OK 的：

如果你想计算最长路径，路径中每增加一条边，路径的总权重就会减少，要是能够满足这个条件，也可以用 Dijkstra 算法。

你看这道题是不是符合这个条件？边和边之间是乘法关系，每条边的概率都是小于 1 的，所以肯定会越乘越小。

只不过，这道题的解法要把优先级队列的排序顺序反过来，一些 if 大小判断也要反过来，我们直接看解法代码吧：

```java
    double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {
        List<double[]>[] graph = new LinkedList[n];
        for (int i = 0; i < n; i++) {
            graph[i] = new LinkedList<>();
        }
        // 构造邻接表结构表示图
        for (int i = 0; i < edges.length; i++) {
            int from = edges[i][0];
            int to = edges[i][1];
            double weight = succProb[i];
            // 无向图就是双向图；先把 int 统一转成 double，待会再转回来
            graph[from].add(new double[]{(double)to, weight});
            graph[to].add(new double[]{(double)from, weight});
        }
        
        return dijkstra(start, end, graph);
    }
    
    class State {
        // 图节点的 id
        int id;
        // 从 start 节点到达当前节点的概率
        double probFromStart;
    
        State(int id, double probFromStart) {
            this.id = id;
            this.probFromStart = probFromStart;
        }
    }
    
    double dijkstra(int start, int end, List<double[]>[] graph) {
        // 定义：probTo[i] 的值就是节点 start 到达节点 i 的最大概率
        double[] probTo = new double[graph.length];
        // dp table 初始化为一个取不到的最小值
        Arrays.fill(probTo, -1);
        // base case，start 到 start 的概率就是 1
        probTo[start] = 1;
    
        // 优先级队列，probFromStart 较大的排在前面
        Queue<State> pq = new PriorityQueue<>((a, b) -> {
            return Double.compare(b.probFromStart, a.probFromStart);
        });
        // 从起点 start 开始进行 BFS
        pq.offer(new State(start, 1));
    
        while (!pq.isEmpty()) {
            State curState = pq.poll();
            int curNodeID = curState.id;
            double curProbFromStart = curState.probFromStart;
    
            // 遇到终点提前返回
            if (curNodeID == end) {
                return curProbFromStart;
            }
            
            if (curProbFromStart < probTo[curNodeID]) {
                // 已经有一条概率更大的路径到达 curNode 节点了
                continue;
            }
            // 将 curNode 的相邻节点装入队列
            for (double[] neighbor : graph[curNodeID]) {
                int nextNodeID = (int)neighbor[0];
                // 看看从 curNode 达到 nextNode 的概率是否会更大
                double probToNextNode = probTo[curNodeID] * neighbor[1];
                if (probTo[nextNodeID] < probToNextNode) {
                    probTo[nextNodeID] = probToNextNode;
                    pq.offer(new State(nextNodeID, probToNextNode));
                }
            }
        }
        // 如果到达这里，说明从 start 开始无法到达 end，返回 0
        return 0.0;
    }

```

好了，到这里本文就结束了，总共 6000 多字，这三道例题都是比较困难的，如果你能够看到这里，真得给你鼓掌。

其实前文 [ 毕业旅行省钱算法 ](https://labuladong.gitee.io/algo/3/25/87/) 中讲过限制之下的最小路径问题，当时是使用动态规划思路解决的，但文末也给了 Dijkstra
算法代码，仅仅在本文模板的基础上做了一些变换，你理解本文后可以对照着去看看那道题目。

最后还是那句话，做题在质不在量，希望大家能够透彻理解最基本的数据结构，以不变应万变。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


# 手把手设计数据结构

1、《算法秘籍》和《刷题笔记》两本 PDF 下载 [ 点这里](https://mp.weixin.qq.com/s/X-fE9sR4BLi6T9pn7xP4pg) 。

2、刷题插件下载及使用手册 [ 点这里 ](https://mp.weixin.qq.com/s/wIxflO1dvXzDlibhEcENcQ) 。

3、公众号菜单栏参与 [ 21 天算法挑战活动 ](https://mp.weixin.qq.com/s/eUG2OOzY3k_ZTz-CFvtv5Q) 。

## 算法就像搭乐高：带你手撸 LRU 算法


读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 146. LRU缓存机制（中等） ](https://leetcode-cn.com/problems/lru-cache/)

**———–**

LRU 算法就是一种缓存淘汰策略，原理不难，但是面试中写出没有 bug 的算法比较有技巧，需要对数据结构进行层层抽象和拆解，本文 labuladong 就给你写一手漂亮的代码。

计算机的缓存容量有限，如果缓存满了就要删除一些内容，给新内容腾位置。但问题是，删除哪些内容呢？我们肯定希望删掉哪些没什么用的缓存，而把有用的数据继续留在缓存里，方便之后继续使用。那么，什么样的数据，我们判定为「有用的」的数据呢？

LRU 缓存淘汰算法就是一种常用策略。LRU 的全称是 Least Recently Used，也就是说我们认为最近使用过的数据应该是是「有用的」，很久都没用过的数据应该是无用的，内存满了就优先删那些很久没用过的数据。

举个简单的例子，安卓手机都可以把软件放到后台运行，比如我先后打开了「设置」「手机管家」「日历」，那么现在他们在后台排列的顺序是这样的：

![](https://labuladong.gitee.io/algo/images/LRU%E7%AE%97%E6%B3%95/1.jpg)

但是这时候如果我访问了一下「设置」界面，那么「设置」就会被提前到第一个，变成这样：

![](https://labuladong.gitee.io/algo/images/LRU%E7%AE%97%E6%B3%95/2.jpg)

假设我的手机只允许我同时开 3 个应用程序，现在已经满了。那么如果我新开了一个应用「时钟」，就必须关闭一个应用为「时钟」腾出一个位置，关那个呢？

按照 LRU 的策略，就关最底下的「手机管家」，因为那是最久未使用的，然后把新开的应用放到最上面：

![](https://labuladong.gitee.io/algo/images/LRU%E7%AE%97%E6%B3%95/3.jpg)

现在你应该理解 LRU（Least Recently Used）策略了。当然还有其他缓存淘汰策略，比如不要按访问的时序来淘汰，而是按访问频率（LFU 策略）来淘汰等等，各有应用场景。本文讲解 LRU 算法策略。

### 一、LRU 算法描述

力扣第 146 题「LRU缓存机制」就是让你设计数据结构：

首先要接收一个 ` capacity ` 参数作为缓存的最大容量，然后实现两个 API，一个是 ` put(key, val) ` 方法存入键值对，另一个是
` get(key) ` 方法获取 ` key ` 对应的 ` val ` ，如果 ` key ` 不存在则返回 -1。

注意哦， ` get ` 和 ` put ` 方法必须都是 ` O(1) ` 的时间复杂度，我们举个具体例子来看看 LRU 算法怎么工作。

```java
    /* 缓存容量为 2 */
    LRUCache cache = new LRUCache(2);
    // 你可以把 cache 理解成一个队列
    // 假设左边是队头，右边是队尾
    // 最近使用的排在队头，久未使用的排在队尾
    // 圆括号表示键值对 (key, val)
    
    cache.put(1, 1);
    // cache = [(1, 1)]
    
    cache.put(2, 2);
    // cache = [(2, 2), (1, 1)]
    
    cache.get(1);       // 返回 1
    // cache = [(1, 1), (2, 2)]
    // 解释：因为最近访问了键 1，所以提前至队头
    // 返回键 1 对应的值 1
    
    cache.put(3, 3);
    // cache = [(3, 3), (1, 1)]
    // 解释：缓存容量已满，需要删除内容空出位置
    // 优先删除久未使用的数据，也就是队尾的数据
    // 然后把新的数据插入队头
    
    cache.get(2);       // 返回 -1 (未找到)
    // cache = [(3, 3), (1, 1)]
    // 解释：cache 中不存在键为 2 的数据
    
    cache.put(1, 4);    
    // cache = [(1, 4), (3, 3)]
    // 解释：键 1 已存在，把原始值 1 覆盖为 4
    // 不要忘了也要将键值对提前到队头

```

### 二、LRU 算法设计

分析上面的操作过程，要让 ` put ` 和 ` get ` 方法的时间复杂度为 O(1)，我们可以总结出 ` cache ` 这个数据结构必要的条件：

1、显然 ` cache ` 中的元素必须有时序，以区分最近使用的和久未使用的数据，当容量满了之后要删除最久未使用的那个元素腾位置。

2、我们要在 ` cache ` 中快速找某个 ` key ` 是否已存在并得到对应的 ` val ` ；

3、每次访问 ` cache ` 中的某个 ` key ` ，需要将这个元素变为最近使用的，也就是说 ` cache `要支持在任意位置快速插入和删除元素。

那么，什么数据结构同时符合上述条件呢？哈希表查找快，但是数据无固定顺序；链表有顺序之分，插入删除快，但是查找慢。所以结合一下，形成一种新的数据结构：哈希链表
` LinkedHashMap ` 。

LRU 缓存算法的核心数据结构就是哈希链表，双向链表和哈希表的结合体。这个数据结构长这样：

![](https://labuladong.gitee.io/algo/images/LRU%E7%AE%97%E6%B3%95/4.jpg)

借助这个结构，我们来逐一分析上面的 3 个条件：

1、如果我们每次默认从链表尾部添加元素，那么显然越靠尾部的元素就是最近使用的，越靠头部的元素就是最久未使用的。

2、对于某一个 ` key ` ，我们可以通过哈希表快速定位到链表中的节点，从而取得对应 ` val ` 。

3、链表显然是支持在任意位置快速插入和删除的，改改指针就行。只不过传统的链表无法按照索引快速访问某一个位置的元素，而这里借助哈希表，可以通过 ` key `快速映射到任意一个链表节点，然后进行插入和删除。

**也许读者会问，为什么要是双向链表，单链表行不行？另外，既然哈希表中已经存了` key ` ，为什么链表中还要存 ` key ` 和 ` val `呢，只存 ` val ` 不就行了 ** ？

想的时候都是问题，只有做的时候才有答案。这样设计的原因，必须等我们亲自实现 LRU 算法之后才能理解，所以我们开始看代码吧～

### 三、代码实现

很多编程语言都有内置的哈希链表或者类似 LRU 功能的库函数，但是为了帮大家理解算法的细节，我们先自己造轮子实现一遍 LRU 算法，然后再使用 Java 内置的 ` LinkedHashMap ` 来实现一遍。

首先，我们把双链表的节点类写出来，为了简化， ` key ` 和 ` val ` 都认为是 int 类型：

```java
    class Node {
        public int key, val;
        public Node next, prev;
        public Node(int k, int v) {
            this.key = k;
            this.val = v;
        }
    }

```

然后依靠我们的 ` Node ` 类型构建一个双链表，实现几个 LRU 算法必须的 API：

```java
    class DoubleList {  
        // 头尾虚节点
        private Node head, tail;  
        // 链表元素数
        private int size;
        
        public DoubleList() {
            // 初始化双向链表的数据
            head = new Node(0, 0);
            tail = new Node(0, 0);
            head.next = tail;
            tail.prev = head;
            size = 0;
        }
    
        // 在链表尾部添加节点 x，时间 O(1)
        public void addLast(Node x) {
            x.prev = tail.prev;
            x.next = tail;
            tail.prev.next = x;
            tail.prev = x;
            size++;
        }
    
        // 删除链表中的 x 节点（x 一定存在）
        // 由于是双链表且给的是目标 Node 节点，时间 O(1)
        public void remove(Node x) {
            x.prev.next = x.next;
            x.next.prev = x.prev;
            size--;
        }
        
        // 删除链表中第一个节点，并返回该节点，时间 O(1)
        public Node removeFirst() {
            if (head.next == tail)
                return null;
            Node first = head.next;
            remove(first);
            return first;
        }
    
        // 返回链表长度，时间 O(1)
        public int size() { return size; }
    
    }

```

到这里就能回答刚才「为什么必须要用双向链表」的问题了，因为我们需要删除操作。删除一个节点不光要得到该节点本身的指针，也需要操作其前驱节点的指针，而双向链表才能支持直接查找前驱，保证操作的时间复杂度 O(1)。

**注意我们实现的双链表 API 只能从尾部插入，也就是说靠尾部的数据是最近使用的，靠头部的数据是最久为使用的** 。

有了双向链表的实现，我们只需要在 LRU 算法中把它和哈希表结合起来即可，先搭出代码框架：

```java
    class LRUCache {
        // key -> Node(key, val)
        private HashMap<Integer, Node> map;
        // Node(k1, v1) <-> Node(k2, v2)...
        private DoubleList cache;
        // 最大容量
        private int cap;
        
        public LRUCache(int capacity) {
            this.cap = capacity;
            map = new HashMap<>();
            cache = new DoubleList();
        }

```

先不慌去实现 LRU 算法的 ` get ` 和 ` put ` 方法。由于我们要同时维护一个双链表 ` cache ` 和一个哈希表 ` map `，很容易漏掉一些操作，比如说删除某个 ` key ` 时，在 ` cache ` 中删除了对应的 ` Node ` ，但是却忘记在 ` map ` 中删除
` key ` 。

**解决这种问题的有效方法是：在这两种数据结构之上提供一层抽象 API** 。

说的有点玄幻，实际上很简单，就是尽量让 LRU 的主方法 ` get ` 和 ` put ` 避免直接操作 ` map ` 和 ` cache `的细节。我们可以先实现下面几个函数：

```java
    /* 将某个 key 提升为最近使用的 */
    private void makeRecently(int key) {
        Node x = map.get(key);
        // 先从链表中删除这个节点
        cache.remove(x);
        // 重新插到队尾
        cache.addLast(x);
    }
    
    /* 添加最近使用的元素 */
    private void addRecently(int key, int val) {
        Node x = new Node(key, val);
        // 链表尾部就是最近使用的元素
        cache.addLast(x);
        // 别忘了在 map 中添加 key 的映射
        map.put(key, x);
    }
    
    /* 删除某一个 key */
    private void deleteKey(int key) {
        Node x = map.get(key);
        // 从链表中删除
        cache.remove(x);
        // 从 map 中删除
        map.remove(key);
    }
    
    /* 删除最久未使用的元素 */
    private void removeLeastRecently() {
        // 链表头部的第一个元素就是最久未使用的
        Node deletedNode = cache.removeFirst();
        // 同时别忘了从 map 中删除它的 key
        int deletedKey = deletedNode.key;
        map.remove(deletedKey);
    }

```

这里就能回答之前的问答题「为什么要在链表中同时存储 key 和 val，而不是只存储 val」，注意 ` removeLeastRecently `函数中，我们需要用 ` deletedNode ` 得到 ` deletedKey ` 。

也就是说，当缓存容量已满，我们不仅仅要删除最后一个 ` Node ` 节点，还要把 ` map ` 中映射到该节点的 ` key ` 同时删除，而这个 `key ` 只能由 ` Node ` 得到。如果 ` Node ` 结构中只存储 ` val ` ，那么我们就无法得知 ` key ` 是什么，就无法删除
` map ` 中的键，造成错误。

上述方法就是简单的操作封装，调用这些函数可以避免直接操作 ` cache ` 链表和 ` map ` 哈希表，下面我先来实现 LRU 算法的 ` get `方法：

```java
    public int get(int key) {
        if (!map.containsKey(key)) {
            return -1;
        }
        // 将该数据提升为最近使用的
        makeRecently(key);
        return map.get(key).val;
    }

```

` put ` 方法稍微复杂一些，我们先来画个图搞清楚它的逻辑：

![](https://labuladong.gitee.io/algo/images/LRU%e7%ae%97%e6%b3%95/put.jpg)

这样我们可以轻松写出 ` put ` 方法的代码：

```java
    public void put(int key, int val) {
        if (map.containsKey(key)) {
            // 删除旧的数据
            deleteKey(key);
            // 新插入的数据为最近使用的数据
            addRecently(key, val);
            return;
        }
        
        if (cap == cache.size()) {
            // 删除最久未使用的元素
            removeLeastRecently();
        }
        // 添加为最近使用的元素
        addRecently(key, val);
    }

```

至此，你应该已经完全掌握 LRU 算法的原理和实现了，我们最后用 Java 的内置类型 ` LinkedHashMap ` 来实现 LRU 算法，逻辑和之前完全一致，我就不过多解释了：

```java
    class LRUCache {
        int cap;
        LinkedHashMap<Integer, Integer> cache = new LinkedHashMap<>();
        public LRUCache(int capacity) { 
            this.cap = capacity;
        }
        
        public int get(int key) {
            if (!cache.containsKey(key)) {
                return -1;
            }
            // 将 key 变为最近使用
            makeRecently(key);
            return cache.get(key);
        }
        
        public void put(int key, int val) {
            if (cache.containsKey(key)) {
                // 修改 key 的值
                cache.put(key, val);
                // 将 key 变为最近使用
                makeRecently(key);
                return;
            }
            
            if (cache.size() >= this.cap) {
                // 链表头部就是最久未使用的 key
                int oldestKey = cache.keySet().iterator().next();
                cache.remove(oldestKey);
            }
            // 将新的 key 添加链表尾部
            cache.put(key, val);
        }
        
        private void makeRecently(int key) {
            int val = cache.get(key);
            // 删除 key，重新插入到队尾
            cache.remove(key);
            cache.put(key, val);
        }
    }

```

至此，LRU 算法就没有什么神秘的了。

接下来可阅读：

* [ 手把手带你实现 LFU 算法 ](https://labuladong.gitee.io/algo/2/19/44/)

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


## 算法就像搭乐高：带你手撸 LFU 算法


读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 460. LFU缓存机制（困难） ](https://leetcode-cn.com/problems/lfu-cache/)

**———–**

上篇文章 [ 带你手写LRU算法 ](https://labuladong.gitee.io/algo/2/19/43/) 写了 LRU 缓存淘汰算法的实现方法，本文来写另一个著名的缓存淘汰算法：LFU 算法。

LRU 算法的淘汰策略是 Least Recently Used，也就是每次淘汰那些最久没被使用的数据；而 LFU 算法的淘汰策略是 Least Frequently Used，也就是每次淘汰那些使用次数最少的数据。

LRU 算法的核心数据结构是使用哈希链表 ` LinkedHashMap `，首先借助链表的有序性使得链表元素维持插入顺序，同时借助哈希映射的快速访问能力使得我们可以在 O(1) 时间访问链表的任意元素。

从实现难度上来说，LFU 算法的难度大于 LRU 算法，因为 LRU
算法相当于把数据按照时间排序，这个需求借助链表很自然就能实现，你一直从链表头部加入元素的话，越靠近头部的元素就是新的数据，越靠近尾部的元素就是旧的数据，我们进行缓存淘汰的时候只要简单地将尾部的元素淘汰掉就行了。

而 LFU 算法相当于是把数据按照访问频次进行排序，这个需求恐怕没有那么简单，而且还有一种情况，如果多个数据拥有相同的访问频次，我们就得删除最早插入的那个数据。也就是说 LFU
算法是淘汰访问频次最低的数据，如果访问频次最低的数据有多条，需要淘汰最旧的数据。

所以说 LFU 算法是要复杂很多的，而且经常出现在面试中，因为 LFU 缓存淘汰算法在工程实践中经常使用，也有可能是应该 LRU 算法太简单了。
**不过话说回来，这种著名的算法的套路都是固定的，关键是由于逻辑较复杂，不容易写出漂亮且没有 bug 的代码** 。

那么本文 labuladong 就带你拆解 LFU 算法，自顶向下，逐步求精，就是解决复杂问题的不二法门。

### 一、算法描述

要求你写一个类，接受一个 ` capacity ` 参数，实现 ` get ` 和 ` put ` 方法：

```java
    class LFUCache {
        // 构造容量为 capacity 的缓存
        public LFUCache(int capacity) {}
        // 在缓存中查询 key
        public int get(int key) {}
        // 将 key 和 val 存入缓存
        public void put(int key, int val) {}
    }

```

` get(key) ` 方法会去缓存中查询键 ` key ` ，如果 ` key ` 存在，则返回 ` key ` 对应的 ` val ` ，否则返回 -1。

` put(key, value) ` 方法插入或修改缓存。如果 ` key ` 已存在，则将它对应的值改为 ` val ` ；如果 ` key `不存在，则插入键值对 ` (key, val) ` 。

当缓存达到容量 ` capacity ` 时，则应该在插入新的键值对之前，删除使用频次（后文用 ` freq ` 表示）最低的键值对。如果 ` freq `最低的键值对有多个，则删除其中最旧的那个。

```java
    // 构造一个容量为 2 的 LFU 缓存
    LFUCache cache = new LFUCache(2);
    
    // 插入两对 (key, val)，对应的 freq 为 1
    cache.put(1, 10);
    cache.put(2, 20);
    
    // 查询 key 为 1 对应的 val
    // 返回 10，同时键 1 对应的 freq 变为 2
    cache.get(1);
    
    // 容量已满，淘汰 freq 最小的键 2
    // 插入键值对 (3, 30)，对应的 freq 为 1
    cache.put(3, 30);   
    
    // 键 2 已经被淘汰删除，返回 -1
    cache.get(2);       

```

### 二、思路分析

一定先从最简单的开始，根据 LFU 算法的逻辑，我们先列举出算法执行过程中的几个显而易见的事实：

1、调用 ` get(key) ` 方法时，要返回该 ` key ` 对应的 ` val ` 。

2、只要用 ` get ` 或者 ` put ` 方法访问一次某个 ` key ` ，该 ` key ` 的 ` freq ` 就要加一。

3、如果在容量满了的时候进行插入，则需要将 ` freq ` 最小的 ` key ` 删除，如果最小的 ` freq ` 对应多个 ` key `，则删除其中最旧的那一个。

好的，我们希望能够在 O(1) 的时间内解决这些需求，可以使用基本数据结构来逐个击破：

1、使用一个 ` HashMap ` 存储 ` key ` 到 ` val ` 的映射，就可以快速计算 ` get(key) ` 。

```java
    HashMap<Integer, Integer> keyToVal;

```

2、使用一个 ` HashMap ` 存储 ` key ` 到 ` freq ` 的映射，就可以快速操作 ` key ` 对应的 ` freq ` 。

```java
    HashMap<Integer, Integer> keyToFreq;

```

3、这个需求应该是 LFU 算法的核心，所以我们分开说。

3.1、首先，肯定是需要 ` freq ` 到 ` key ` 的映射，用来找到 ` freq ` 最小的 ` key ` 。

3.2、将 ` freq ` 最小的 ` key ` 删除，那你就得快速得到当前所有 ` key ` 最小的 ` freq ` 是多少。想要时间复杂度 O(1) 的话，肯定不能遍历一遍去找，那就用一个变量 ` minFreq `来记录当前最小的 ` freq ` 吧。

3.3、可能有多个 ` key ` 拥有相同的 ` freq ` ，所以 **` freq ` 对 ` key ` 是一对多的关系 ** ，即一个 `freq ` 对应一个 ` key ` 的列表。

3.4、希望 ` freq ` 对应的 ` key ` 的列表是 **存在时序** 的，便于快速查找并删除最旧的 ` key ` 。

3.5、希望 **能够快速删除` key ` 列表中的任何一个 ` key ` ** ，因为如果频次为 ` freq ` 的某个 ` key `被访问，那么它的频次就会变成 ` freq+1 ` ，就应该从 ` freq ` 对应的 ` key ` 列表中删除，加到 ` freq+1 ` 对应的 `key ` 的列表中。

```java
    HashMap<Integer, LinkedHashSet<Integer>> freqToKeys;
    int minFreq = 0;

```

介绍一下这个 ` LinkedHashSet ` ，它满足我们 3.3，3.4，3.5 这几个要求。你会发现普通的链表 ` LinkedList `能够满足 3.3，3.4 这两个要求，但是由于普通链表不能快速访问链表中的某一个节点，所以无法满足 3.5 的要求。

` LinkedHashSet `顾名思义，是链表和哈希集合的结合体。链表不能快速访问链表节点，但是插入元素具有时序；哈希集合中的元素无序，但是可以对元素进行快速的访问和删除。

那么，它俩结合起来就兼具了哈希集合和链表的特性，既可以在 O(1) 时间内访问或删除其中的元素，又可以保持插入的时序，高效实现 3.5 这个需求。

综上，我们可以写出 LFU 算法的基本数据结构：

```java
    class LFUCache {
        // key 到 val 的映射，我们后文称为 KV 表
        HashMap<Integer, Integer> keyToVal;
        // key 到 freq 的映射，我们后文称为 KF 表
        HashMap<Integer, Integer> keyToFreq;
        // freq 到 key 列表的映射，我们后文称为 FK 表
        HashMap<Integer, LinkedHashSet<Integer>> freqToKeys;
        // 记录最小的频次
        int minFreq;
        // 记录 LFU 缓存的最大容量
        int cap;
    
        public LFUCache(int capacity) {
            keyToVal = new HashMap<>();
            keyToFreq = new HashMap<>();
            freqToKeys = new HashMap<>();
            this.cap = capacity;
            this.minFreq = 0;
        }
    
        public int get(int key) {}
    
        public void put(int key, int val) {}
    
    }

```

### 三、代码框架

LFU 的逻辑不难理解，但是写代码实现并不容易，因为你看我们要维护 ` KV ` 表， ` KF ` 表， ` FK `表三个映射，特别容易出错。对于这种情况，labuladong 教你三个技巧：

1、不要企图上来就实现算法的所有细节，而应该自顶向下，逐步求精，先写清楚主函数的逻辑框架，然后再一步步实现细节。

2、搞清楚映射关系，如果我们更新了某个 ` key ` 对应的 ` freq ` ，那么就要同步修改 ` KF ` 表和 ` FK `表，这样才不会出问题。

3、画图，画图，画图，重要的话说三遍，把逻辑比较复杂的部分用流程图画出来，然后根据图来写代码，可以极大减少出错的概率。

下面我们先来实现 ` get(key) ` 方法，逻辑很简单，返回 ` key ` 对应的 ` val ` ，然后增加 ` key ` 对应的 ` freq
` ：

**＿＿＿＿＿＿＿＿＿＿＿＿＿**

应合作方要求，本文不便在此发布，请扫码关注回复关键词「lfu」查看：

![](https://labuladong.gitee.io/algo/images/qrcode.jpg)

## 数据结构设计：最大栈


读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 895. 最大频率栈（困难） ](https://leetcode-cn.com/problems/maximum-frequency-stack/)

**———–**

我个人很喜欢设计特殊数据结构的问题，毕竟在工作中会经常用到基本数据结构，而设计类的问题就非常考验对基本数据结构的理解和运用。

力扣第 895 题要求我们实现一个特殊的数据结构「最大频率栈」，比较有意思，让我们实现下面这两个 API：

```java
    class FreqStack {
    
        // 在栈中加入一个元素 val
        public void push(int val) {}
        
        // 从栈中删除并返回出现频率最高的元素
        // 如果频率最高的元素不止一个，
        // 则返回最近添加的那个元素
        public int pop() {}
    }

```

比如下面这个例子：

```java
    FreqStack stk = new FreqStack();
    
    // 向最大频率栈中添加元素
    stk.push(2); stk.push(7); stk.push(2);
    stk.push(7); stk.push(2); stk.push(4);
    
    // 栈中元素：[2,7,2,7,2,4]
    
    stk.pop() // 返回 2
    // 因为 2 出现了三次
    
    // 栈中元素：[2,7,2,7,4]
    
    stk.pop() // 返回 7
    // 2 和 7 都出现了两次，但 7 是最近添加的
    
    // 栈中元素：[2,7,2,4]
    
    stk.pop() // 返回 2
    
    // 栈中元素：[2,7,4]
    
    stk.pop() // 返回 4
    
    // 栈中元素：[2,7]

```

**这种设计数据结构的问题，主要是要搞清楚问题的难点在哪里，然后结合各种基本数据结构的特性，高效实现题目要求的 API** 。

那么，我们仔细思考一下 ` push ` 和 ` pop ` 方法，难点如下：

1、每次 ` pop ` 时，必须要知道频率最高的元素是什么。

2、如果频率最高的元素有多个，还得知道哪个是最近 ` push ` 进来的元素是哪个。

为了实现上述难点，我们要做到以下几点：

1、肯定要有一个变量 ` maxFreq ` 记录当前栈中最高的频率是多少。

2、我们得知道一个频率 ` freq ` 对应的元素有哪些，且这些元素要有时间顺序。

3、随着 ` pop ` 的调用，每个 ` val ` 对应的频率会变化，所以还得维持一个映射记录每个 ` val ` 对应的 ` freq ` 。

综上，我们可以先实现 ` FreqStack ` 所需的数据结构：

```java
    class FreqStack {
        // 记录 FreqStack 中元素的最大频率
        int maxFreq = 0;
        // 记录 FreqStack 中每个 val 对应的出现频率，后文就称为 VF 表
        HashMap<Integer, Integer> valToFreq = new HashMap<>();
        // 记录频率 freq 对应的 val 列表，后文就称为 FV 表
        HashMap<Integer, Stack<Integer>> freqToVals = new HashMap<>();
    }

```

其实这有点类似前文 [ 手把手实现 LFU 算法 ](https://labuladong.gitee.io/algo/2/19/44/) ，注意 ` freqToVals ` 中 ` val `列表用一个栈实现，如果一个 ` freq ` 对应的元素有多个，根据栈的特点，可以首先取出最近添加的元素。

要记住在 ` push ` 和 ` pop ` 方法中同时修改 ` maxFreq ` 、 ` VF ` 表、 ` FV ` 表，否则容易出现 bug。

现在，我们可以来实现 ` push ` 方法了：

```java
    public void push(int val) {
        // 修改 VF 表：val 对应的 freq 加一
        int freq = valToFreq.getOrDefault(val, 0) + 1;
        valToFreq.put(val, freq);
        // 修改 FV 表：在 freq 对应的列表加上 val
        freqToVals.putIfAbsent(freq, new Stack<>());
        freqToVals.get(freq).push(val);
        // 更新 maxFreq
        maxFreq = Math.max(maxFreq, freq);
    }

```

` pop ` 方法的实现也非常简单：

```java
    public int pop() {
        // 修改 FV 表：pop 出一个 maxFreq 对应的元素 v
        Stack<Integer> vals = freqToVals.get(maxFreq);
        int v = vals.pop();
        // 修改 VF 表：v 对应的 freq 减一
        int freq = valToFreq.get(v) - 1;
        valToFreq.put(v, freq);
        // 更新 maxFreq
        if (vals.isEmpty()) {
            // 如果 maxFreq 对应的元素空了
            maxFreq--;
        }
        return v;
    }

```

这样，两个 API 都实现了，算法执行过程如下：

![](https://labuladong.gitee.io/algo/images/%e9%ab%98%e9%a2%91%e6%a0%88/1.gif)

嗯，这道题就解决了，Hard 难度的题目也不过如此嘛~

以往的数据结构设计文章：

* [ 手把手实现 LFU 算法 ](https://labuladong.gitee.io/algo/2/19/44/)
* [ 手把手实现 LRU 算法 ](https://labuladong.gitee.io/algo/2/19/43/)
* [ 设计朋友圈时间线功能 ](https://labuladong.gitee.io/algo/2/19/47/)
* [ 单调栈结构解决三道算法题 ](https://labuladong.gitee.io/algo/2/19/48/)
* [ 单调队列结构解决滑动窗口问题 ](https://labuladong.gitee.io/algo/2/19/49/)
* [ 一道数组去重的算法题把我整不会了 ](https://labuladong.gitee.io/algo/2/20/62/)

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


## 一道求中位数的算法题把我整不会了


读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 295. 数据流的中位数（困难） ](https://leetcode-cn.com/problems/find-median-from-data-
stream)

**———–**

如果输入一个数组，让你求中位数，这个好办，排个序，如果数组长度是奇数，最中间的一个元素就是中位数，如果数组长度是偶数，最中间两个元素的平均数作为中位数。

如果数据规模非常巨大，排序不太现实，那么也可以使用概率算法，随机抽取一部分数据，排序，求中位数，作为所有数据的中位数。

本文说的中位数算法比较困难，也比较精妙，是力扣第 295 题，要求你在数据流中计算中位数：

![](https://labuladong.gitee.io/algo/images/%e4%b8%ad%e4%bd%8d%e6%95%b0/title.png)

就是让你设计这样一个类：

```java
    class MedianFinder {
    
        // 添加一个数字
        public void addNum(int num) {}
    
        // 计算当前添加的所有数字的中位数
        public double findMedian() {}
    }

```

**其实，所有关于「流」的算法都比较难** ，比如我们旧文 [ 水塘抽样算法详解 ](https://labuladong.gitee.io/algo/4/29/119/)写过如何从数据流中等概率随机抽取一个元素，如果说你没有接触过这个问题的话，还是很难想到解法的。

这道题要求在数据流中计算平均数，我们先想一想常规思路。

### 尝试分析

一个直接的解法可以用一个数组记录所有 ` addNum ` 添加进来的数字，通过插入排序的逻辑保证数组中的元素有序，当调用 ` findMedian `方法时，可以通过数组索引直接计算中位数。

但是用数组作为底层容器的问题也很明显， ` addNum ` 搜索插入位置的时候可以用二分搜索算法，但是插入操作需要搬移数据，所以最坏时间复杂度为 O(N)。

那换链表？链表插入元素很快，但是查找插入位置的时候只能线性遍历，最坏时间复杂度还是 O(N)，而且 ` findMedian `方法也需要遍历寻找中间索引，最坏时间复杂度也是 O(N)。

那么就用平衡二叉树呗，增删查改复杂度都是 O(logN)，这样总行了吧？

比如用 Java 提供的 ` TreeSet ` 容器，底层是红黑树， ` addNum ` 直接插入， ` findMedian `可以通过当前元素的个数推出计算中位数的元素的排名。

很遗憾，依然不行，这里有两个问题。

第一， ` TreeSet ` 是一种 ` Set `，其中不存在重复元素的元素，但是我们的数据流可能输入重复数据的，而且计算中位数也是需要算上重复元素的。

第二， ` TreeSet ` 并没有实现一个通过排名快速计算元素的 API。假设我想找到 ` TreeSet ` 中第 5 大的元素，并没有一个现成可用的方法实现这个需求。

> PS：如果让你实现一个在二叉搜索树中通过排名计算对应元素的方法 ` rank(int index) `> ，你会怎么设计？你可以思考一下，我会把答案写在留言区置顶。

除了平衡二叉树，还有没有什么常用的数据结构是动态有序的？优先级队列（二叉堆）行不行？

好像也不太行，因为优先级队列是一种受限的数据结构，只能从堆顶添加/删除元素，我们的 ` addNum ` 方法可以从堆顶插入元素，但是 `findMedian ` 函数需要从数据中间取，这个功能优先级队列是没办法提供的。

可以看到，求个中位数还是挺难的，我们使尽浑身解数都没有一个高效地思路，下面直接来看解法吧，比较巧妙。

### 解法思路

**我们必然需要有序数据结构，本题的核心思路是使用两个优先级队列** 。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**

应合作方要求，本文不便在此发布，请扫码关注回复关键词「中位数」查看：

![](https://labuladong.gitee.io/algo/images/qrcode.jpg)

## 设计朋友圈时间线功能


读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 355. 设计推特（中等） ](https://leetcode-cn.com/problems/design-twitter)

**———–**

「design Twitter」是 LeetCode 上第 355 道题目，不仅题目本身很有意思，而且把合并多个有序链表的算法和面向对象设计（OO design）结合起来了，很有实际意义，本文就带大家来看看这道题。

至于 Twitter 的什么功能跟算法有关系，等我们描述一下题目要求就知道了。

### 一、题目及应用场景简介

Twitter 和微博功能差不多，我们主要要实现这样几个 API：

```java
    class Twitter {
    
        /** user 发表一条 tweet 动态 */
        public void postTweet(int userId, int tweetId) {}
        
        /** 返回该 user 关注的人（包括他自己）最近的动态 id，
        最多 10 条，而且这些动态必须按从新到旧的时间线顺序排列。*/
        public List<Integer> getNewsFeed(int userId) {}
        
        /** follower 关注 followee，如果 Id 不存在则新建 */
        public void follow(int followerId, int followeeId) {}
        
        /** follower 取关 followee，如果 Id 不存在则什么都不做 */
        public void unfollow(int followerId, int followeeId) {}
    }

```

举个具体的例子，方便大家理解 API 的具体用法：

```java
    Twitter twitter = new Twitter();
    
    twitter.postTweet(1, 5);
    // 用户 1 发送了一条新推文 5
    
    twitter.getNewsFeed(1);
    // return [5]，因为自己是关注自己的
    
    twitter.follow(1, 2);
    // 用户 1 关注了用户 2
    
    twitter.postTweet(2, 6);
    // 用户2发送了一个新推文 (id = 6)
    
    twitter.getNewsFeed(1);
    // return [6, 5]
    // 解释：用户 1 关注了自己和用户 2，所以返回他们的最近推文
    // 而且 6 必须在 5 之前，因为 6 是最近发送的
    
    twitter.unfollow(1, 2);
    // 用户 1 取消关注了用户 2
    
    twitter.getNewsFeed(1);
    // return [5]

```

这个场景在我们的现实生活中非常常见。拿朋友圈举例，比如我刚加到女神的微信，然后我去刷新一下我的朋友圈动态，那么女神的动态就会出现在我的动态列表，而且会和其他动态按时间排好序。只不过 Twitter
是单向关注，微信好友相当于双向关注。除非，被屏蔽…

这几个 API 中大部分都很好实现，最核心的功能难点应该是 ` getNewsFeed `，因为返回的结果必须在时间上有序，但问题是用户的关注是动态变化的，怎么办？

**这里就涉及到算法了** ：如果我们把每个用户各自的推文存储在链表里，每个链表节点存储文章 id 和一个时间戳 time（记录发帖时间以便比较），而且这个链表是按 time 有序的，那么如果某个用户关注了 k 个用户，我们就可以用合并 k
个有序链表的算法合并出有序的推文列表，正确地 ` getNewsFeed ` 了！

具体的算法等会讲解。不过，就算我们掌握了算法，应该如何编程表示用户 user 和推文动态 tweet 才能把算法流畅地用出来呢？
**这就涉及简单的面向对象设计了** ，下面我们来由浅入深，一步一步进行设计。

### 二、面向对象设计

根据刚才的分析，我们需要一个 User 类，储存 user 信息，还需要一个 Tweet 类，储存推文信息，并且要作为链表的节点。所以我们先搭建一下整体的框架：

```java
    class Twitter {
        private static int timestamp = 0;
        private static class Tweet {}
        private static class User {}
    
        /* 还有那几个 API 方法 */
        public void postTweet(int userId, int tweetId) {}
        public List<Integer> getNewsFeed(int userId) {}
        public void follow(int followerId, int followeeId) {}
        public void unfollow(int followerId, int followeeId) {}
    }

```

之所以要把 Tweet 和 User 类放到 Twitter 类里面，是因为 Tweet 类必须要用到一个全局时间戳 timestamp，而 User 类又需要用到 Tweet
类记录用户发送的推文，所以它们都作为内部类。不过为了清晰和简洁，下文会把每个内部类和 API 方法单独拿出来实现。

**1、Tweet 类的实现**

根据前面的分析，Tweet 类很容易实现：每个 Tweet 实例需要记录自己的 tweetId 和发表时间 time，而且作为链表节点，要有一个指向下一个节点的 next 指针。

```java
    class Tweet {
        private int id;
        private int time;
        private Tweet next;
    
        // 需要传入推文内容（id）和发文时间
        public Tweet(int id, int time) {
            this.id = id;
            this.time = time;
            this.next = null;
        }
    }

```

![](https://labuladong.gitee.io/algo/images/%e8%ae%be%e8%ae%a1Twitter/tweet.jpg)

**2、User 类的实现**

我们根据实际场景想一想，一个用户需要存储的信息有 userId，关注列表，以及该用户发过的推文列表。其中关注列表应该用集合（Hash
Set）这种数据结构来存，因为不能重复，而且需要快速查找；推文列表应该由链表这种数据结构储存，以便于进行有序合并的操作。画个图理解一下：

![](https://labuladong.gitee.io/algo/images/%e8%ae%be%e8%ae%a1Twitter/user.jpg)

除此之外，根据面向对象的设计原则，「关注」「取关」和「发文」应该是 User 的行为，况且关注列表和推文列表也存储在 User 类中，所以我们也应该给 User 添加 follow，unfollow 和 post 这几个方法：

```java
    // static int timestamp = 0
    class User {
        private int id;
        public Set<Integer> followed;
        // 用户发表的推文链表头结点
        public Tweet head;
    
        public User(int userId) {
            followed = new HashSet<>();
            this.id = userId;
            this.head = null;
            // 关注一下自己
            follow(id);
        }
    
        public void follow(int userId) {
            followed.add(userId);
        }
    
        public void unfollow(int userId) {
            // 不可以取关自己
            if (userId != this.id)
                followed.remove(userId);
        }
    
        public void post(int tweetId) {
            Tweet twt = new Tweet(tweetId, timestamp);
            timestamp++;
            // 将新建的推文插入链表头
            // 越靠前的推文 time 值越大
            twt.next = head;
            head = twt;
        }
    }

```

**3、几个 API 方法的实现**

```java
    class Twitter {
        private static int timestamp = 0;
        private static class Tweet {...}
        private static class User {...}
    
        // 我们需要一个映射将 userId 和 User 对象对应起来
        private HashMap<Integer, User> userMap = new HashMap<>();
    
        /** user 发表一条 tweet 动态 */
        public void postTweet(int userId, int tweetId) {
            // 若 userId 不存在，则新建
            if (!userMap.containsKey(userId))
                userMap.put(userId, new User(userId));
            User u = userMap.get(userId);
            u.post(tweetId);
        }
        
        /** follower 关注 followee */
        public void follow(int followerId, int followeeId) {
            // 若 follower 不存在，则新建
    		if(!userMap.containsKey(followerId)){
    			User u = new User(followerId);
    			userMap.put(followerId, u);
    		}
            // 若 followee 不存在，则新建
    		if(!userMap.containsKey(followeeId)){
    			User u = new User(followeeId);
    			userMap.put(followeeId, u);
    		}
    		userMap.get(followerId).follow(followeeId);
        }
        
        /** follower 取关 followee，如果 Id 不存在则什么都不做 */
        public void unfollow(int followerId, int followeeId) {
            if (userMap.containsKey(followerId)) {
                User flwer = userMap.get(followerId);
                flwer.unfollow(followeeId);
            }
        }
    
        /** 返回该 user 关注的人（包括他自己）最近的动态 id，
        最多 10 条，而且这些动态必须按从新到旧的时间线顺序排列。*/
        public List<Integer> getNewsFeed(int userId) {
            // 需要理解算法，见下文
        }
    }

```

### 三、算法设计

实现合并 k 个有序链表的算法需要用到优先级队列（Priority
Queue），这种数据结构是「二叉堆」最重要的应用，你可以理解为它可以对插入的元素自动排序。乱序的元素插入其中就被放到了正确的位置，可以按照从小到大（或从大到小）有序地取出元素。

```java
    PriorityQueue pq
    ## 乱序插入
    for i in {2,4,1,9,6}:
        pq.add(i)
    while pq not empty:
        ## 每次取出第一个（最小）元素
        print(pq.pop())
    
    ## 输出有序：1,2,4,6,9

```

借助这种牛逼的数据结构支持，我们就很容易实现这个核心功能了。注意我们把优先级队列设为按 time 属性 **从大到小降序排列** ，因为 time 越大意味着时间越近，应该排在前面：

```java
    public List<Integer> getNewsFeed(int userId) {
        List<Integer> res = new ArrayList<>();
        if (!userMap.containsKey(userId)) return res;
        // 关注列表的用户 Id
        Set<Integer> users = userMap.get(userId).followed;
        // 自动通过 time 属性从大到小排序，容量为 users 的大小
        PriorityQueue<Tweet> pq = 
            new PriorityQueue<>(users.size(), (a, b)->(b.time - a.time));
    
        // 先将所有链表头节点插入优先级队列
        for (int id : users) {
            Tweet twt = userMap.get(id).head;
            if (twt == null) continue;
            pq.add(twt);
        }
    
        while (!pq.isEmpty()) {
            // 最多返回 10 条就够了
            if (res.size() == 10) break;
            // 弹出 time 值最大的（最近发表的）
            Tweet twt = pq.poll();
            res.add(twt.id);
            // 将下一篇 Tweet 插入进行排序
            if (twt.next != null) 
                pq.add(twt.next);
        }
        return res;
    }

```

这个过程是这样的，下面是我制作的一个 GIF 图描述合并链表的过程。假设有三个 Tweet 链表按 time 属性降序排列，我们把他们降序合并添加到 res 中。注意图中链表节点中的数字是 time 属性，不是 id 属性：

![](https://labuladong.gitee.io/algo/images/%e8%ae%be%e8%ae%a1Twitter/merge.gif)

至此，这道一个极其简化的 Twitter 时间线功能就设计完毕了。

### 四、最后总结

本文运用简单的面向对象技巧和合并 k 个有序链表的算法设计了一套简化的时间线功能，这个功能其实广泛地运用在许多社交应用中。

我们先合理地设计出 User 和 Tweet 两个类，然后基于这个设计之上运用算法解决了最重要的一个功能。可见实际应用中的算法并不是孤立存在的，需要和其他知识混合运用，才能发挥实际价值。

当然，实际应用中的社交 App 数据量是巨大的，考虑到数据库的读写性能，我们的设计可能承受不住流量压力，还是有些太简化了。而且实际的应用都是一个极其庞大的工程，比如下图，是 Twitter 这样的社交网站大致的系统结构：

![](https://labuladong.gitee.io/algo/images/%e8%ae%be%e8%ae%a1Twitter/design.png)

我们解决的问题应该只能算 Timeline Service 模块的一小部分，功能越多，系统的复杂性可能是指数级增长的。所以说合理的顶层设计十分重要，其作用是远超某一个算法的。

最后，Github 上有一个优秀的开源项目，专门收集了很多大型系统设计的案例和解析，而且有中文版本，上面这个图也出自该项目。对系统设计感兴趣的读者可以点击
[ 这里 ](https://github.com/donnemartin/system-design-primer) 查看。

> PS：本文前两张图片和 GIF 是我第一次尝试用平板的绘图软件制作的，花了很多时间，尤其是 GIF
> 图，需要一帧一帧制作。如果本文内容对你有帮助，点个赞分个享，鼓励一下我呗！

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


## 单调栈结构解决三道算法题


读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 496. 下一个更大元素I（简单） ](https://leetcode-cn.com/problems/next-greater-element-i)

[ 503. 下一个更大元素II（中等） ](https://leetcode-cn.com/problems/next-greater-element-
ii)

[ 739. 每日温度（中等） ](https://leetcode-cn.com/problems/daily-temperatures/)

**———–**

栈（stack）是很简单的一种数据结构，先进后出的逻辑顺序，符合某些问题的特点，比如说函数调用栈。

单调栈实际上就是栈，只是利用了一些巧妙的逻辑，使得每次新元素入栈后，栈内的元素都保持有序（单调递增或单调递减）。

听起来有点像堆（heap）？不是的，单调栈用途不太广泛，只处理一种典型的问题，叫做 Next Greater Element。本文用讲解单调队列的算法模版解决这类问题，并且探讨处理「循环数组」的策略。

### 单调栈模板

现在给你出这么一道题：

给你一个数组 ` nums ` ，请你返回一个等长的结果数组，结果数组中对应索引存储着下一个更大元素，如果没有更大的元素，就存 -1。

函数签名如下：

```java
    vector<int> nextGreaterElement(vector<int>& nums);

```

比如说，输入一个数组 ` nums = [2,1,2,4,3] ` ，你返回数组 ` [4,2,4,-1,-1] ` 。

解释：第一个 2 后面比 2 大的数是 4; 1 后面比 1 大的数是 2；第二个 2 后面比 2 大的数是 4; 4 后面没有比 4 大的数，填 -1；3 后面没有比 3 大的数，填 -1。

这道题的暴力解法很好想到，就是对每个元素后面都进行扫描，找到第一个更大的元素就行了。但是暴力解法的时间复杂度是 ` O(n^2) ` 。

这个问题可以这样抽象思考：把数组的元素想象成并列站立的人，元素大小想象成人的身高。这些人面对你站成一列，如何求元素「2」的 Next Greater Number 呢？

很简单，如果能够看到元素「2」，那么他后面可见的第一个人就是「2」的 Next Greater Number，因为比「2」小的元素身高不够，都被「2」挡住了，第一个露出来的就是答案。

![](https://labuladong.gitee.io/algo/images/%E5%8D%95%E8%B0%83%E6%A0%88/1.jpeg)

这个情景很好理解吧？带着这个抽象的情景，先来看下代码。

```java
    vector<int> nextGreaterElement(vector<int>& nums) {
        vector<int> res(nums.size()); // 存放答案的数组
        stack<int> s;
        // 倒着往栈里放
        for (int i = nums.size() - 1; i >= 0; i--) {
            // 判定个子高矮
            while (!s.empty() && s.top() <= nums[i]) {
                // 矮个起开，反正也被挡着了。。。
                s.pop();
            }
            // nums[i] 身后的 next great number
            res[i] = s.empty() ? -1 : s.top();
            s.push(nums[i]);
        }
        return res;
    }

```

这就是单调队列解决问题的模板。for 循环要从后往前扫描元素，因为我们借助的是栈的结构，倒着入栈，其实是正着出栈。while
循环是把两个「个子高」元素之间的元素排除，因为他们的存在没有意义，前面挡着个「更高」的元素，所以他们不可能被作为后续进来的元素的 Next Great Number 了。

这个算法的时间复杂度不是那么直观，如果你看到 for 循环嵌套 while 循环，可能认为这个算法的复杂度也是 ` O(n^2) `，但是实际上这个算法的复杂度只有 ` O(n) ` 。

分析它的时间复杂度，要从整体来看：总共有 ` n ` 个元素，每个元素都被 ` push ` 入栈了一次，而最多会被 ` pop `一次，没有任何冗余操作。所以总的计算规模是和元素规模 ` n ` 成正比的，也就是 ` O(n) ` 的复杂度。

### 问题变形

单调栈的使用技巧差不多了，来一个简单的变形，力扣第 739 题「每日温度」：

给你一个数组 ` T ` ，这个数组存放的是近几天的天气气温，你返回一个等长的数组，计算：
**对于每一天，你还要至少等多少天才能等到一个更暖和的气温；如果等不到那一天，填 0** 。

函数签名如下：

```java
    vector<int> dailyTemperatures(vector<int>& T);

```

比如说给你输入 ` T = [73,74,75,71,69,76] ` ，你返回 ` [1,1,3,2,1,0] ` 。

解释：第一天 73 华氏度，第二天 74 华氏度，比 73 大，所以对于第一天，只要等一天就能等到一个更暖和的气温，后面的同理。

这个问题本质上也是找 Next Greater Number，只不过现在不是问你 Next Greater Number 是多少，而是问你当前距离 Next Greater Number 的距离而已。

相同的思路，直接调用单调栈的算法模板，稍作改动就可以，直接上代码吧：

```java
    vector<int> dailyTemperatures(vector<int>& T) {
        vector<int> res(T.size());
        // 这里放元素索引，而不是元素
        stack<int> s; 
        /* 单调栈模板 */
        for (int i = T.size() - 1; i >= 0; i--) {
            while (!s.empty() && T[s.top()] <= T[i]) {
                s.pop();
            }
            // 得到索引间距
            res[i] = s.empty() ? 0 : (s.top() - i); 
            // 将索引入栈，而不是元素
            s.push(i); 
        }
        return res;
    }

```

单调栈讲解完毕，下面开始另一个重点：如何处理「循环数组」。

### 如何处理环形数组

同样是 Next Greater Number，现在假设给你的数组是个环形的，如何处理？力扣第 503 题「下一个更大元素 II」就是这个问题：

比如输入一个数组 ` [2,1,2,4,3] ` ，你返回数组 ` [4,2,4,-1,4] ` 。拥有了环形属性， **最后一个元素 3 绕了一圈后找到了比自己大的元素 4** 。

一般是通过 % 运算符求模（余数），来获得环形特效：

```java
    int[] arr = {1,2,3,4,5};
    int n = arr.length, index = 0;
    while (true) {
        print(arr[index % n]);
        index++;
    }

```

这个问题肯定还是要用单调栈的解题模板，但难点在于，比如输入是 ` [2,1,2,4,3] ` ，对于最后一个元素 3，如何找到元素 4 作为 Next Greater Number。

**对于这种需求，常用套路就是将数组长度翻倍** ：

![](https://labuladong.gitee.io/algo/images/%E5%8D%95%E8%B0%83%E6%A0%88/2.jpeg)

这样，元素 3 就可以找到元素 4 作为 Next Greater Number 了，而且其他的元素都可以被正确地计算。

有了思路，最简单的实现方式当然可以把这个双倍长度的数组构造出来，然后套用算法模板。但是，
**我们可以不用构造新数组，而是利用循环数组的技巧来模拟数组长度翻倍的效果** 。

直接看代码吧：

```java
    vector<int> nextGreaterElements(vector<int>& nums) {
        int n = nums.size();
        vector<int> res(n);
        stack<int> s;
        // 假装这个数组长度翻倍了
        for (int i = 2 * n - 1; i >= 0; i--) {
            // 索引要求模，其他的和模板一样
            while (!s.empty() && s.top() <= nums[i % n])
                s.pop();
            res[i % n] = s.empty() ? -1 : s.top();
            s.push(nums[i % n]);
        }
        return res;
    }

```

这样，就可以巧妙解决环形数组的问题，时间复杂度 ` O(N) ` 。

接下来可阅读：

* [ 特殊数据结构之单调队列 ](https://labuladong.gitee.io/algo/2/19/49/)

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


## 单调队列结构解决滑动窗口问题


读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 239. 滑动窗口最大值（困难） ](https://leetcode-cn.com/problems/sliding-window-maximum)

**———–**

前文用 [ 单调栈解决三道算法问题 ](https://labuladong.gitee.io/algo/2/19/48/) 介绍了单调栈这种特殊数据结构，本文写一个类似的数据结构「单调队列」。

也许这种数据结构的名字你没听过，其实没啥难的，就是一个「队列」，只是使用了一点巧妙的方法，使得 **队列中的元素全都是单调递增（或递减）的** 。

「单调栈」主要解决 Next Great Number 一类算法问题，而「单调队列」这个数据结构可以解决滑动窗口相关的问题，比如说力扣第 239 题「滑动窗口最大值」，难度 Hard：

给你输入一个数组 ` nums ` 和一个正整数 ` k ` ，有一个大小为 ` k ` 的窗口在 ` nums ` 上从左至右滑动，请你输出每次窗口中 `k ` 个元素的最大值。

函数签名如下：

```java
    int[] maxSlidingWindow(int[] nums, int k);

```

比如说力扣给出的一个示例：

![](https://labuladong.gitee.io/algo/images/%e5%8d%95%e8%b0%83%e9%98%9f%e5%88%97/window.png)

### 一、搭建解题框架

这道题不复杂，难点在于如何在 ` O(1) `时间算出每个「窗口」中的最大值，使得整个算法在线性时间完成。这种问题的一个特殊点在于，「窗口」是不断滑动的，也就是你得 **动态地** 计算窗口中的最大值。

对于这种动态的场景，很容易得到一个结论：

**在一堆数字中，已知最值为` A ` ，如果给这堆数添加一个数 ` B ` ，那么比较一下 ` A ` 和 ` B `就可以立即算出新的最值；但如果减少一个数，就不能直接得到最值了，因为如果减少的这个数恰好是 ` A ` ，就需要遍历所有数重新找新的最值 ** 。

回到这道题的场景，每个窗口前进的时候，要添加一个数同时减少一个数，所以想在 O(1)的时间得出新的最值，不是那么容易的，需要「单调队列」这种特殊的数据结构来辅助。

一个普通的队列一定有这两个操作：

```java
    class Queue {
        // enqueue 操作，在队尾加入元素 n
        void push(int n);
        // dequeue 操作，删除队头元素
        void pop();
    }

```

一个「单调队列」的操作也差不多：

```java
    class MonotonicQueue {
        // 在队尾添加元素 n
        void push(int n);
        // 返回当前队列中的最大值
        int max();
        // 队头元素如果是 n，删除它
        void pop(int n);
    }

```

当然，这几个 API 的实现方法肯定跟一般的 Queue 不一样，不过我们暂且不管，而且认为这几个操作的时间复杂度都是 O(1)，先把这道「滑动窗口」问题的解答框架搭出来：

```java
    int[] maxSlidingWindow(int[] nums, int k) {
        MonotonicQueue window = new MonotonicQueue();
        List<Integer> res = new ArrayList<>();
        
        for (int i = 0; i < nums.length; i++) {
            if (i < k - 1) {
                //先把窗口的前 k - 1 填满
                window.push(nums[i]);
            } else {
                // 窗口开始向前滑动
                // 移入新元素
                window.push(nums[i]);
                // 将当前窗口中的最大元素记入结果
                res.add(window.max());
                // 移出最后的元素
                window.pop(nums[i - k + 1]);
            }
        }
        // 将 List 类型转化成 int[] 数组作为返回值
        int[] arr = new int[res.size()];
        for (int i = 0; i < res.size(); i++) {
            arr[i] = res.get(i);
        }
        return arr;
    }

```

![](https://labuladong.gitee.io/algo/images/%e5%8d%95%e8%b0%83%e9%98%9f%e5%88%97/1.png)

这个思路很简单，能理解吧？下面我们开始重头戏，单调队列的实现。

### 二、实现单调队列数据结构

观察滑动窗口的过程就能发现，实现「单调队列」必须使用一种数据结构支持在头部和尾部进行插入和删除，很明显双链表是满足这个条件的。

「单调队列」的核心思路和「单调栈」类似， ` push ` 方法依然在队尾添加元素，但是要把前面比自己小的元素都删掉：

```java
    class MonotonicQueue {
    // 双链表，支持头部和尾部增删元素
    private LinkedList<Integer> q = new LinkedList<>();
    
    public void push(int n) {
        // 将前面小于自己的元素都删除
        while (!q.isEmpty() && q.getLast() < n) {
            q.pollLast();
        }
        q.addLast(n);
    }

```

你可以想象，加入数字的大小代表人的体重，把前面体重不足的都压扁了，直到遇到更大的量级才停住。

![](https://labuladong.gitee.io/algo/images/%e5%8d%95%e8%b0%83%e9%98%9f%e5%88%97/3.png)

如果每个元素被加入时都这样操作，最终单调队列中的元素大小就会保持一个 **单调递减** 的顺序，因此我们的 ` max ` 方法可以可以这样写：

```java
    public int max() {
        // 队头的元素肯定是最大的
        return q.getFirst();
    }

```

` pop ` 方法在队头删除元素 ` n ` ，也很好写：

```java
    public void pop(int n) {
        if (n == q.getFirst()) {
            q.pollFirst();
        }
    }

```

之所以要判断 ` data.front() == n ` ，是因为我们想删除的队头元素 ` n `可能已经被「压扁」了，可能已经不存在了，所以这时候就不用删除了：

![](https://labuladong.gitee.io/algo/images/%e5%8d%95%e8%b0%83%e9%98%9f%e5%88%97/2.png)

至此，单调队列设计完毕，看下完整的解题代码：

```java
    /* 单调队列的实现 */
    class MonotonicQueue {
        LinkedList<Integer> q = new LinkedList<>();
        public void push(int n) {
            // 将小于 n 的元素全部删除
            while (!q.isEmpty() && q.getLast() < n) {
                q.pollLast();
            }
            // 然后将 n 加入尾部
            q.addLast(n);
        }
        
        public int max() {
            return q.getFirst();
        }
        
        public void pop(int n) {
            if (n == q.getFirst()) {
                q.pollFirst();
            }
        }
    }
    
    /* 解题函数的实现 */
    int[] maxSlidingWindow(int[] nums, int k) {
        MonotonicQueue window = new MonotonicQueue();
        List<Integer> res = new ArrayList<>();
        
        for (int i = 0; i < nums.length; i++) {
            if (i < k - 1) {
                //先填满窗口的前 k - 1
                window.push(nums[i]);
            } else {
                // 窗口向前滑动，加入新数字
                window.push(nums[i]);
                // 记录当前窗口的最大值
                res.add(window.max());
                // 移出旧数字
                window.pop(nums[i - k + 1]);
            }
        }
        // 需要转成 int[] 数组再返回
        int[] arr = new int[res.size()];
        for (int i = 0; i < res.size(); i++) {
            arr[i] = res.get(i);
        }
        return arr;
    }

```

有一点细节问题不要忽略，在实现 ` MonotonicQueue ` 时，我们使用了 Java 的 ` LinkedList `，因为链表结构支持在头部和尾部快速增删元素；而在解法代码中的 ` res ` 则使用的 ` ArrayList `结构，因为后续会按照索引取元素，所以数组结构更合适。

### 三、算法复杂度分析

读者可能疑惑， ` push ` 操作中含有 while 循环，时间复杂度应该不是 ` O(1) ` 呀，那么本算法的时间复杂度应该不是线性时间吧？

单独看 ` push ` 操作的复杂度确实不是 ` O(1) ` ，但是算法整体的复杂度依然是 ` O(N) ` 线性时间。要这样想， ` nums `中的每个元素最多被 ` push ` 和 ` pop ` 一次，没有任何多余操作，所以整体的复杂度还是 ` O(N) ` 。

空间复杂度就很简单了，就是窗口的大小 ` O(k) ` 。

其实我觉得，这种特殊数据结构的设计还是蛮有意思的，你学会单调队列的使用了吗？学会了给个三连？

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


## 二叉堆详解实现优先级队列


**———–**

二叉堆（Binary Heap）没什么神秘，性质比二叉搜索树 BST 还简单。其主要操作就两个， ` sink ` （下沉）和 ` swim `（上浮），用以维护二叉堆的性质。其主要应用有两个，首先是一种排序方法「堆排序」，第二是一种很有用的数据结构「优先级队列」。

本文就以实现优先级队列（Priority Queue）为例，来讲讲一下二叉堆怎么运作的。

### 一、二叉堆概览

首先，二叉堆和二叉树有啥关系呢，为什么人们总是把二叉堆画成一棵二叉树？

因为，二叉堆在逻辑上其实是一种特殊的二叉树（完全二叉树），只不过存储在数组里。一般的链表二叉树，我们操作节点的指针，而在数组里，我们把数组索引作为指针：

```java
    // 父节点的索引
    int parent(int root) {
        return root / 2;
    }
    // 左孩子的索引
    int left(int root) {
        return root * 2;
    }
    // 右孩子的索引
    int right(int root) {
        return root * 2 + 1;
    }

```

画个图你立即就能理解了，比如 ` arr ` 是一个字符数组，注意数组的第一个索引 0 空着不用：

![](https://labuladong.gitee.io/algo/images/heap/1.png)

你看到了，因为这棵二叉树是「完全二叉树」，所以把 ` arr[1] `作为整棵树的根的话，每个节点的父节点和左右孩子的索引都可以通过简单的运算得到，这就是二叉堆设计的一个巧妙之处。

为了方便讲解，下面都会画的图都是二叉树结构，相信你能把树和数组对应起来。

二叉堆还分为最大堆和最小堆。 **最大堆的性质是：每个节点都大于等于它的两个子节点** 。类似的，最小堆的性质是：每个节点都小于等于它的子节点。

两种堆核心思路都是一样的，本文以最大堆为例讲解。

对于一个最大堆，根据其性质，显然堆顶，也就是 ` arr[1] ` 一定是所有元素中最大的元素。

### 二、优先级队列概览

优先级队列这种数据结构有一个很有用的功能，你插入或者删除元素的时候，元素会自动排序，这底层的原理就是二叉堆的操作。

数据结构的功能无非增删查该，优先级队列有两个主要 API，分别是 ` insert ` 插入一个元素和 ` delMax `删除最大元素（如果底层用最小堆，那么就是 ` delMin ` ）。

下面我们实现一个简化的优先级队列，先看下代码框架：

> PS：这里用到 Java 的泛型， ` Key ` 可以是任何一种可比较大小的数据类型，比如 Integer 等类型。

```java
    public class MaxPQ
        <Key extends Comparable<Key>> {
        // 存储元素的数组
        private Key[] pq;
        // 当前 Priority Queue 中的元素个数
        private int N = 0;
    
        public MaxPQ(int cap) {
            // 索引 0 不用，所以多分配一个空间
            pq = (Key[]) new Comparable[cap + 1];
        }
    
        /* 返回当前队列中最大元素 */
        public Key max() {
            return pq[1];
        }
    
        /* 插入元素 e */
        public void insert(Key e) {...}
    
        /* 删除并返回当前队列中最大元素 */
        public Key delMax() {...}
    
        /* 上浮第 k 个元素，以维护最大堆性质 */
        private void swim(int k) {...}
    
        /* 下沉第 k 个元素，以维护最大堆性质 */
        private void sink(int k) {...}
    
        /* 交换数组的两个元素 */
        private void exch(int i, int j) {
            Key temp = pq[i];
            pq[i] = pq[j];
            pq[j] = temp;
        }
    
        /* pq[i] 是否比 pq[j] 小？ */
        private boolean less(int i, int j) {
            return pq[i].compareTo(pq[j]) < 0;
        }
    
        /* 还有 left, right, parent 三个方法 */
    }

```

空出来的四个方法是二叉堆和优先级队列的奥妙所在，下面用图文来逐个理解。

### 三、实现 swim 和 sink

为什么要有上浮 ` swim ` 和下沉 ` sink ` 的操作呢？为了维护堆结构。

我们要讲的是最大堆，每个节点都比它的两个子节点大，但是在插入元素和删除元素时，难免破坏堆的性质，这就需要通过这两个操作来恢复堆的性质了。

对于最大堆，会破坏堆性质的有两种情况：

1. 如果某个节点 A 比它的子节点（中的一个）小，那么 A 就不配做父节点，应该下去，下面那个更大的节点上来做父节点，这就是对 A 进行 **下沉** 。

2. 如果某个节点 A 比它的父节点大，那么 A 不应该做子节点，应该把父节点换下来，自己去做父节点，这就是对 A 的 **上浮** 。

当然，错位的节点 A 可能要上浮（或下沉）很多次，才能到达正确的位置，恢复堆的性质。所以代码中肯定有一个 ` while ` 循环。

细心的读者也许会问，这两个操作不是互逆吗，所以上浮的操作一定能用下沉来完成，为什么我还要费劲写两个方法？

是的，操作是互逆等价的，但是最终我们的操作只会在堆底和堆顶进行（等会讲原因），显然堆底的「错位」元素需要上浮，堆顶的「错位」元素需要下沉。

**上浮的代码实现：**

```java
    private void swim(int k) {
        // 如果浮到堆顶，就不能再上浮了
        while (k > 1 && less(parent(k), k)) {
            // 如果第 k 个元素比上层大
            // 将 k 换上去
            exch(parent(k), k);
            k = parent(k);
        }
    }

```

画个 GIF 看一眼就明白了：

![](https://labuladong.gitee.io/algo/images/heap/swim.gif)

**下沉的代码实现：**

下沉比上浮略微复杂一点，因为上浮某个节点 A，只需要 A 和其父节点比较大小即可；但是下沉某个节点 A，需要 A 和其 **两个子节点** 比较大小，如果 A 不是最大的就需要调整位置，要把较大的那个子节点和 A 交换。

```java
    private void sink(int k) {
        // 如果沉到堆底，就沉不下去了
        while (left(k) <= N) {
            // 先假设左边节点较大
            int older = left(k);
            // 如果右边节点存在，比一下大小
            if (right(k) <= N && less(older, right(k)))
                older = right(k);
            // 结点 k 比俩孩子都大，就不必下沉了
            if (less(older, k)) break;
            // 否则，不符合最大堆的结构，下沉 k 结点
            exch(k, older);
            k = older;
        }
    }

```

画个 GIF 看下就明白了：

![](https://labuladong.gitee.io/algo/images/heap/sink.gif)

至此，二叉堆的主要操作就讲完了，一点都不难吧，代码加起来也就十行。明白了 ` sink ` 和 ` swim ` 的行为，下面就可以实现优先级队列了。

### 四、实现 delMax 和 insert

这两个方法就是建立在 ` swim ` 和 ` sink ` 上的。

**` insert ` 方法先把要插入的元素添加到堆底的最后，然后让其上浮到正确位置 ** 。

![](https://labuladong.gitee.io/algo/images/heap/insert.gif)

```java
    public void insert(Key e) {
        N++;
        // 先把新元素加到最后
        pq[N] = e;
        // 然后让它上浮到正确的位置
        swim(N);
    }

```

**` delMax ` 方法先把堆顶元素 ` A ` 和堆底最后的元素 ` B ` 对调，然后删除 ` A ` ，最后让 ` B ` 下沉到正确位置 **。

```java
    public Key delMax() {
        // 最大堆的堆顶就是最大元素
        Key max = pq[1];
        // 把这个最大元素换到最后，删除之
        exch(1, N);
        pq[N] = null;
        N--;
        // 让 pq[1] 下沉到正确位置
        sink(1);
        return max;
    }

```

![](https://labuladong.gitee.io/algo/images/heap/delete.gif)

至此，一个优先级队列就实现了，插入和删除元素的时间复杂度为 ` O(logK) ` ， ` K `为当前二叉堆（优先级队列）中的元素总数。因为我们时间复杂度主要花费在 ` sink ` 或者 ` swim `上，而不管上浮还是下沉，最多也就树（堆）的高度，也就是 log 级别。

### 五、最后总结

二叉堆就是一种完全二叉树，所以适合存储在数组中，而且二叉堆拥有一些特殊性质。

二叉堆的操作很简单，主要就是上浮和下沉，来维护堆的性质（堆有序），核心代码也就十行。

优先级队列是基于二叉堆实现的，主要操作是插入和删除。插入是先插到最后，然后上浮到正确位置；删除是调换位置后再删除，然后下沉到正确位置。核心代码也就十行。

也许这就是数据结构的威力，简单的操作就能实现巧妙的功能，真心佩服发明二叉堆算法的人！

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


## 队列实现栈以及栈实现队列


读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 232. 用栈实现队列（简单） ](https://leetcode-cn.com/problems/implement-queue-using-
stacks)

[ 225. 用队列实现栈（简单） ](https://leetcode-cn.com/problems/implement-stack-using-
queues)

**———–**

队列是一种先进先出的数据结构，栈是一种先进后出的数据结构，形象一点就是这样：

![](https://labuladong.gitee.io/algo/images/%E6%A0%88%E9%98%9F%E5%88%97/1.jpg)

这两种数据结构底层其实都是数组或者链表实现的，只是 API 限定了它们的特性，那么今天就来看看如何使用「栈」的特性来实现一个「队列」，如何用「队列」实现一个「栈」。

### 一、用栈实现队列

首先，队列的 API 如下：

```java
    class MyQueue {
        
        /** 添加元素到队尾 */
        public void push(int x);
        
        /** 删除队头的元素并返回 */
        public int pop();
        
        /** 返回队头元素 */
        public int peek();
        
        /** 判断队列是否为空 */
        public boolean empty();
    }

```

我们使用两个栈 ` s1, s2 ` 就能实现一个队列的功能（这样放置栈可能更容易理解）：

![](https://labuladong.gitee.io/algo/images/%E6%A0%88%E9%98%9F%E5%88%97/2.jpg)

```java
    class MyQueue {
        private Stack<Integer> s1, s2;
        
        public MyQueue() {
            s1 = new Stack<>();
            s2 = new Stack<>();
        }
        // ...
    }

```

当调用 ` push ` 让元素入队时，只要把元素压入 ` s1 ` 即可，比如说 ` push ` 进 3 个元素分别是 1,2,3，那么底层结构就是这样：

![](https://labuladong.gitee.io/algo/images/%E6%A0%88%E9%98%9F%E5%88%97/3.jpg)

```java
    /** 添加元素到队尾 */
    public void push(int x) {
        s1.push(x);
    }

```

那么如果这时候使用 ` peek ` 查看队头的元素怎么办呢？按道理队头元素应该是 1，但是在 ` s1 ` 中 1 被压在栈底，现在就要轮到 ` s2 `起到一个中转的作用了：当 ` s2 ` 为空时，可以把 ` s1 ` 的所有元素取出再添加进 ` s2 ` ， **这时候` s2 `中元素就是先进先出顺序了 ** 。

![](https://labuladong.gitee.io/algo/images/%E6%A0%88%E9%98%9F%E5%88%97/4.jpg)

```java
    /** 返回队头元素 */
    public int peek() {
        if (s2.isEmpty())
            // 把 s1 元素压入 s2
            while (!s1.isEmpty())
                s2.push(s1.pop());
        return s2.peek();
    }

```

同理，对于 ` pop ` 操作，只要操作 ` s2 ` 就可以了。

```java
    /** 删除队头的元素并返回 */
    public int pop() {
        // 先调用 peek 保证 s2 非空
        peek();
        return s2.pop();
    }

```

最后，如何判断队列是否为空呢？如果两个栈都为空的话，就说明队列为空：

```java
    /** 判断队列是否为空 */
    public boolean empty() {
        return s1.isEmpty() && s2.isEmpty();
    }

```

至此，就用栈结构实现了一个队列，核心思想是利用两个栈互相配合。

值得一提的是，这几个操作的时间复杂度是多少呢？有点意思的是 ` peek ` 操作，调用它时可能触发 ` while ` 循环，这样的话时间复杂度是 O(N)，但是大部分情况下 ` while ` 循环不会被触发，时间复杂度是 O(1)
。由于 ` pop ` 操作调用了 ` peek `，它的时间复杂度和 ` peek ` 相同。

像这种情况，可以说它们的 **最坏时间复杂度** 是 O(N)，因为包含 ` while ` 循环， **可能** 需要从 ` s1 ` 往 ` s2 `搬移元素。

但是它们的 **均摊时间复杂度** 是 O(1)，这个要这么理解：对于一个元素，最多只可能被搬运一次，也就是说 ` peek `操作平均到每个元素的时间复杂度是 O(1)。

### 二、用队列实现栈

如果说双栈实现队列比较巧妙，那么用队列实现栈就比较简单粗暴了，只需要一个队列作为底层数据结构。首先看下栈的 API：

```java
    class MyStack {
        
        /** 添加元素到栈顶 */
        public void push(int x);
        
        /** 删除栈顶的元素并返回 */
        public int pop();
        
        /** 返回栈顶元素 */
        public int top();
        
        /** 判断栈是否为空 */
        public boolean empty();
    }

```

先说 ` push ` API，直接将元素加入队列，同时记录队尾元素，因为队尾元素相当于栈顶元素，如果要 ` top ` 查看栈顶元素的话可以直接返回：

```java
    class MyStack {
        Queue<Integer> q = new LinkedList<>();
        int top_elem = 0;
    
        /** 添加元素到栈顶 */
        public void push(int x) {
            // x 是队列的队尾，是栈的栈顶
            q.offer(x);
            top_elem = x;
        }
        
        /** 返回栈顶元素 */
        public int top() {
            return top_elem;
        }
    }

```

我们的底层数据结构是先进先出的队列，每次 ` pop ` 只能从队头取元素；但是栈是后进先出，也就是说 ` pop ` API 要从队尾取元素：

![](https://labuladong.gitee.io/algo/images/%E6%A0%88%E9%98%9F%E5%88%97/5.jpg)

解决方法简单粗暴，把队列前面的都取出来再加入队尾，让之前的队尾元素排到队头，这样就可以取出了：

![](https://labuladong.gitee.io/algo/images/%E6%A0%88%E9%98%9F%E5%88%97/6.jpg)

```java
    /** 删除栈顶的元素并返回 */
    public int pop() {
        int size = q.size();
        while (size > 1) {
            q.offer(q.poll());
            size--;
        }
        // 之前的队尾元素已经到了队头
        return q.poll();
    }

```

这样实现还有一点小问题就是，原来的队尾元素被提到队头并删除了，但是 ` top_elem ` 变量没有更新，我们还需要一点小修改：

```java
    /** 删除栈顶的元素并返回 */
    public int pop() {
        int size = q.size();
        // 留下队尾 2 个元素
        while (size > 2) {
            q.offer(q.poll());
            size--;
        }
        // 记录新的队尾元素
        top_elem = q.peek();
        q.offer(q.poll());
        // 删除之前的队尾元素
        return q.poll();
    }

```

最后，API ` empty ` 就很容易实现了，只要看底层的队列是否为空即可：

```java
    /** 判断栈是否为空 */
    public boolean empty() {
        return q.isEmpty();
    }

```

很明显，用队列实现栈的话， ` pop ` 操作时间复杂度是 O(N)，其他操作都是 O(1)​。​

个人认为，用队列实现栈是没啥亮点的问题，但是 **用双栈实现队列是值得学习的** 。

![](https://labuladong.gitee.io/algo/images/%E6%A0%88%E9%98%9F%E5%88%97/4.jpg)

从栈 ` s1 ` 搬运元素到 ` s2 ` 之后，元素在 ` s2 ` 中就变成了队列的先进先出顺序，这个特性有点类似「负负得正」，确实不太容易想到。

希望本文对你有帮助。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


# 手把手刷数组题目

1、《算法秘籍》和《刷题笔记》两本 PDF 下载 [ 点这里](https://mp.weixin.qq.com/s/X-fE9sR4BLi6T9pn7xP4pg) 。

2、刷题插件下载及使用手册 [ 点这里 ](https://mp.weixin.qq.com/s/wIxflO1dvXzDlibhEcENcQ) 。

3、公众号菜单栏参与 [ 21 天算法挑战活动 ](https://mp.weixin.qq.com/s/eUG2OOzY3k_ZTz-CFvtv5Q) 。

## 小而美的算法技巧：前缀和数组


读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 303. 区域和检索 - 数组不可变（中等） ](https://leetcode-cn.com/problems/range-sum-query-
immutable)

[ 304. 二维区域和检索 - 矩阵不可变（中等） ](https://leetcode-cn.com/problems/range-sum-
query-2d-immutable)

[ 560. 和为K的子数组（中等） ](https://leetcode-cn.com/problems/subarray-sum-equals-k)

**———–**

前缀和技巧适用于快速、频繁地计算一个索引区间内的元素之和。

### 一维数组中的前缀和

先看一道例题，力扣第 303 题「区域和检索 - 数组不可变」，让你计算数组区间内元素的和，这是一道标准的前缀和问题：

![](https://labuladong.gitee.io/algo/images/%E5%89%8D%E7%BC%80%E5%92%8C/title1.png)

题目要求你实现这样一个类：

```java
    class NumArray {
    
        public NumArray(int[] nums) {}
        
        /* 查询闭区间 [left, right] 的累加和 */
        public int sumRange(int left, int right) {}
    }

```

` sumRange ` 函数需要计算并返回一个索引区间之内的元素和，没学过前缀和的人可能写出如下代码：

```java
    class NumArray {
    
        private int[] nums;
    
        public NumArray(int[] nums) {
            this.nums = nums;
        }
        
        public int sumRange(int left, int right) {
            int res = 0;
            for (int i = left; i <= right; i++) {
                res += nums[i];
            }
            return res;
        }
    }

```

这样，可以达到效果，但是效率很差，因为 ` sumRange ` 方法会被频繁调用，而它的时间复杂度是 ` O(N) ` ，其中 ` N ` 代表 `nums ` 数组的长度。

这道题的最优解法是使用前缀和技巧，将 ` sumRange ` 函数的时间复杂度降为 ` O(1) ` ，说白了就是不要在 ` sumRange ` 里面用 for 循环，咋整？

直接看代码实现：

```java
    class NumArray {
        // 前缀和数组
        private int[] preSum;
    
        /* 输入一个数组，构造前缀和 */
        public NumArray(int[] nums) {
            // preSum[0] = 0，便于计算累加和
            preSum = new int[nums.length + 1];
            // 计算 nums 的累加和
            for (int i = 1; i < preSum.length; i++) {
                preSum[i] = preSum[i - 1] + nums[i - 1];
            }
        }
        
        /* 查询闭区间 [left, right] 的累加和 */
        public int sumRange(int left, int right) {
            return preSum[right + 1] - preSum[left];
        }
    }

```

核心思路是我们 new 一个新的数组 ` preSum ` 出来， ` preSum[i] ` 记录 ` nums[0..i-1] ` 的累加和，看图 10 = 3 + 5 + 2：

![](https://labuladong.gitee.io/algo/images/%e5%b7%ae%e5%88%86%e6%95%b0%e7%bb%84/1.jpeg)

看这个 ` preSum ` 数组，如果我想求索引区间 ` [1, 4] ` 内的所有元素之和，就可以通过 ` preSum[5] - preSum[1]
` 得出。

这样， ` sumRange ` 函数仅仅需要做一次减法运算，避免了每次进行 for 循环调用，最坏时间复杂度为常数 ` O(1) ` 。

这个技巧在生活中运用也挺广泛的，比方说，你们班上有若干同学，每个同学有一个期末考试的成绩（满分 100 分），那么请你实现一个 API，输入任意一个分数段，返回有多少同学的成绩在这个分数段内。

那么，你可以先通过计数排序的方式计算每个分数具体有多少个同学，然后利用前缀和技巧来实现分数段查询的 API：

```java
    int[] scores; // 存储着所有同学的分数
    // 试卷满分 100 分
    int[] count = new int[100 + 1]
    // 记录每个分数有几个同学
    for (int score : scores)
        count[score]++
    // 构造前缀和
    for (int i = 1; i < count.length; i++)
        count[i] = count[i] + count[i-1];
    
    // 利用 count 这个前缀和数组进行分数段查询

```

接下来，我们看一看前缀和思路在实际算法题中可以如何运用。

### 二维矩阵中的前缀和

这是力扣第 304 题「304. 二维区域和检索 - 矩阵不可变」，其实和上一题类似，上一题是让你计算子数组的元素之和，这道题让你计算二维矩阵中子矩阵的元素之和：

![](https://labuladong.gitee.io/algo/images/%E5%89%8D%E7%BC%80%E5%92%8C/title2.png)

比如说输入的 ` matrix ` 如下图：

![](https://labuladong.gitee.io/algo/images/%E5%89%8D%E7%BC%80%E5%92%8C/4.png)

那么 ` sumRegion([2,1,4,3]) ` 就是图中红色的子矩阵，你需要返回该子矩阵的元素和 8。

这题的思路和一维数组中的前缀和是非常类似的，如下图：

![](https://labuladong.gitee.io/algo/images/%E5%89%8D%E7%BC%80%E5%92%8C/5.png)

如果我想计算红色的这个子矩阵的元素之和，可以用绿色矩阵减去蓝色矩阵减去橙色矩阵最后加上粉色矩阵，而绿蓝橙粉这四个矩阵有一个共同的特点，就是左上角就是 `(0, 0) ` 原点。

那么我们可以维护一个二维 ` preSum ` 数组，专门记录以原点为顶点的矩阵的元素之和，就可以用几次加减运算算出任何一个子矩阵的元素和：

```java
    class NumMatrix {
        // preSum[i][j] 记录矩阵 [0, 0, i, j] 的元素和
        private int[][] preSum;
        
        public NumMatrix(int[][] matrix) {
            int m = matrix.length, n = matrix[0].length;
            if (m == 0 || n == 0) return;
            // 构造前缀和矩阵
            preSum = new int[m + 1][n + 1];
            for (int i = 1; i <= m; i++) {
                for (int j = 1; j <= n; j++) {
                    // 计算每个矩阵 [0, 0, i, j] 的元素和
                    preSum[i][j] = preSum[i-1][j] + preSum[i][j-1] + matrix[i - 1][j - 1] - preSum[i-1][j-1];
                }
            }
        }
        
        // 计算子矩阵 [x1, y1, x2, y2] 的元素和
        public int sumRegion(int x1, int y1, int x2, int y2) {
            // 目标矩阵之和由四个相邻矩阵运算获得
            return preSum[x2+1][y2+1] - preSum[x1][y2+1] - preSum[x2+1][y1] + preSum[x1][y1];
        }
    }

```

这样， ` sumRegion ` 函数的复杂度也用前缀和技巧优化到了 O(1)。

### 和为 k 的子数组

最后聊一道稍微有些困难的前缀和题目，力扣第 560 题「和为 K 的子数组」：

![](https://labuladong.gitee.io/algo/images/%E5%89%8D%E7%BC%80%E5%92%8C/title.png)

那我把所有子数组都穷举出来，算它们的和，看看谁的和等于 ` k ` 不就行了，借助前缀和技巧很容易写出一个解法：

```java
    int subarraySum(int[] nums, int k) {
        int n = nums.length;
        // 构造前缀和
        int[] preSum = new int[n + 1];
        preSum[0] = 0; 
        for (int i = 0; i < n; i++)
            preSum[i + 1] = preSum[i] + nums[i];
        
        int res = 0;
        // 穷举所有子数组
        for (int i = 1; i <= n; i++)
            for (int j = 0; j < i; j++)
                // 子数组 nums[j..i-1] 的元素和
                if (preSum[i] - preSum[j] == k)
                    res++;
    
        return res;
    }

```

这个解法的时间复杂度 ` O(N^2) ` 空间复杂度 ` O(N) `，并不是最优的解法。不过通过这个解法理解了前缀和数组的工作原理之后，可以使用一些巧妙的办法把时间复杂度进一步降低。

注意前面的解法有嵌套的 for 循环：

```java
    for (int i = 1; i <= n; i++)
        for (int j = 0; j < i; j++)
            if (preSum[i] - preSum[j] == k)
                res++;

```

第二层 for 循环在干嘛呢？翻译一下就是， **在计算，有几个` j ` 能够使得 ` preSum[i] ` 和 ` preSum[j] ` 的差为 `k ` ** 。毎找到一个这样的 ` j ` ，就把结果加一。

我们可以把 if 语句里的条件判断移项，这样写：

```java
    if (preSum[j] == preSum[i] - k)
        res++;

```

优化的思路是： **我直接记录下有几个` preSum[j] ` 和 ` preSum[i] - k ` 相等，直接更新结果，就避免了内层的 for 循环

** 。我们可以用哈希表，在记录前缀和的同时记录该前缀和出现的次数。

```java
    int subarraySum(int[] nums, int k) {
        int n = nums.length;
        // map：前缀和 -> 该前缀和出现的次数
        HashMap<Integer, Integer> 
            preSum = new HashMap<>();
        // base case
        preSum.put(0, 1);
    
        int res = 0, sum0_i = 0;
        for (int i = 0; i < n; i++) {
            sum0_i += nums[i];
            // 这是我们想找的前缀和 nums[0..j]
            int sum0_j = sum0_i - k;
            // 如果前面有这个前缀和，则直接更新答案
            if (preSum.containsKey(sum0_j))
                res += preSum.get(sum0_j);
            // 把前缀和 nums[0..i] 加入并记录出现次数
            preSum.put(sum0_i, 
                preSum.getOrDefault(sum0_i, 0) + 1);
        }
        return res;
    }

```

比如说下面这个情况，需要前缀和 8 就能找到和为 ` k ` 的子数组了，之前的暴力解法需要遍历数组去数有几个 8，而优化解法借助哈希表可以直接得知有几个前缀和为 8。

![](https://labuladong.gitee.io/algo/images/%E5%89%8D%E7%BC%80%E5%92%8C/2.jpg)

这样，就把时间复杂度降到了 ` O(N) ` ，是最优解法了。

前缀和技巧就讲到这里，应该说这个算法技巧是会者不难难者不会，实际运用中还是要多培养自己的思维灵活性，做到一眼看出题目是一个前缀和问题。

接下来可阅读：

* [ 差分数组技巧 ](https://labuladong.gitee.io/algo/2/20/54/)

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


## 小而美的算法技巧：差分数组


读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 370. 区间加法（中等） ](https://leetcode-cn.com/problems/range-addition/)

[ 1109. 航班预订统计（中等） ](https://leetcode-cn.com/problems/corporate-flight-
bookings/)

[ 1094. 拼车（中等） ](https://leetcode-cn.com/problems/car-pooling/)

**———–**

前文 [ 前缀和技巧详解 ](https://labuladong.gitee.io/algo/2/20/53/) 写过的前缀和技巧是非常常用的算法技巧，
**前缀和主要适用的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和** 。

没看过前文没关系，这里简单介绍一下前缀和，核心代码就是下面这段：

```java
    class PrefixSum {
        // 前缀和数组
        private int[] prefix;
        
        /* 输入一个数组，构造前缀和 */
        public PrefixSum(int[] nums) {
            prefix = new int[nums.length + 1];
            // 计算 nums 的累加和
            for (int i = 1; i < prefix.length; i++) {
                prefix[i] = prefix[i - 1] + nums[i - 1];
            }
        }
    
        /* 查询闭区间 [i, j] 的累加和 */
        public int query(int i, int j) {
            return prefix[j + 1] - prefix[i];
        }
    }

```

![](https://labuladong.gitee.io/algo/images/%e5%b7%ae%e5%88%86%e6%95%b0%e7%bb%84/1.jpeg)

` prefix[i] ` 就代表着 ` nums[0..i-1] ` 所有元素的累加和，如果我们想求区间 ` nums[i..j] ` 的累加和，只要计算
` prefix[j+1] - prefix[i] ` 即可，而不需要遍历整个区间求和。

本文讲一个和前缀和思想非常类似的算法技巧「差分数组」， **差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减** 。

比如说，我给你输入一个数组 ` nums ` ，然后又要求给区间 ` nums[2..6] ` 全部加 1，再给 ` nums[3..9] ` 全部减 3，再给 ` nums[0..4] ` 全部加 2，再给…

一通操作猛如虎，然后问你，最后 ` nums ` 数组的值是什么？

常规的思路很容易，你让我给区间 ` nums[i..j] ` 加上 ` val ` ，那我就一个 for 循环给它们都加上呗，还能咋样？这种思路的时间复杂度是 O(N)，由于这个场景下对 ` nums ` 的修改非常频繁，所以效率会很低下。

这里就需要差分数组的技巧，类似前缀和技巧构造的 ` prefix ` 数组，我们先对 ` nums ` 数组构造一个 ` diff ` 差分数组， **`
diff[i] ` 就是 ` nums[i] ` 和 ` nums[i-1] ` 之差 ** ：

```java
    int[] diff = new int[nums.length];
    // 构造差分数组
    diff[0] = nums[0];
    for (int i = 1; i < nums.length; i++) {
        diff[i] = nums[i] - nums[i - 1];
    }

```

![](https://labuladong.gitee.io/algo/images/%e5%b7%ae%e5%88%86%e6%95%b0%e7%bb%84/2.jpeg)

通过这个 ` diff ` 差分数组是可以反推出原始数组 ` nums ` 的，代码逻辑如下：

```java
    int[] res = new int[diff.length];
    // 根据差分数组构造结果数组
    res[0] = diff[0];
    for (int i = 1; i < diff.length; i++) {
        res[i] = res[i - 1] + diff[i];
    }

```

**这样构造差分数组` diff ` ，就可以快速进行区间增减的操作 ** ，如果你想对区间 ` nums[i..j] ` 的元素全部加 3，那么只需要让
` diff[i] += 3 ` ，然后再让 ` diff[j+1] -= 3 ` 即可：

![](https://labuladong.gitee.io/algo/images/%e5%b7%ae%e5%88%86%e6%95%b0%e7%bb%84/3.jpeg)

**原理很简单，回想` diff ` 数组反推 ` nums ` 数组的过程， ` diff[i] += 3 ` 意味着给 ` nums[i..] `所有的元素都加了 3，然后 ` diff[j+1] -= 3 ` 又意味着对于 ` nums[j+1..] ` 所有元素再减 3，那综合起来，是不是就是对
` nums[i..j] ` 中的所有元素都加 3 了 ** ？

只要花费 O(1) 的时间修改 ` diff ` 数组，就相当于给 ` nums ` 的整个区间做了修改。多次修改 ` diff ` ，然后通过 `diff ` 数组反推，即可得到 ` nums ` 修改后的结果。

现在我们把差分数组抽象成一个类，包含 ` increment ` 方法和 ` result ` 方法：

```java
    // 差分数组工具类
    class Difference {
        // 差分数组
        private int[] diff;
        
        /* 输入一个初始数组，区间操作将在这个数组上进行 */
        public Difference(int[] nums) {
            assert nums.length > 0;
            diff = new int[nums.length];
            // 根据初始数组构造差分数组
            diff[0] = nums[0];
            for (int i = 1; i < nums.length; i++) {
                diff[i] = nums[i] - nums[i - 1];
            }
        }
    
        /* 给闭区间 [i,j] 增加 val（可以是负数）*/
        public void increment(int i, int j, int val) {
            diff[i] += val;
            if (j + 1 < diff.length) {
                diff[j + 1] -= val;
            }
        }
    
        /* 返回结果数组 */
        public int[] result() {
            int[] res = new int[diff.length];
            // 根据差分数组构造结果数组
            res[0] = diff[0];
            for (int i = 1; i < diff.length; i++) {
                res[i] = res[i - 1] + diff[i];
            }
            return res;
        }
    }

```

这里注意一下 ` increment ` 方法中的 if 语句：

```java
    public void increment(int i, int j, int val) {
        diff[i] += val;
        if (j + 1 < diff.length) {
            diff[j + 1] -= val;
        }
    }

```

当 ` j+1 >= diff.length ` 时，说明是对 ` nums[i] ` 及以后的整个数组都进行修改，那么就不需要再给 ` diff `数组减 ` val ` 了。

### 算法实践

首先，力扣第 370 题「区间加法」 就直接考察了差分数组技巧：

![](https://labuladong.gitee.io/algo/images/%e5%b7%ae%e5%88%86%e6%95%b0%e7%bb%84/title1.png)

那么我们直接复用刚才实现的 ` Difference ` 类就能把这道题解决掉：

```java
    int[] getModifiedArray(int length, int[][] updates) {
        // nums 初始化为全 0
        int[] nums = new int[length];
        // 构造差分解法
        Difference df = new Difference(nums);
        
        for (int[] update : updates) {
            int i = update[0];
            int j = update[1];
            int val = update[2];
            df.increment(i, j, val);
        }
        
        return df.result();
    }

```

当然，实际的算法题可能需要我们对题目进行联想和抽象，不会这么直接地让你看出来要用差分数组技巧，这里看一下力扣第 1109 题「航班预订统计」：

![](https://labuladong.gitee.io/algo/images/%e5%b7%ae%e5%88%86%e6%95%b0%e7%bb%84/title.png)

函数签名如下：

```java
    int[] corpFlightBookings(int[][] bookings, int n)

```

这个题目就在那绕弯弯，其实它就是个差分数组的题，我给你翻译一下：

给你输入一个长度为 ` n ` 的数组 ` nums ` ，其中所有元素都是 0。再给你输入一个 ` bookings ` ，里面是若干三元组 `(i,j,k) ` ，每个三元组的含义就是要求你给 ` nums ` 数组的闭区间 ` [i-1,j-1] ` 中所有元素都加上 ` k `。请你返回最后的 ` nums ` 数组是多少？

> PS：因为题目说的 ` n ` 是从 1 开始计数的，而数组索引从 0 开始，所以对于输入的三元组 ` (i,j,k) ` ，数组区间应该对应 `> [i-1,j-1] ` 。

这么一看，不就是一道标准的差分数组题嘛？我们可以直接复用刚才写的类：

```java
    int[] corpFlightBookings(int[][] bookings, int n) {
        // nums 初始化为全 0
        int[] nums = new int[n];
        // 构造差分解法
        Difference df = new Difference(nums);
    
        for (int[] booking : bookings) {
            // 注意转成数组索引要减一哦
            int i = booking[0] - 1;
            int j = booking[1] - 1;
            int val = booking[2];
            // 对区间 nums[i..j] 增加 val
            df.increment(i, j, val);
        }
        // 返回最终的结果数组
        return df.result();
    }

```

这道题就解决了。

还有一道很类似的题目是力扣第 1094 题「拼车」，我简单描述下题目：

你是一个开公交车的司机，公交车的最大载客量为 ` capacity ` ，沿途要经过若干车站，给你一份乘客行程表 ` int[][] trips ` ，其中
` trips[i] = [num, start, end] ` 代表着有 ` num ` 个旅客要从站点 ` start ` 上车，到站点 ` end `下车，请你计算是否能够一次把所有旅客运送完毕（不能超过最大载客量 ` capacity ` ）。

函数签名如下：

```java
    boolean carPooling(int[][] trips, int capacity);

```

比如输入：

```java
    trips = [[2,1,5],[3,3,7]], capacity = 4

```

这就不能一次运完，因为 ` trips[1] ` 最多只能上 2 人，否则车就会超载。

相信你已经能够联想到差分数组技巧了： **` trips[i] ` 代表着一组区间操作，旅客的上车和下车就相当于数组的区间加减；只要结果数组中的元素都小于
` capacity ` ，就说明可以不超载运输所有旅客 ** 。

但问题是，差分数组的长度（车站的个数）应该是多少呢？题目没有直接给，但给出了数据取值范围：

```java
    0 <= trips[i][1] < trips[i][2] <= 1000

```

车站个数最多为 1000，那么我们的差分数组长度可以直接设置为 1001：

```java
    boolean carPooling(int[][] trips, int capacity) {
        // 最多有 1000 个车站
        int[] nums = new int[1001];
        // 构造差分解法
        Difference df = new Difference(nums);
        
        for (int[] trip : trips) {
            // 乘客数量
            int val = trip[0];
            // 第 trip[1] 站乘客上车
            int i = trip[1];
            // 第 trip[2] 站乘客已经下车，
            // 即乘客在车上的区间是 [trip[1], trip[2] - 1]
            int j = trip[2] - 1;
            // 进行区间操作
            df.increment(i, j, val);
        }
        
        int[] res = df.result();
        
        // 客车自始至终都不应该超载
        for (int i = 0; i < res.length; i++) {
            if (capacity < res[i]) {
                return false;
            }
        }
        return true;
    }

```

至此，这道题也解决了。

最后，差分数组和前缀和数组都是比较常见且巧妙的算法技巧，分别适用不同的常见，而且是会者不难，难者不会。所以，关于差分数组的使用，你学会了吗？

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


## 双指针技巧总结


读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 141. 环形链表（简单） ](https://leetcode-cn.com/problems/linked-list-cycle)

[ 142. 环形链表II（简单） ](https://leetcode-cn.com/problems/linked-list-cycle-ii)

[ 167. 两数之和 II - 输入有序数组（中等） ](https://leetcode-cn.com/problems/two-sum-ii-
input-array-is-sorted)

[ 344. 反转字符串（简单） ](https://leetcode-cn.com/problems/reverse-string/)

[ 19. 删除链表倒数第 N 个元素（中等） ](https://leetcode-cn.com/problems/remove-nth-node-
from-end-of-list)

[ 876. 链表的中间结点 ](https://leetcode-cn.com/problems/middle-of-the-linked-list/)

**———–**

我把双指针技巧再分为两类，一类是「快慢指针」，一类是「左右指针」。前者解决主要解决链表中的问题，比如典型的判定链表中是否包含环；后者主要解决数组（或者字符串）中的问题，比如二分查找。

### 一、快慢指针的常见算法

快慢指针一般都初始化指向链表的头结点 ` head ` ，前进时快指针 ` fast ` 在前，慢指针 ` slow ` 在后，巧妙解决一些链表中的问题。

**1、判定链表中是否含有环**

这属于链表最基本的操作了，学习数据结构应该对这个算法思想都不陌生。

单链表的特点是每个节点只知道下一个节点，所以一个指针的话无法判断链表中是否含有环的。

如果链表中不含环，那么这个指针最终会遇到空指针 ` null ` 表示链表到头了，这还好说，可以判断该链表不含环：

```java
    boolean hasCycle(ListNode head) {
        while (head != null)
            head = head.next;
        return false;
    }

```

但是如果链表中含有环，那么这个指针就会陷入死循环，因为环形数组中没有 ` null ` 指针作为尾部节点。

经典解法就是用两个指针，一个跑得快，一个跑得慢。如果不含有环，跑得快的那个指针最终会遇到 ` null `，说明链表不含环；如果含有环，快指针最终会超慢指针一圈，和慢指针相遇，说明链表含有环。

力扣第 141 题就是这个问题，解法代码如下：

```java
    boolean hasCycle(ListNode head) {
        ListNode fast, slow;
        fast = slow = head;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
            
            if (fast == slow) return true;
        }
        return false;
    }

```

**2、已知链表中含有环，返回这个环的起始位置**

![](https://labuladong.gitee.io/algo/images/%E5%8F%8C%E6%8C%87%E9%92%88/1.jpeg)

这是力扣第 142 题，其实一点都不困难，有点类似脑筋急转弯，先直接看代码：

```java
    ListNode detectCycle(ListNode head) {
        ListNode fast, slow;
        fast = slow = head;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
            if (fast == slow) break;
        }
        // 上面的代码类似 hasCycle 函数
        if (fast == null || fast.next == null) {
            // fast 遇到空指针说明没有环
            return null;
        }
    
        slow = head;
        while (slow != fast) {
            fast = fast.next;
            slow = slow.next;
        }
        return slow;
    }

```

可以看到，当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。这是为什么呢？

第一次相遇时，假设慢指针 ` slow ` 走了 ` k ` 步，那么快指针 ` fast ` 一定走了 ` 2k ` 步：

![](https://labuladong.gitee.io/algo/images/%E5%8F%8C%E6%8C%87%E9%92%88/3.jpeg)

**` fast ` 一定比 ` slow ` 多走了 ` k ` 步，这多走的 ` k ` 步其实就是 ` fast ` 指针在环里转圈圈，所以 ` k
` 的值就是环长度的「整数倍」 ** 。

说句题外话，之前还有读者争论为什么是环长度整数倍，我举个简单的例子你就明白了，我们想一想极端情况，假设环长度就是 1，如下图：

![](https://labuladong.gitee.io/algo/images/%E5%8F%8C%E6%8C%87%E9%92%88/4.jpeg)

那么 ` fast ` 肯定早早就进环里转圈圈了，而且肯定会转好多圈，这不就是环长度的整数倍嘛。

言归正传，设相遇点距环的起点的距离为 ` m ` ，那么环的起点距头结点 ` head ` 的距离为 ` k - m ` ，也就是说如果从 ` head `前进 ` k - m ` 步就能到达环起点。

巧的是，如果从相遇点继续前进 ` k - m ` 步，也恰好到达环起点。你甭管 ` fast ` 在环里到底转了几圈，反正走 ` k `步可以到相遇点，那走 ` k - m ` 步一定就是走到环起点了：

![](https://labuladong.gitee.io/algo/images/%E5%8F%8C%E6%8C%87%E9%92%88/2.jpeg)

所以，只要我们把快慢指针中的任一个重新指向 ` head ` ，然后两个指针同速前进， ` k - m ` 步后就会相遇，相遇之处就是环的起点了。

**3、寻找链表的中点**

类似上面的思路，我们还可以让快指针一次前进两步，慢指针一次前进一步，当快指针到达链表尽头时，慢指针就处于链表的中间位置。

力扣第 876 题就是找链表中点的题目，解法代码如下：

```java
    ListNode middleNode(ListNode head) {
        ListNode fast, slow;
        fast = slow = head;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }
        // slow 就在中间位置
        return slow;
    }

```

当链表的长度是奇数时， ` slow ` 恰巧停在中点位置；如果长度是偶数， ` slow ` 最终的位置是中间偏右：

![](https://labuladong.gitee.io/algo/images/%E5%8F%8C%E6%8C%87%E9%92%88/center.png)

寻找链表中点的一个重要作用是对链表进行归并排序。

回想数组的归并排序：求中点索引递归地把数组二分，最后合并两个有序数组。对于链表，合并两个有序链表是很简单的，难点就在于二分。

但是现在你学会了找到链表的中点，就能实现链表的二分了。关于归并排序的具体内容本文就不具体展开了。

**4、寻找链表的倒数第` n ` 个元素 **

这是力扣第 19 题「删除链表的倒数第 ` n ` 个元素」，先看下题目：

![](https://labuladong.gitee.io/algo/images/%e5%8f%8c%e6%8c%87%e9%92%88/title2.png)

我们的思路还是使用快慢指针，让快指针先走 ` n ` 步，然后快慢指针开始同速前进。这样当快指针走到链表末尾 ` null `时，慢指针所在的位置就是倒数第 ` n ` 个链表节点（ ` n ` 不会超过链表长度）。

解法比较简单，直接看代码吧：

```java
    ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode fast, slow;
        fast = slow = head;
        // 快指针先前进 n 步
        while (n-- > 0) {
            fast = fast.next;
        }
        if (fast == null) {
            // 如果此时快指针走到头了，
            // 说明倒数第 n 个节点就是第一个节点
            return head.next;
        }
        // 让慢指针和快指针同步向前
        while (fast != null && fast.next != null) {
            fast = fast.next;
            slow = slow.next;
        }
        // slow.next 就是倒数第 n 个节点，删除它
        slow.next = slow.next.next;
        return head;
    }

```

### 二、左右指针的常用算法

左右指针在数组中实际是指两个索引值，一般初始化为 ` left = 0, right = nums.length - 1 ` 。

**1、二分查找**

前文 [ 二分查找框架详解 ](https://labuladong.gitee.io/algo/2/20/57/) 有详细讲解，这里只写最简单的二分算法，旨在突出它的双指针特性：

```java
    int binarySearch(int[] nums, int target) {
        int left = 0; 
        int right = nums.length - 1;
        while(left <= right) {
            int mid = (right + left) / 2;
            if(nums[mid] == target)
                return mid; 
            else if (nums[mid] < target)
                left = mid + 1; 
            else if (nums[mid] > target)
                right = mid - 1;
        }
        return -1;
    }

```

**2、两数之和**

直接看力扣第 167 题「两数之和 II」吧：

![](https://labuladong.gitee.io/algo/images/%E5%8F%8C%E6%8C%87%E9%92%88/title.png)

只要数组有序，就应该想到双指针技巧。这道题的解法有点类似二分查找，通过调节 ` left ` 和 ` right ` 可以调整 ` sum ` 的大小：

```java
    int[] twoSum(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left < right) {
            int sum = nums[left] + nums[right];
            if (sum == target) {
                // 题目要求的索引是从 1 开始的
                return new int[]{left + 1, right + 1};
            } else if (sum < target) {
                left++; // 让 sum 大一点
            } else if (sum > target) {
                right--; // 让 sum 小一点
            }
        }
        return new int[]{-1, -1};
    }

```

**3、反转数组**

一般编程语言都会提供 ` reverse ` 函数，其实非常简单，力扣第 344 题是类似的需求，让你反转一个 ` char[] `类型的字符数组，我们直接看代码吧：

```java
    void reverseString(char[] arr) {
        int left = 0;
        int right = arr.length - 1;
        while (left < right) {
            // 交换 arr[left] 和 arr[right]
            char temp = arr[left];
            arr[left] = arr[right];
            arr[right] = temp;
            left++; right--;
        }
    }

```

**4、滑动窗口算法**

这也许是双指针技巧的最高境界了，如果掌握了此算法，可以解决一大类子字符串匹配的问题，不过「滑动窗口」稍微比上述的这些算法复杂些。

不过这类算法是有框架模板的，而且前文 [ 我写了首诗，把滑动窗口算法变成了默写题 ](https://labuladong.gitee.io/algo/2/20/56/)就讲解了「滑动窗口」算法模板，帮大家秒杀几道子串匹配的问题，如果没有看过，建议去看看。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


## 我写了首诗，把滑动窗口算法算法变成了默写题


读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 76. 最小覆盖子串（困难） ](https://leetcode-cn.com/problems/minimum-window-substring)

[ 567. 字符串的排列（中等） ](https://leetcode-cn.com/problems/permutation-in-string)

[ 438. 找到字符串中所有字母异位词（中等） ](https://leetcode-cn.com/problems/find-all-anagrams-
in-a-string)

[ 3. 无重复字符的最长子串（中等） ](https://leetcode-cn.com/problems/longest-substring-
without-repeating-characters)

**———–**

鉴于前文 [ 二分搜索框架详解 ](https://labuladong.gitee.io/algo/2/20/57/)的那首《二分搜索升天词》很受好评，并在民间广为流传，成为安睡助眠的一剂良方，今天在滑动窗口算法框架中，我再次编写一首小诗来歌颂滑动窗口算法的伟大：

![](https://labuladong.gitee.io/algo/images/slidingwindow/poem.png)

关于双指针的快慢指针和左右指针的用法，可以参见前文 [ 双指针技巧汇总 ](https://labuladong.gitee.io/algo/2/20/55/)
，本文就解决一类最难掌握的双指针技巧：滑动窗口技巧。总结出一套框架，可以保你闭着眼睛都能写出正确的解法。

说起滑动窗口算法，很多读者都会头疼。这个算法技巧的思路非常简单，就是维护一个窗口，不断滑动，然后更新答案么。LeetCode 上有起码 10 道运用滑动窗口算法的题目，难度都是中等和困难。该算法的大致逻辑如下：

```java
    int left = 0, right = 0;
    
    while (right < s.size()) {
        // 增大窗口
        window.add(s[right]);
        right++;
        
        while (window needs shrink) {
            // 缩小窗口
            window.remove(s[left]);
            left++;
        }
    }

```

这个算法技巧的时间复杂度是 O(N)，比字符串暴力算法要高效得多。

其实困扰大家的，不是算法的思路，而是各种细节问题。比如说如何向窗口中添加新元素，如何缩小窗口，在窗口滑动的哪个阶段更新结果。即便你明白了这些细节，也容易出 bug，找 bug 还不知道怎么找，真的挺让人心烦的。

**所以今天我就写一套滑动窗口算法的代码框架，我连再哪里做输出 debug 都给你写好了，以后遇到相关的问题，你就默写出来如下框架然后改三个地方就行，还不会出 bug** ：

```java
    /* 滑动窗口算法框架 */
    void slidingWindow(string s, string t) {
        unordered_map<char, int> need, window;
        for (char c : t) need[c]++;
        
        int left = 0, right = 0;
        int valid = 0; 
        while (right < s.size()) {
            // c 是将移入窗口的字符
            char c = s[right];
            // 右移窗口
            right++;
            // 进行窗口内数据的一系列更新
            ...
    
            /*** debug 输出的位置 ***/
            printf("window: [%d, %d)\n", left, right);
            /********************/
            
            // 判断左侧窗口是否要收缩
            while (window needs shrink) {
                // d 是将移出窗口的字符
                char d = s[left];
                // 左移窗口
                left++;
                // 进行窗口内数据的一系列更新
                ...
            }
        }
    }

```

**其中两处` ... ` 表示的更新窗口数据的地方，到时候你直接往里面填就行了 ** 。

而且，这两个 ` ... ` 处的操作分别是右移和左移窗口更新操作，等会你会发现它们操作是完全对称的。

说句题外话，我发现很多人喜欢执着于表象，不喜欢探求问题的本质。比如说有很多人评论我这个框架，说什么散列表速度慢，不如用数组代替散列表；还有很多人喜欢把代码写得特别短小，说我这样代码太多余，影响编译速度，LeetCode 上速度不够快。

我服了。算法看的是时间复杂度，你能确保自己的时间复杂度最优，就行了。至于 LeetCode 所谓的运行速度，那个都是玄学，只要不是慢的离谱就没啥问题，根本不值得你从编译层面优化，不要舍本逐末……

我的公众号重点在于算法思想，你把框架思维了然于心，然后随你魔改代码好吧，你高兴就好。

言归正传，下面就直接上 **四道** LeetCode 原题来套这个框架，其中第一道题会详细说明其原理，后面四道就直接闭眼睛秒杀了。

因为滑动窗口很多时候都是在处理字符串相关的问题，Java 处理字符串不方便，所以本文代码为 C++ 实现。不会用到什么编程方面的奇技淫巧，但是还是简单介绍一下一些用到的数据结构，以免有的读者因为语言的细节问题阻碍对算法思想的理解：

` unordered_map ` 就是哈希表（字典），它的一个方法 ` count(key) ` 相当于 Java 的 `containsKey(key) ` 可以判断键 key 是否存在。

可以使用方括号访问键对应的值 ` map[key] ` 。需要注意的是，如果该 ` key ` 不存在，C++ 会自动创建这个 key，并把 `map[key] ` 赋值为 0。

所以代码中多次出现的 ` map[key]++ ` 相当于 Java 的 ` map.put(key, map.getOrDefault(key, 0) +

1) ` 。

### 一、最小覆盖子串

先来看看力扣第 76 题「最小覆盖子串」难度 Hard：

![](https://labuladong.gitee.io/algo/images/slidingwindow/title1.png)

就是说要在 ` S ` (source) 中找到包含 ` T ` (target) 中全部字母的一个子串，且这个子串一定是所有可能子串中最短的。

如果我们使用暴力解法，代码大概是这样的：

```java
    for (int i = 0; i < s.size(); i++)
        for (int j = i + 1; j < s.size(); j++)
            if s[i:j] 包含 t 的所有字母:
                更新答案

```

思路很直接，但是显然，这个算法的复杂度肯定大于 O(N^2) 了，不好。

**滑动窗口算法的思路是这样** ：

1、我们在字符串 ` S ` 中使用双指针中的左右指针技巧，初始化 ` left = right = 0 ` ，把索引 **左闭右开** 区间 `[left, right) ` 称为一个「窗口」。

2、我们先不断地增加 ` right ` 指针扩大窗口 ` [left, right) ` ，直到窗口中的字符串符合要求（包含了 ` T `中的所有字符）。

3、此时，我们停止增加 ` right ` ，转而不断增加 ` left ` 指针缩小窗口 ` [left, right) `，直到窗口中的字符串不再符合要求（不包含 ` T ` 中的所有字符了）。同时，每次增加 ` left ` ，我们都要更新一轮结果。

4、重复第 2 和第 3 步，直到 ` right ` 到达字符串 ` S ` 的尽头。

这个思路其实也不难， **第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解**，也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动，这就是「滑动窗口」这个名字的来历。

下面画图理解一下， ` needs ` 和 ` window ` 相当于计数器，分别记录 ` T ` 中字符出现次数和「窗口」中的相应字符的出现次数。

初始状态：

![](https://labuladong.gitee.io/algo/images/slidingwindow/1.png)

增加 ` right ` ，直到窗口 ` [left, right] ` 包含了 ` T ` 中所有字符：

![](https://labuladong.gitee.io/algo/images/slidingwindow/2.png)

现在开始增加 ` left ` ，缩小窗口 ` [left, right] ` ：

![](https://labuladong.gitee.io/algo/images/slidingwindow/3.png)

直到窗口中的字符串不再符合要求， ` left ` 不再继续移动：

![](https://labuladong.gitee.io/algo/images/slidingwindow/4.png)

之后重复上述过程，先移动 ` right ` ，再移动 ` left ` …… 直到 ` right ` 指针到达字符串 ` S ` 的末端，算法结束。

如果你能够理解上述过程，恭喜，你已经完全掌握了滑动窗口算法思想。 **现在我们来看看这个滑动窗口代码框架怎么用** ：

首先，初始化 ` window ` 和 ` need ` 两个哈希表，记录窗口中的字符和需要凑齐的字符：

```java
    unordered_map<char, int> need, window;
    for (char c : t) need[c]++;

```

然后，使用 ` left ` 和 ` right ` 变量初始化窗口的两端，不要忘了，区间 ` [left, right) `是左闭右开的，所以初始情况下窗口没有包含任何元素：

```java
    int left = 0, right = 0;
    int valid = 0; 
    while (right < s.size()) {
        // 开始滑动
    }

```

**其中` valid ` 变量表示窗口中满足 ` need ` 条件的字符个数 ** ，如果 ` valid ` 和 ` need.size `的大小相同，则说明窗口已满足条件，已经完全覆盖了串 ` T ` 。

**现在开始套模板，只需要思考以下四个问题** ：

1、当移动 ` right ` 扩大窗口，即加入字符时，应该更新哪些数据？

2、什么条件下，窗口应该暂停扩大，开始移动 ` left ` 缩小窗口？

3、当移动 ` left ` 缩小窗口，即移出字符时，应该更新哪些数据？

4、我们要的结果应该在扩大窗口时还是缩小窗口时进行更新？

如果一个字符进入窗口，应该增加 ` window ` 计数器；如果一个字符将移出窗口的时候，应该减少 ` window ` 计数器；当 ` valid `满足 ` need ` 时应该收缩窗口；应该在收缩窗口的时候更新最终结果。

下面是完整代码：

```java
    string minWindow(string s, string t) {
        unordered_map<char, int> need, window;
        for (char c : t) need[c]++;
    
        int left = 0, right = 0;
        int valid = 0;
        // 记录最小覆盖子串的起始索引及长度
        int start = 0, len = INT_MAX;
        while (right < s.size()) {
            // c 是将移入窗口的字符
            char c = s[right];
            // 右移窗口
            right++;
            // 进行窗口内数据的一系列更新
            if (need.count(c)) {
                window[c]++;
                if (window[c] == need[c])
                    valid++;
            }
    
            // 判断左侧窗口是否要收缩
            while (valid == need.size()) {
                // 在这里更新最小覆盖子串
                if (right - left < len) {
                    start = left;
                    len = right - left;
                }
                // d 是将移出窗口的字符
                char d = s[left];
                // 左移窗口
                left++;
                // 进行窗口内数据的一系列更新
                if (need.count(d)) {
                    if (window[d] == need[d])
                        valid--;
                    window[d]--;
                }                    
            }
        }
        // 返回最小覆盖子串
        return len == INT_MAX ?
            "" : s.substr(start, len);
    }

```

> PS：使用 Java 的读者要尤其警惕语言特性的陷阱。Java 的 Integer，String 等类型判定相等应该用 ` equals `> 方法而不能直接用等号 ` == ` ，这是 Java包装类的一个隐晦细节。所以在左移窗口更新数据的时候，不能直接改写为 ` window.get(d)
> == need.get(d) ` ，而要用 ` window.get(d).equals(need.get(d)) ` ，之后的题目代码同理。

需要注意的是，当我们发现某个字符在 ` window ` 的数量满足了 ` need ` 的需要，就要更新 ` valid `，表示有一个字符已经满足要求。而且，你能发现，两次对窗口内数据的更新操作是完全对称的。

当 ` valid == need.size() ` 时，说明 ` T `中所有字符已经被覆盖，已经得到一个可行的覆盖子串，现在应该开始收缩窗口了，以便得到「最小覆盖子串」。

移动 ` left ` 收缩窗口时，窗口内的字符都是可行解，所以应该在收缩窗口的阶段进行最小覆盖子串的更新，以便从可行解中找到长度最短的最终结果。

至此，应该可以完全理解这套框架了，滑动窗口算法又不难，就是细节问题让人烦得很。 **以后遇到滑动窗口算法，你就按照这框架写代码，保准没有 bug，还省事儿** 。

下面就直接利用这套框架秒杀几道题吧，你基本上一眼就能看出思路了。

### 二、字符串排列

LeetCode 567 题，Permutation in String，难度 Medium：

![](https://labuladong.gitee.io/algo/images/slidingwindow/title2.png)

注意哦，输入的 ` s1 ` 是可以包含重复字符的，所以这个题难度不小。

这种题目，是明显的滑动窗口算法， **相当给你一个` S ` 和一个 ` T ` ，请问你 ` S ` 中是否存在一个子串，包含 ` T `中所有字符且不包含其他字符 ** ？

首先，先复制粘贴之前的算法框架代码，然后明确刚才提出的 4 个问题，即可写出这道题的答案：

```java
    // 判断 s 中是否存在 t 的排列
    bool checkInclusion(string t, string s) {
        unordered_map<char, int> need, window;
        for (char c : t) need[c]++;
    
        int left = 0, right = 0;
        int valid = 0;
        while (right < s.size()) {
            char c = s[right];
            right++;
            // 进行窗口内数据的一系列更新
            if (need.count(c)) {
                window[c]++;
                if (window[c] == need[c])
                    valid++;
            }
    
            // 判断左侧窗口是否要收缩
            while (right - left >= t.size()) {
                // 在这里判断是否找到了合法的子串
                if (valid == need.size())
                    return true;
                char d = s[left];
                left++;
                // 进行窗口内数据的一系列更新
                if (need.count(d)) {
                    if (window[d] == need[d])
                        valid--;
                    window[d]--;
                }
            }
        }
        // 未找到符合条件的子串
        return false;
    }

```

对于这道题的解法代码，基本上和最小覆盖子串一模一样，只需要改变两个地方：

1、本题移动 ` left ` 缩小窗口的时机是窗口大小大于 ` t.size() ` 时，应为排列嘛，显然长度应该是一样的。

2、当发现 ` valid == need.size() ` 时，就说明窗口中就是一个合法的排列，所以立即返回 ` true ` 。

至于如何处理窗口的扩大和缩小，和最小覆盖子串完全相同。

### 三、找所有字母异位词

这是 LeetCode 第 438 题，Find All Anagrams in a String，难度 Medium：

![](https://labuladong.gitee.io/algo/images/slidingwindow/title3.png)

呵呵，这个所谓的字母异位词，不就是排列吗，搞个高端的说法就能糊弄人了吗？ **相当于，输入一个串` S ` ，一个串 ` T ` ，找到 ` S ` 中所有
` T ` 的排列，返回它们的起始索引 ** 。

直接默写一下框架，明确刚才讲的 4 个问题，即可秒杀这道题：

```java
    vector<int> findAnagrams(string s, string t) {
        unordered_map<char, int> need, window;
        for (char c : t) need[c]++;
    
        int left = 0, right = 0;
        int valid = 0;
        vector<int> res; // 记录结果
        while (right < s.size()) {
            char c = s[right];
            right++;
            // 进行窗口内数据的一系列更新
            if (need.count(c)) {
                window[c]++;
                if (window[c] == need[c]) 
                    valid++;
            }
            // 判断左侧窗口是否要收缩
            while (right - left >= t.size()) {
                // 当窗口符合条件时，把起始索引加入 res
                if (valid == need.size())
                    res.push_back(left);
                char d = s[left];
                left++;
                // 进行窗口内数据的一系列更新
                if (need.count(d)) {
                    if (window[d] == need[d])
                        valid--;
                    window[d]--;
                }
            }
        }
        return res;
    }

```

跟寻找字符串的排列一样，只是找到一个合法异位词（排列）之后将起始索引加入 ` res ` 即可。

### 四、最长无重复子串

这是 LeetCode 第 3 题，Longest Substring Without Repeating Characters，难度 Medium：

![](https://labuladong.gitee.io/algo/images/slidingwindow/title4.png)

这个题终于有了点新意，不是一套框架就出答案，不过反而更简单了，稍微改一改框架就行了：

```java
    int lengthOfLongestSubstring(string s) {
        unordered_map<char, int> window;
    
        int left = 0, right = 0;
        int res = 0; // 记录结果
        while (right < s.size()) {
            char c = s[right];
            right++;
            // 进行窗口内数据的一系列更新
            window[c]++;
            // 判断左侧窗口是否要收缩
            while (window[c] > 1) {
                char d = s[left];
                left++;
                // 进行窗口内数据的一系列更新
                window[d]--;
            }
            // 在这里更新答案
            res = max(res, right - left);
        }
        return res;
    }

```

这就是变简单了，连 ` need ` 和 ` valid ` 都不需要，而且更新窗口内数据也只需要简单的更新计数器 ` window ` 即可。

当 ` window[c] ` 值大于 1 时，说明窗口中存在重复字符，不符合条件，就该移动 ` left ` 缩小窗口了嘛。

唯一需要注意的是，在哪里更新结果 ` res ` 呢？我们要的是最长无重复子串，哪一个阶段可以保证窗口中的字符串是没有重复的呢？

这里和之前不一样，要在收缩窗口完成后更新 ` res ` ，因为窗口收缩的 while 条件是存在重复元素，换句话说收缩完成后一定保证窗口中没有重复嘛。

### 五、最后总结

建议背诵并默写这套框架，顺便背诵一下文章开头的那首诗。以后就再也不怕子串、子数组问题了好吧。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


## 我写了首诗，让你闭着眼睛也能写对二分搜索


读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 704. 二分查找（简单） ](https://leetcode-cn.com/problems/binary-search)

[ 34. 在排序数组中查找元素的第一个和最后一个位置（中等） ](https://leetcode-cn.com/problems/find-first-
and-last-position-of-element-in-sorted-array/)

**———–**

本文是前文 [ 二分搜索详解 ](https://mp.weixin.qq.com/s/uA2suoVykENmCQcKFMOSuQ)的修订版，添加了对二分搜索算法更详细的分析。

先给大家讲个笑话乐呵一下：

有一天阿东到图书馆借了 N
本书，出图书馆的时候，警报响了，于是保安把阿东拦下，要检查一下哪本书没有登记出借。阿东正准备把每一本书在报警器下过一下，以找出引发警报的书，但是保安露出不屑的眼神：你连二分查找都不会吗？于是保安把书分成两堆，让第一堆过一下报警器，报警器响；于是再把这堆书分成两堆……
最终，检测了 logN 次之后，保安成功的找到了那本引起警报的书，露出了得意和嘲讽的笑容。于是阿东背着剩下的书走了。

从此，图书馆丢了 N - 1 本书。

二分查找并不简单，Knuth 大佬（发明 KMP 算法的那位）都说二分查找： **思路很简单，细节是魔鬼** 。很多人喜欢拿整型溢出的 bug 说事儿，但是二分查找真正的坑根本就不是那个细节问题，而是在于到底要给 ` mid `加一还是减一，while 里到底用 ` <= ` 还是 ` < ` 。

你要是没有正确理解这些细节，写二分肯定就是玄学编程，有没有 bug 只能靠菩萨保佑。 **我特意写了一首诗来歌颂该算法，概括本文的主要内容，建议保存** ：

![](https://labuladong.gitee.io/algo/images/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/poem.png)

本文就来探究几个最常用的二分查找场景：寻找一个数、寻找左侧边界、寻找右侧边界。而且，我们就是要深入细节，比如不等号是否应该带等号，mid 是否应该加一等等。分析这些细节的差异以及出现这些差异的原因，保证你能灵活准确地写出正确的二分查找算法。

### 零、二分查找框架

```java
    int binarySearch(int[] nums, int target) {
        int left = 0, right = ...;
    
        while(...) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                ...
            } else if (nums[mid] < target) {
                left = ...
            } else if (nums[mid] > target) {
                right = ...
            }
        }
        return ...;
    }

```

**分析二分查找的一个技巧是：不要出现 else，而是把所有情况用 else if 写清楚，这样可以清楚地展现所有细节** 。本文都会使用 else if，旨在讲清楚，读者理解后可自行简化。

其中 ` ... ` 标记的部分，就是可能出现细节问题的地方，当你见到一个二分查找的代码时，首先注意这几个地方。后文用实例分析这些地方能有什么样的变化。

另外声明一下，计算 mid 时需要防止溢出，代码中 ` left + (right - left) / 2 ` 就和 ` (left + right) / 2 ` 的结果相同，但是有效防止了 ` left ` 和 ` right `太大直接相加导致溢出。

### 一、寻找一个数（基本的二分搜索）

这个场景是最简单的，可能也是大家最熟悉的，即搜索一个数，如果存在，返回其索引，否则返回 -1。

```java
    int binarySearch(int[] nums, int target) {
        int left = 0; 
        int right = nums.length - 1; // 注意
    
        while(left <= right) {
            int mid = left + (right - left) / 2;
            if(nums[mid] == target)
                return mid; 
            else if (nums[mid] < target)
                left = mid + 1; // 注意
            else if (nums[mid] > target)
                right = mid - 1; // 注意
        }
        return -1;
    }

```

**1、为什么 while 循环的条件中是 <=，而不是 < ** ？

答：因为初始化 ` right ` 的赋值是 ` nums.length - 1 ` ，即最后一个元素的索引，而不是 ` nums.length ` 。

这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 ` [left, right] ` ，后者相当于左闭右开区间 ` [left, right) ` ，因为索引大小为 ` nums.length ` 是越界的。

我们这个算法中使用的是前者 ` [left, right] ` 两端都闭的区间。 **这个区间其实就是每次进行搜索的区间** 。

什么时候应该停止搜索呢？当然，找到了目标值的时候可以终止：

```java
        if(nums[mid] == target)
            return mid; 

```

但如果没找到，就需要 while 循环终止，然后返回 -1。那 while 循环什么时候应该终止？ **搜索区间为空的时候应该终止**，意味着你没得找了，就等于没找到嘛。

` while(left <= right) ` 的终止条件是 ` left == right + 1 ` ，写成区间的形式就是 ` [right + 1, right] ` ，或者带个具体的数字进去 ` [3, 2] ` ，可见 **这时候区间为空** ，因为没有数字既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。

` while(left < right) ` 的终止条件是 ` left == right ` ，写成区间的形式就是 ` [right, right] `，或者带个具体的数字进去 ` [2, 2] ` ， **这时候区间非空** ，还有一个数 2，但此时 while 循环终止了。也就是说这区间 ` [2, 2] ` 被漏掉了，索引 2 没有被搜索，如果这时候直接返回 -1 就是错误的。

当然，如果你非要用 ` while(left < right) ` 也可以，我们已经知道了出错的原因，就打个补丁好了：

```java
        //...
        while(left < right) {
            // ...
        }
        return nums[left] == target ? left : -1;

```

**2、为什么` left = mid + 1 ` ， ` right = mid - 1 ` ？我看有的代码是 ` right = mid ` 或者 `left = mid ` ，没有这些加加减减，到底怎么回事，怎么判断 ** ？

答：这也是二分查找的一个难点，不过只要你能理解前面的内容，就能够很容易判断。

刚才明确了「搜索区间」这个概念，而且本算法的搜索区间是两端都闭的，即 ` [left, right] ` 。那么当我们发现索引 ` mid ` 不是要找的
` target ` 时，下一步应该去搜索哪里呢？

当然是去搜索 ` [left, mid-1] ` 或者 ` [mid+1, right] ` 对不对？ **因为` mid `已经搜索过，应该从搜索区间中去除 ** 。

**3、此算法有什么缺陷** ？

答：至此，你应该已经掌握了该算法的所有细节，以及这样处理的原因。但是，这个算法存在局限性。

比如说给你有序数组 ` nums = [1,2,2,2,3] ` ， ` target ` 为 2，此算法返回的索引是 2，没错。但是如果我想得到 `target ` 的左侧边界，即索引 1，或者我想得到 ` target ` 的右侧边界，即索引 3，这样的话此算法是无法处理的。

这样的需求很常见， **你也许会说，找到一个` target ` ，然后向左或向右线性搜索不行吗？可以，但是不好，因为这样难以保证二分查找对数级的复杂度了

** 。

我们后续的算法就来讨论这两种二分查找的算法。

### 二、寻找左侧边界的二分搜索

以下是最常见的代码形式，其中的标记是需要注意的细节：

```java
    int left_bound(int[] nums, int target) {
        if (nums.length == 0) return -1;
        int left = 0;
        int right = nums.length; // 注意
        
        while (left < right) { // 注意
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                right = mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid; // 注意
            }
        }
        return left;
    }

```

**1、为什么 while 中是` < ` 而不是 ` <= ` ** ?

答：用相同的方法分析，因为 ` right = nums.length ` 而不是 ` nums.length - 1 ` 。因此每次循环的「搜索区间」是
` [left, right) ` 左闭右开。

` while(left < right) ` 终止的条件是 ` left == right ` ，此时搜索区间 ` [left, left) `为空，所以可以正确终止。

> PS：这里先要说一个搜索左右边界和上面这个算法的一个区别，也是很多读者问的： **刚才的` right ` 不是 ` nums.length - 1 `> 吗，为啥这里非要写成 ` nums.length ` 使得「搜索区间」变成左闭右开呢 ** ？

因为对于搜索左右侧边界的二分查找，这种写法比较普遍，我就拿这种写法举例了，保证你以后遇到这类代码可以理解。你非要用两端都闭的写法反而更简单，我会在后面写相关的代码，把三种二分搜索都用一种两端都闭的写法统一起来，你耐心往后看就行了。

**2、为什么没有返回 -1 的操作？如果` nums ` 中不存在 ` target ` 这个值，怎么办 ** ？

答：因为要一步一步来，先理解一下这个「左侧边界」有什么特殊含义：

![](https://labuladong.gitee.io/algo/images/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/1.jpg)

对于这个数组，算法会返回索引 1。

这个索引 1 的含义可以解读为「 ` nums ` 中小于 2 的元素有 1 个」。

比如对于有序数组 ` nums = [2,3,5,7] ` , ` target = 1 ` ，算法会返回 0，含义是： ` nums ` 中小于 1 的元素有 0 个。

再比如说 ` nums = [2,3,5,7], target = 8 ` ，算法会返回 4，含义是： ` nums ` 中小于 8 的元素有 4 个。

> PS：对于 ` target ` 不存在 ` nums ` 中的情况，函数的返回值还可以有多种理解方式，详见 [ 随机权重算法
> 
> ](https://mp.weixin.qq.com/s/_5t0RSqUzErWUYYb-w0MMw) 中对二分搜索的运用。

综上可以看出，函数的返回值（即 ` left ` 变量的值）取值区间是闭区间 ` [0, nums.length] `，所以我们简单添加两行代码就能在正确的时候 return -1：

```java
    while (left < right) {
        //...
    }
    // target 比所有数都大
    if (left == nums.length) return -1;
    // 类似之前算法的处理方式
    return nums[left] == target ? left : -1;

```

**3、为什么` left = mid + 1 ` ， ` right = mid ` ？和之前的算法不一样 ** ？

答：这个很好解释，因为我们的「搜索区间」是 ` [left, right) ` 左闭右开，所以当 ` nums[mid] `被检测之后，下一步的搜索区间应该去掉 ` mid ` 分割成两个区间，即 ` [left, mid) ` 或 ` [mid + 1, right) ` 。

**4、为什么该算法能够搜索左侧边界** ？

答：关键在于对于 ` nums[mid] == target ` 这种情况的处理：

```java
        if (nums[mid] == target)
            right = mid;

```

可见，找到 target 时不要立即返回，而是缩小「搜索区间」的上界 ` right ` ，在区间 ` [left, mid) `中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。

**5、为什么返回` left ` 而不是 ` right ` ** ？

答：都是一样的，因为 while 终止的条件是 ` left == right ` 。

**6、能不能想办法把` right ` 变成 ` nums.length - 1 `，也就是继续使用两边都闭的「搜索区间」？这样就可以和第一种二分搜索在某种程度上统一起来了 ** 。

答：当然可以，只要你明白了「搜索区间」这个概念，就能有效避免漏掉元素，随便你怎么改都行。下面我们严格根据逻辑来修改：

因为你非要让搜索区间两端都闭，所以 ` right ` 应该初始化为 ` nums.length - 1 ` ，while 的终止条件应该是 ` left == right + 1 ` ，也就是其中应该用 ` <= ` ：

```java
    int left_bound(int[] nums, int target) {
        // 搜索区间为 [left, right]
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            // if else ...
        }

```

因为搜索区间是两端都闭的，且现在是搜索左侧边界，所以 ` left ` 和 ` right ` 的更新逻辑如下：

```java
    if (nums[mid] < target) {
        // 搜索区间变为 [mid+1, right]
        left = mid + 1;
    } else if (nums[mid] > target) {
        // 搜索区间变为 [left, mid-1]
        right = mid - 1;
    } else if (nums[mid] == target) {
        // 收缩右侧边界
        right = mid - 1;
    }

```

由于 while 的退出条件是 ` left == right + 1 ` ，所以当 ` target ` 比 ` nums `中所有元素都大时，会存在以下情况使得索引越界：

![](https://labuladong.gitee.io/algo/images/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/2.jpg)

因此，最后返回结果的代码应该检查越界情况：

```java
    if (left >= nums.length || nums[left] != target)
        return -1;
    return left;

```

至此，整个算法就写完了，完整代码如下：

```java
    int left_bound(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        // 搜索区间为 [left, right]
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                // 搜索区间变为 [mid+1, right]
                left = mid + 1;
            } else if (nums[mid] > target) {
                // 搜索区间变为 [left, mid-1]
                right = mid - 1;
            } else if (nums[mid] == target) {
                // 收缩右侧边界
                right = mid - 1;
            }
        }
        // 检查出界情况
        if (left >= nums.length || nums[left] != target)
            return -1;
        return left;
    }

```

这样就和第一种二分搜索算法统一了，都是两端都闭的「搜索区间」，而且最后返回的也是 ` left `变量的值。只要把住二分搜索的逻辑，两种形式大家看自己喜欢哪种记哪种吧。

### 三、寻找右侧边界的二分查找

类似寻找左侧边界的算法，这里也会提供两种写法，还是先写常见的左闭右开的写法，只有两处和搜索左侧边界不同，已标注：

```java
    int right_bound(int[] nums, int target) {
        if (nums.length == 0) return -1;
        int left = 0, right = nums.length;
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                left = mid + 1; // 注意
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid;
            }
        }
        return left - 1; // 注意
    }

```

**1、为什么这个算法能够找到右侧边界** ？

答：类似地，关键点还是这里：

```java
    if (nums[mid] == target) {
        left = mid + 1;

```

当 ` nums[mid] == target ` 时，不要立即返回，而是增大「搜索区间」的下界 ` left `，使得区间不断向右收缩，达到锁定右侧边界的目的。

**2、为什么最后返回` left - 1 ` 而不像左侧边界的函数，返回 ` left ` ？而且我觉得这里既然是搜索右侧边界，应该返回 ` right
` 才对 ** 。

答：首先，while 循环的终止条件是 ` left == right ` ，所以 ` left ` 和 ` right `是一样的，你非要体现右侧的特点，返回 ` right - 1 ` 好了。

至于为什么要减一，这是搜索右侧边界的一个特殊点，关键在这个条件判断：

```java
    if (nums[mid] == target) {
        left = mid + 1;
        // 这样想: mid = left - 1

```

![](https://labuladong.gitee.io/algo/images/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/3.jpg)

因为我们对 ` left ` 的更新必须是 ` left = mid + 1 ` ，就是说 while 循环结束时， ` nums[left] `一定不等于 ` target ` 了，而 ` nums[left-1] ` 可能是 ` target ` 。

至于为什么 ` left ` 的更新必须是 ` left = mid + 1 ` ，同左侧边界搜索，就不再赘述。

**3、为什么没有返回 -1 的操作？如果` nums ` 中不存在 ` target ` 这个值，怎么办 ** ？

答：类似之前的左侧边界搜索，因为 while 的终止条件是 ` left == right ` ，就是说 ` left ` 的取值范围是 ` [0, nums.length] ` ，所以可以添加两行代码，正确地返回 -1：

```java
    while (left < right) {
        // ...
    }
    if (left == 0) return -1;
    return nums[left-1] == target ? (left-1) : -1;

```

**4、是否也可以把这个算法的「搜索区间」也统一成两端都闭的形式呢？这样这三个写法就完全统一了，以后就可以闭着眼睛写出来了** 。

答：当然可以，类似搜索左侧边界的统一写法，其实只要改两个地方就行了：

```java
    int right_bound(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            } else if (nums[mid] == target) {
                // 这里改成收缩左侧边界即可
                left = mid + 1;
            }
        }
        // 这里改为检查 right 越界的情况，见下图
        if (right < 0 || nums[right] != target)
            return -1;
        return right;
    }

```

当 ` target ` 比所有元素都小时， ` right ` 会被减到 -1，所以需要在最后防止越界：

![](https://labuladong.gitee.io/algo/images/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/4.jpg)

至此，搜索右侧边界的二分查找的两种写法也完成了，其实将「搜索区间」统一成两端都闭反而更容易记忆，你说是吧？

### 四、逻辑统一

来梳理一下这些细节差异的因果逻辑：

**第一个，最基本的二分查找算法** ：

```java
    因为我们初始化 right = nums.length - 1
    所以决定了我们的「搜索区间」是 [left, right]
    所以决定了 while (left <= right)
    同时也决定了 left = mid+1 和 right = mid-1
    
    因为我们只需找到一个 target 的索引即可
    所以当 nums[mid] == target 时可以立即返回

```

**第二个，寻找左侧边界的二分查找** ：

```java
    因为我们初始化 right = nums.length
    所以决定了我们的「搜索区间」是 [left, right)
    所以决定了 while (left < right)
    同时也决定了 left = mid + 1 和 right = mid
    
    因为我们需找到 target 的最左侧索引
    所以当 nums[mid] == target 时不要立即返回
    而要收紧右侧边界以锁定左侧边界

```

**第三个，寻找右侧边界的二分查找** ：

```java
    因为我们初始化 right = nums.length
    所以决定了我们的「搜索区间」是 [left, right)
    所以决定了 while (left < right)
    同时也决定了 left = mid + 1 和 right = mid
    
    因为我们需找到 target 的最右侧索引
    所以当 nums[mid] == target 时不要立即返回
    而要收紧左侧边界以锁定右侧边界
    
    又因为收紧左侧边界时必须 left = mid + 1
    所以最后无论返回 left 还是 right，必须减一

```

对于寻找左右边界的二分搜索，常见的手法是使用左闭右开的「搜索区间」，
**我们还根据逻辑将「搜索区间」全都统一成了两端都闭，便于记忆，只要修改两处即可变化出三种写法** ：

```java
    int binary_search(int[] nums, int target) {
        int left = 0, right = nums.length - 1; 
        while(left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1; 
            } else if(nums[mid] == target) {
                // 直接返回
                return mid;
            }
        }
        // 直接返回
        return -1;
    }
    
    int left_bound(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            } else if (nums[mid] == target) {
                // 别返回，锁定左侧边界
                right = mid - 1;
            }
        }
        // 最后要检查 left 越界的情况
        if (left >= nums.length || nums[left] != target)
            return -1;
        return left;
    }
    
    int right_bound(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            } else if (nums[mid] == target) {
                // 别返回，锁定右侧边界
                left = mid + 1;
            }
        }
        // 最后要检查 right 越界的情况
        if (right < 0 || nums[right] != target)
            return -1;
        return right;
    }

```

如果以上内容你都能理解，那么恭喜你，二分查找算法的细节不过如此。

通过本文，你学会了：

1、分析二分查找代码时，不要出现 else，全部展开成 else if 方便理解。

2、注意「搜索区间」和 while 的终止条件，如果存在漏掉的元素，记得在最后检查。

3、如需定义左闭右开的「搜索区间」搜索左右边界，只要在 ` nums[mid] == target ` 时做修改即可，搜索右侧时需要减一。

4、如果将「搜索区间」全都统一成两端都闭，好记，只要稍改 ` nums[mid] == target ` 条件处的代码和返回的逻辑即可，
**推荐拿小本本记下，作为二分搜索模板** 。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


## 二分搜索怎么用？我又总结了套路


读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 875. 爱吃香蕉的珂珂（中等） ](https://leetcode-cn.com/problems/koko-eating-bananas/)

[ 1011. 在D天内送达包裹的能力（中等） ](https://leetcode-cn.com/problems/capacity-to-ship-
packages-within-d-days/)

**———–**

我们前文 [ 我写了首诗，把二分搜索变成了默写题 ](https://labuladong.gitee.io/algo/2/20/57/)详细介绍了二分搜索的细节问题，探讨了「搜索一个元素」，「搜索左侧边界」，「搜索右侧边界」这三个情况，教你如何写出正确无 bug 的二分搜索算法。

**但是前文总结的二分搜索代码框架仅仅局限于「在有序数组中搜索指定元素」这个基本场景，具体的算法问题没有这么直接，可能你都很难看出这个问题能够用到二分搜索**。

对于二分搜索算法在具体问题中的运用，前文 [ 二分搜索的运用（一） ](https://labuladong.gitee.io/algo/2/20/58/) 和前文 [ 二分搜索的运用（二）](https://labuladong.gitee.io/algo/2/20/59/) 有过介绍，但是还没有抽象出来一个具体的套路框架。

所以本文就来总结一套二分搜索算法运用的框架套路，帮你在遇到二分搜索算法相关的实际问题时，能够有条理地思考分析，步步为营，写出答案。

警告：本文略长略硬核，建议清醒时学习。

### 原始的二分搜索代码

二分搜索的原型就是在「 **有序数组** 」中搜索一个元素 ` target ` ，返回该元素对应的索引。

如果该元素不存在，那可以返回一个什么特殊值，这种细节问题只要微调算法实现就可实现。

还有一个重要的问题，如果「 **有序数组** 」中存在多个 ` target ` 元素，那么这些元素肯定挨在一起，这里就涉及到算法应该返回最左侧的那个 `target ` 元素的索引还是最右侧的那个 ` target `元素的索引，也就是所谓的「搜索左侧边界」和「搜索右侧边界」，这个也可以通过微调算法的代码来实现。

**我们前文[ 我写了首诗，把二分搜索变成了默写题 ](https://labuladong.gitee.io/algo/2/20/57/) 详细探讨了上述问题，对这块还不清楚的读者建议复习前文 **，已经搞清楚基本二分搜索算法的读者可以继续看下去。

**在具体的算法问题中，常用到的是「搜索左侧边界」和「搜索右侧边界」这两种场景** ，很少有让你单独「搜索一个元素」。

因为算法题一般都让你求最值，比如前文 [ 二分搜索的运用（一） ](https://labuladong.gitee.io/algo/2/20/58/)中说的例题让你求吃香蕉的「最小速度」，让你求轮船的「最低运载能力」，前文 [ 二分搜索的运用（二） ](https://labuladong.gitee.io/algo/2/20/59/)讲的题就更魔幻了，让你使每个子数组之和的「最大值最小」。

求最值的过程，必然是搜索一个边界的过程，所以后面我们就详细分析一下这两种搜索边界的二分算法代码。

「搜索左侧边界」的二分搜索算法的具体代码实现如下：

```java
    // 搜索左侧边界
    int left_bound(int[] nums, int target) {
        if (nums.length == 0) return -1;
        int left = 0, right = nums.length;
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                // 当找到 target 时，收缩右侧边界
                right = mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid;
            }
        }
        return left;
    }

```

假设输入的数组 ` nums = [1,2,3,3,3,5,7] ` ，想搜索的元素 ` target = 3 ` ，那么算法就会返回索引 2。

如果画一个图，就是这样：

![](https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%88%86%e8%bf%90%e7%94%a8/1.jpeg)

「搜索右侧边界」的二分搜索算法的具体代码实现如下：

```java
    // 搜索右侧边界
    int right_bound(int[] nums, int target) {
        if (nums.length == 0) return -1;
        int left = 0, right = nums.length;
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                // 当找到 target 时，收缩左侧边界
                left = mid + 1;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid;
            }
        }
        return left - 1;
    }

```

输入同上，那么算法就会返回索引 4，如果画一个图，就是这样：

![](https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%88%86%e8%bf%90%e7%94%a8/2.jpeg)

好，上述内容都属于复习，我想读到这里的读者应该都能理解。记住上述的图像，所有能够抽象出上述图像的问题，都可以使用二分搜索解决。

### 二分搜索问题的泛化

什么问题可以运用二分搜索算法技巧？

**首先，你要从题目中抽象出一个自变量` x ` ，一个关于 ` x ` 的函数 ` f(x) ` ，以及一个目标值 ` target ` ** 。

同时， ` x, f(x), target ` 还要满足以下条件：

**1、` f(x) ` 必须是在 ` x ` 上的单调函数（单调增单调减都可以） ** 。

**2、题目是让你计算满足约束条件` f(x) == target ` 时的 ` x ` 的值 ** 。

上述规则听起来有点抽象，来举个具体的例子：

给你一个升序排列的有序数组 ` nums ` 以及一个目标元素 ` target ` ，请你计算 ` target `在数组中的索引位置，如果有多个目标元素，返回最小的索引。

这就是「搜索左侧边界」这个基本题型，解法代码之前都写了，但这里面 ` x, f(x), target ` 分别是什么呢？

我们可以把数组中元素的索引认为是自变量 ` x ` ，函数关系 ` f(x) ` 就可以这样设定：

```java
    // 函数 f(x) 是关于自变量 x 的单调递增函数
    // 入参 nums 是不会改变的，所以可以忽略，不算自变量
    int f(int x, int[] nums) {
        return nums[x];
    }

```

其实这个函数 ` f ` 就是在访问数组 ` nums ` ，因为题目给我们的数组 ` nums ` 是升序排列的，所以函数 ` f(x) ` 就是在 `x ` 上单调递增的函数。

最后，题目让我们求什么来着？是不是让我们计算元素 ` target ` 的最左侧索引？

是不是就相当于在问我们「满足 ` f(x) == target ` 的 ` x ` 的最小值是多少」？

画个图，如下：

![](https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%88%86%e8%bf%90%e7%94%a8/3.jpeg)

**如果遇到一个算法问题，能够把它抽象成这幅图，就可以对它运用二分搜索算法** 。

算法代码如下：

```java
    // 函数 f 是关于自变量 x 的单调递增函数
    int f(int x, int[] nums) {
        return nums[x];
    }
    
    int left_bound(int[] nums, int target) {
        if (nums.length == 0) return -1;
        int left = 0, right = nums.length;
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (f(mid, nums) == target) {
                // 当找到 target 时，收缩右侧边界
                right = mid;
            } else if (f(mid, nums) < target) {
                left = mid + 1;
            } else if (f(mid, nums) > target) {
                right = mid;
            }
        }
        return left;
    }

```

这段代码把之前的代码微调了一下，把直接访问 ` nums[mid] ` 套了一层函数 ` f `，其实就是多此一举，但是，这样能抽象出二分搜索思想在具体算法问题中的框架。

### 运用二分搜索的套路框架

想要运用二分搜索解决具体的算法问题，可以从以下代码框架着手思考：

```java
    // 函数 f 是关于自变量 x 的单调函数
    int f(int x) {
        // ...
    }
    
    // 主函数，在 f(x) == target 的约束下求 x 的最值
    int solution(int[] nums, int target) {
        if (nums.length == 0) return -1;
        // 问自己：自变量 x 的最小值是多少？
        int left = ...;
        // 问自己：自变量 x 的最大值是多少？
        int right = ... + 1;
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (f(mid) == target) {
                // 问自己：题目是求左边界还是右边界？
                // ...
            } else if (f(mid) < target) {
                // 问自己：怎么让 f(x) 大一点？
                // ...
            } else if (f(mid) > target) {
                // 问自己：怎么让 f(x) 小一点？
                // ...
            }
        }
        return left;
    }

```

具体来说，想要用二分搜索算法解决问题，分为以下几步：

**1、确定` x, f(x), target ` 分别是什么，并写出函数 ` f ` 的代码 ** 。

**2、找到` x ` 的取值范围作为二分搜索的搜索区间，初始化 ` left ` 和 ` right ` 变量 ** 。

**3、根据题目的要求，确定应该使用搜索左侧还是搜索右侧的二分搜索算法，写出解法代码** 。

下面用几道例题来讲解这个流程。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**

应合作方要求，本文不便在此发布，请扫码关注回复关键词「二分」查看：

![](https://labuladong.gitee.io/algo/images/qrcode.jpg)

## 我和快手面试官对二分搜索进行了深度探讨


读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 410. 分割数组的最大值（困难） ](https://leetcode-cn.com/problems/split-array-largest-
sum/)

**———–**

经常有读者问我，读了之前的爆文 [ 二分查找框架详解 ](https://labuladong.gitee.io/algo/2/20/57/)之后，二分查找的算法他写的很溜了，但仅仅局限于在数组中搜索元素，不知道底怎么在算法题里面运用二分查找技巧来优化效率。

**那我先说结论，你想用二分查找技巧优化算法，首先要把 for 循环形式的暴力算法写出来，如果算法中存在如下形式的 for 循环** ：

```java
    // func(i) 是 i 的单调函数（递增递减都可以）
    int func(int i);
    
    // 形如这种 for 循环可以用二分查找技巧优化效率
    for (int i = 0; i < n; i++) {
        if (func(i) == target)
            return i;
    }

```

**如果` func(i) ` 函数是在 ` i ` 上单调的函数，一定可以使用二分查找技巧优化 for 循环 ** 。

「在 ` i ` 上单调的函数」是指 ` func(i) ` 的返回值随着 ` i ` 的增加而增加，或者随着 ` i ` 的增加而减小。

为什么满足这个条件就可以使用二分查找？ **因为这个逻辑和「在有序数组中查找一个元素」是完全一样的呀** ！

在 **有序数组** ` nums ` 中查找某一个数 ` target ` ，是不是最简单二分查找形式？我们看下普通的 for 循环遍历算法：

```java
    // nums 是一个有序数组
    int[] nums;
    // target 是要搜索的元素
    int target;
    
    // 搜索 target 在 nums 中的索引
    for (int i = 0; i < nums.length; i++) {
        if (nums[i] == target)
            return i;
    }

```

既然 ` nums ` 是有序数组，你把 ` nums[i] ` 看做函数调用，是不是可以理解为 ` nums ` 在参数 ` i `上是单调的？这是不是和之前说的 ` func(i) ` 函数完全一样？

当然，前文 [ 二分查找框架详解 ](https://labuladong.gitee.io/algo/2/20/57/) 说过，二分查找算法还有搜索左侧、右侧边界的变体，怎么运用到具体算法问题中呢？

还是注意观察 for 循环形式，只是不一定是 ` func(i) == target ` 作为终止条件，可能是 ` <= ` 或者 ` >= `的关系，这个可以根据具体的题目意思来推断，我们实操一下力扣第 410 题「分割数组的最大值」，难度 **Hard** ：

![](https://labuladong.gitee.io/algo/images/%e5%88%86%e5%89%b2%e6%95%b0%e7%bb%84/title.png)

函数签名如下：

```java
    int splitArray(int[] nums, int m);

```

这个题目有点类似前文一道经典动态规划题目 [ 高楼扔鸡蛋 ](https://labuladong.gitee.io/algo/3/25/89/) ，题目比较绕，又是最大值又是最小值的。

简单说，给你输入一个数组 ` nums ` 和数字 ` m ` ，你要把 ` nums ` 分割成 ` m ` 个子数组。

肯定有不止一种分割方法，每种分割方法都会把 ` nums ` 分成 ` m ` 个子数组，这 ` m ` 个子数组中肯定有一个和最大的子数组对吧。

我们想要找一个分割方法，该方法分割出的最大子数组和是所有方法中最大子数组和最小的。

请你的算法返回这个分割方法对应的最大子数组和。

我滴妈呀，这个题目看了就觉得 Hard，完全没思路，这题怎么能和二分查找算法扯上关系？

说个小插曲，快手面试有一道画师画画的算法题，很难，就是以这道题为原型。当时我没做过这道力扣题，面试有点懵，不过之前文章 [ 二分查找算法运用](https://labuladong.gitee.io/algo/2/20/58/) 写了两道类似的比较简单的题目，外加面试官的提示，把那道题做出来了。

**面试做算法题的时候，题目一般都会要求算法的时间复杂度，如果你发现 O(NlogN)这样存在对数的复杂度，一般都要往二分查找的方向上靠，这也算是个小套路** 。

言归正传，如何解决这道数组分割的问题？

首先，一个拍脑袋的思路就是用 [ 回溯算法框架 ](https://labuladong.gitee.io/algo/4/28/105/) 暴力穷举呗，我简单说下思路：

你不是要我把 ` nums ` 分割成 ` m `个子数组，然后计算巴拉巴拉又是最大又是最小的那个最值吗？那我把所有分割方案都穷举出来，那个最值肯定可以算出来对吧？

怎么穷举呢？把 ` nums ` 分割成 ` m ` 个子数组，相当于在 ` len(nums) ` 个元素的序列中切 ` m - 1 `刀，对于每两个元素之间的间隙，我们都有两种「选择」，切一刀，或者不切。

你看，这不就是标准的回溯暴力穷举思路嘛，我们根据穷举结果去计算每种方案的最大子数组和，肯定可以算出答案。

但是回溯的缺点就是复杂度很高，我们刚才说的思路其实就是「组合」嘛，时间复杂度就是组合公式：

![](https://labuladong.gitee.io/algo/images/%e5%88%86%e5%89%b2%e6%95%b0%e7%bb%84/formula.png)

时间复杂度其实是非常高的，所以回溯算法不是一个好的思路，还是得上二分查找技巧，反向思考这道题。

**现在题目是固定了` m ` 的值，让我们确定一个最大子数组和；所谓反向思考就是说，我们可以反过来，限制一个最大子数组和 ` max `，来反推最大子数组和为 ` max ` 时，至少可以将 ` nums ` 分割成几个子数组 ** 。

比如说我们可以写这样一个 ` split ` 函数：

```java
    // 在每个子数组和不超过 max 的条件下，
    // 计算 nums 至少可以分割成几个子数组
    int split(int[] nums, int max);

```

比如说 ` nums = [7,2,5,10] ` ，若限制 ` max = 10 ` ，则 ` split ` 函数返回 3，即 ` nums `数组最少能分割成三个子数组，分别是 ` [7,2],[5],[10] ` 。

那如果我们找到一个最小 ` max ` 值，满足 ` split(nums, max) ` 和 ` m ` 相等，那么这个 ` max `值不就是符合题意的「最小的最大子数组和」吗？

现在就简单了，我们只要对 ` max ` 进行穷举就行，那么最大子数组和 ` max ` 的取值范围是什么呢？

显然，子数组至少包含一个元素，至多包含整个数组，所以「最大」子数组和的取值范围就是闭区间 ` [max(nums), sum(nums)] `，也就是最大元素值到整个数组和之间。

那么，我们就可以写出如下代码：

```java
    /* 主函数，计算最大子数组和 */
    int splitArray(int[] nums, int m) {
        int lo = getMax(nums), hi = getSum(nums);
        for (int max = lo; max <= hi; max++) {
            // 如果最大子数组和是 max，
            // 至少可以把 nums 分割成 n 个子数组
            int n = split(nums, max);
            // 为什么是 <= 不是 == ？
            if (n <= m) {
                return max;
            }
        }
        
        return -1;
    }
    
    /* 辅助函数，若限制最大子数组和为 max，
    计算 nums 至少可以被分割成几个子数组 */
    int split(int[] nums, int max) {
        // 至少可以分割的子数组数量
        int count = 1;
        // 记录每个子数组的元素和
        int sum = 0;
        for (int i = 0; i < nums.length; i++) {
            if (sum + nums[i] > max) {
                // 如果当前子数组和大于 max 限制
                // 则这个子数组不能再添加元素了
                count++;
                sum = nums[i];
            } else {
                // 当前子数组和还没达到 max 限制
                // 还可以添加元素
                sum += nums[i];
            }
        }
        return count;
    }
    
    // 计算数组中的最大值
    int getMax(int[] nums) {
        int res = 0;
        for (int n : nums)
            res = Math.max(n, res);
        return res;
    }
    
    // 计算数组元素和
    int getSum(int[] nums) {
        int res = 0;
        for (int n : nums)
            res += n;
        return res;
    }

```

这段代码有两个关键问题：

**1、对` max ` 变量的穷举是从 ` lo ` 到 ` hi ` 即从小到大的 ** 。

这是因为我们求的是「最大子数组和」的「最小值」，且 ` split ` 函数的返回值有单调性，所以从小到大遍历，第一个满足条件的值就是「最小值」。

**2、函数返回的条件是` n <= m ` ，而不是 ` n == m ` ** 。按照之前的思路，应该 ` n == m ` 才对吧？

其实， ` split ` 函数采用了贪心的策略，计算的是 ` max ` 限制下 **至少** 能够将 ` nums ` 分割成几个子数组。

举个例子，输入 ` nums = [2,1,1], m = 3 ` ，显然分割方法只有一种，即每个元素都认为是一个子数组，最大子数组和为 2。

但是，我们的算法会在区间 ` [2,4] ` 穷举 ` max ` ，当 ` max = 2 ` 时， ` split ` 会算出 ` nums `**至少** 可以被分割成 ` n = 2 ` 个子数组 ` [2] ` 和 ` [1,1] ` 。

当 ` max = 3 ` 时算出 ` n = 2 ` ，当 ` max = 4 ` 时算出 ` n = 1 ` ，显然都是小于 ` m = 3 ` 的。

所以我们不能用 ` n == m ` 而必须用 ` n <= m ` 来找到答案， **因为如果你能把` nums ` 分割成 2 个子数组（ `[2],[1,1] ` ），那么肯定也可以分割成 3 个子数组（ ` [2],[1],[1] ` ） ** 。

好了，现在 for 循环的暴力算法已经写完了，但是无法通过力扣的判题系统，会超时。

由于 ` split ` 是单调函数，且符合二分查找技巧进行优化的标志，所以可以试图改造成二分查找。

那么应该使用搜索左侧边界的二分查找，还是搜索右侧边界的二分查找呢？这个还是要看我们的算法逻辑：

```java
    int lo = getMax(nums), hi = getSum(nums);
    for (int max = lo; max <= hi; max++) {
        int n = split(nums, max);
        if (n <= m) {
            return max;
        }
    }

```

可能存在多个 ` max ` 使得 ` split(nums, max) ` 算出相同的 ` n ` ， **因为我们的算法会返回最小的那个` max `，所以应该使用搜索左侧边界的二分查找算法 ** 。

现在，问题变为：在闭区间 ` [lo, hi] ` 中搜索一个最小的 ` max ` ，使得 ` split(nums, max) ` 恰好等于 ` m `。

那么，我们就可以直接套用搜索左侧边界的二分搜索框架改写代码：

```java
    int splitArray(int[] nums, int m) {
        // 一般搜索区间是左闭右开的，所以 hi 要额外加一
        int lo = getMax(nums), hi = getSum(nums) + 1;
        while (lo < hi) {
            int mid = lo + (hi - lo) / 2;
            // 根据分割子数组的个数收缩搜索区间
            int n = split(nums, mid);
            if (n == m) {
                // 收缩右边界，达到搜索左边界的目的
                hi = mid;
            } else if (n < m) {
                // 最大子数组和上限高了，减小一些
                hi = mid;
            } else if (n > m) {
                // 最大子数组和上限低了，增加一些
                lo = mid + 1;
            }
        }
        return lo;
    }
    
    int split(int[] nums, int max) {/* 见上文 */}
    int getMax(int[] nums) {/* 见上文 */}
    int getSum(int[] nums) {/* 见上文 */}

```

这段二分搜索的代码就是标准的搜索左侧边界的代码框架，如果不理解可以参见前文 [ 二分查找框架详解 ](https://labuladong.gitee.io/algo/2/20/57/)
，这里就不展开了。

至此，这道题就通过二分查找技巧高效解决了。假设 ` nums ` 元素个数为 ` N ` ，元素和为 ` S ` ，则 ` split ` 函数的复杂度为
` O(N) ` ，二分查找的复杂度为 ` O(logS) ` ，所以算法的总时间复杂度为 ` O(N*logS) ` 。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


## 田忌赛马背后的算法决策


读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 870. 优势洗牌（中等） ](https://leetcode-cn.com/problems/advantage-shuffle)

**———–**

田忌赛马的故事大家应该都听说过：

田忌和齐王赛马，两人的马分上中下三等，如果同等级的马对应着比赛，田忌赢不了齐王。但是田忌遇到了孙膑，孙膑就教他用自己的下等马对齐王的上等马，再用自己的上等马对齐王的中等马，最后用自己的中等马对齐王的下等马，结果三局两胜，田忌赢了。

当然，这段历史也挺有意思的，那个讽齐王纳谏，自恋的不行的邹忌和田忌是同一时期的人，他俩后来就杠上了。不过这是题外话，我们这里就打住。

以前学到田忌赛马课文的时，我就在想，如果不是三匹马比赛，而是一百匹马比赛，孙膑还能不能合理地安排比赛的顺序，赢得齐王呢？

当时没想出什么好的点子，只觉得这里面最核心问题是要尽可能让自己占便宜，让对方吃亏。总结来说就是， **打得过就打，打不过就拿自己的垃圾和对方的精锐互换**。

不过，我一直没具体把这个思路实现出来，直到最近刷到力扣第 870 题「优势洗牌」，一眼就发现这是田忌赛马问题的加强版：

给你输入两个 **长度相等** 的数组 ` nums1 ` 和 ` nums2 ` ，请你重新组织 ` nums1 ` 中元素的位置，使得 ` nums1
` 的「优势」最大化。

如果 ` nums1[i] > nums2[i] ` ，就是说 ` nums1 ` 在索引 ` i ` 上对 ` nums2[i] `有「优势」。优势最大化也就是说让你重新组织 ` nums1 ` ， **尽可能多的让` nums[i] > nums2[i] ` ** 。

算法签名如下：

```java
    int[] advantageCount(int[] nums1, int[] nums2);

```

比如输入：

` nums1 = [12,24,8,32] ` ` nums2 = [13,25,32,11] `
你的算法应该返回 ` [24,32,8,12] ` ，因为这样排列 ` nums1 ` 的话有三个元素都有「优势」。

**这就像田忌赛马的情景，` nums1 ` 就是田忌的马， ` nums2 ` 就是齐王的马，数组中的元素就是马的战斗力，你就是孙膑，展示你真正的技术吧

** 。

仔细想想，这个题的解法还是有点扑朔迷离的。什么时候应该放弃抵抗去送人头，什么时候应该硬刚？这里面应该有一种算法策略来最大化「优势」。

送人头一定是迫不得已而为之的权宜之计，否则隔壁田忌就要开语音骂你菜了。只有田忌的上等马比不过齐王的上等马时，才会用下等马去和齐王的上等马互换。

对于比较复杂的问题，可以尝试从特殊情况考虑。

你想，谁应该去应对齐王最快的马？肯定是田忌最快的那匹马，我们简称一号选手。

**如果田忌的一号选手比不过齐王的一号选手**，那其他马肯定是白给了，显然这种情况肯定应该用田忌垫底的马去送人头，降低己方损失，保存实力，增加接下来比赛的胜率。

**但如果田忌的一号选手能比得过齐王的一号选手** ，那就和齐王硬刚好了，反正这把田忌可以赢。

你也许说，这种情况下说不定田忌的二号选手也能干得过齐王的一号选手？如果可以的话，让二号选手去对决齐王的一号选手，不是更节约？

就好比，如果考 60 分就能过的话，何必考 90 分？每多考一分就亏一分，刚刚好卡在 60 分是最划算的。

**这种节约的策略是没问题的，但是没有必要。这也是本题有趣的地方，需要绕个脑筋急转弯** ：

我们暂且把田忌的一号选手称为 ` T1 ` ，二号选手称为 ` T2 ` ，齐王的一号选手称为 ` Q1 ` 。

如果 ` T2 ` 能赢 ` Q1 ` ，你试图保存己方实力，让 ` T2 ` 去战 ` Q1 ` ，把 ` T1 ` 留着是为了对付谁？

显然，你担心齐王还有战力大于 ` T2 ` 的马，可以让 ` T1 ` 去对付。

但是你仔细想想，现在 ` T2 ` 已经是可以战胜 ` Q1 ` 的， ` Q1 ` 可是齐王的最快的马耶，齐王剩下的那些马里，怎么可能还有比 ` T2 `更强的马？

所以，没必要节约，最后我们得出的策略就是：

**将齐王和田忌的马按照战斗力排序，然后按照排名一一对比。如果田忌的马能赢，那就比赛，如果赢不了，那就换个垫底的来送人头，保存实力** 。

上述思路的代码逻辑如下：

```java
    int n = nums1.length;
    
    sort(nums1); // 田忌的马
    sort(nums2); // 齐王的马
    
    // 从最快的马开始比
    for (int i = n - 1; i >= 0; i--) {
        if (nums1[i] > nums2[i]) {
            // 比得过，跟他比
        } else {
            // 比不过，换个垫底的来送人头
        }
    }

```

根据这个思路，我们需要对两个数组排序，但是 ` nums2 ` 中元素的顺序不能改变，因为计算结果的顺序依赖 ` nums2 ` 的顺序，所以不能直接对 `nums2 ` 进行排序，而是利用其他数据结构来辅助。

同时，最终的解法还用到前文 [ 双指针技巧汇总 ](https://labuladong.gitee.io/algo/2/20/55/) 总结的双指针算法模板，用以处理「送人头」的情况：

```java
    int[] advantageCount(int[] nums1, int[] nums2) {
        int n = nums1.length;
        // 给 nums2 降序排序
        PriorityQueue<int[]> maxpq = new PriorityQueue<>(
            (int[] pair1, int[] pair2) -> { 
                return pair2[1] - pair1[1];
            }
        );
        for (int i = 0; i < n; i++) {
            maxpq.offer(new int[]{i, nums2[i]});
        }
        // 给 nums1 升序排序
        Arrays.sort(nums1);
    
        // nums1[left] 是最小值，nums1[right] 是最大值
        int left = 0, right = n - 1;
        int[] res = new int[n];
    
        while (!maxpq.isEmpty()) {
            int[] pair = maxpq.poll();
            // maxval 是 nums2 中的最大值，i 是对应索引
            int i = pair[0], maxval = pair[1];
            if (maxval < nums1[right]) {
                // 如果 nums1[right] 能胜过 maxval，那就自己上
                res[i] = nums1[right];
                right--;
            } else {
                // 否则用最小值混一下，养精蓄锐
                res[i] = nums1[left];
                left++;
            }
        }
        return res;
    }

```

算法的时间复杂度很好分析，也就是二叉堆和排序的复杂度 ` O(nlogn) ` 。

至此，这道田忌赛马的题就解决了，其代码实现上用到了双指针技巧，从最快的马开始，比得过就比，比不过就送，这样就能对任意数量的马求取一个最优的比赛策略了。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


## 给我常数时间，我可以删除/查找数组中的任意元素


读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 380. 常数时间插入、删除和获取随机元素（中等） ](https://leetcode-cn.com/problems/insert-delete-
getrandom-o1)

[ 710. 黑名单中的随机数（困难） ](https://leetcode-cn.com/problems/random-pick-with-
blacklist)

**———–**

本文讲两道比较有技巧性的数据结构设计题，都是和随机读取元素相关的，我们前文 [ 水塘抽样算法 ](https://labuladong.gitee.io/algo/4/29/119/) 也写过类似的问题。

这写问题的一个技巧点在于，如何结合哈希表和数组，使得数组的删除操作时间复杂度也变成 O(1)？

下面来一道道看。

### 实现随机集合

这是力扣第 380 题，看下题目：

![](https://labuladong.gitee.io/algo/images/%e9%9a%8f%e6%9c%ba%e9%9b%86%e5%90%88/title.png)

就是说就是让我们实现如下一个类：

```java
    class RandomizedSet {
    public:
        /** 如果 val 不存在集合中，则插入并返回 true，否则直接返回 false */
         bool insert(int val) {}
        
        /** 如果 val 在集合中，则删除并返回 true，否则直接返回 false */
        bool remove(int val) {}
        
        /** 从集合中等概率地随机获得一个元素 */
        int getRandom() {}
    }

```

本题的难点在于两点：

**1、插入，删除，获取随机元素这三个操作的时间复杂度必须都是 O(1)** 。

**2、` getRandom ` 方法返回的元素必须等概率返回随机元素 ** ，也就是说，如果集合里面有 ` n ` 个元素，每个元素被返回的概率必须是
` 1/n ` 。

我们先来分析一下：对于插入，删除，查找这几个操作，哪种数据结构的时间复杂度是 O(1)？

` HashSet `肯定算一个对吧。哈希集合的底层原理就是一个大数组，我们把元素通过哈希函数映射到一个索引上；如果用拉链法解决哈希冲突，那么这个索引可能连着一个链表或者红黑树。

那么请问对于这样一个标准的 ` HashSet ` ，你能否在 O(1) 的时间内实现 ` getRandom ` 函数？

其实是不能的，因为根据刚才说到的底层实现，元素是被哈希函数「分散」到整个数组里面的，更别说还有拉链法等等解决哈希冲突的机制，基本做不到 O(1)时间等概率随机获取元素。

除了 ` HashSet ` ，还有一些类似的数据结构，比如哈希链表 ` LinkedHashSet ` ，我们前文 [ 手把手实现LRU算法](https://labuladong.gitee.io/algo/2/19/43/) 和 [ 手把手实现LFU算法 ](https://labuladong.gitee.io/algo/2/19/44/)讲过这类数据结构的实现原理，本质上就是哈希表配合双链表，元素存储在双链表中。

但是， ` LinkedHashSet ` 只是给 ` HashSet ` 增加了有序性，依然无法按要求实现我们的 ` getRandom `函数，因为底层用链表结构存储元素的话，是无法在 O(1) 的时间内访问某一个元素的。

根据上面的分析，对于 ` getRandom ` 方法，如果想「等概率」且「在 O(1) 的时间」取出元素，一定要满足：
**底层用数组实现，且数组必须是紧凑的** 。

这样我们就可以直接生成随机数作为索引，从数组中取出该随机索引对应的元素，作为随机元素。

**但如果用数组存储元素的话，插入，删除的时间复杂度怎么可能是 O(1) 呢** ？

可以做到！对数组尾部进行插入和删除操作不会涉及数据搬移，时间复杂度是 O(1)。

**所以，如果我们想在 O(1) 的时间删除数组中的某一个元素` val ` ，可以先把这个元素交换到数组的尾部，然后再 ` pop ` 掉 ** 。

交换两个元素必须通过索引进行交换对吧，那么我们需要一个哈希表 ` valToIndex ` 来记录每个元素值对应的索引。

有了思路铺垫，我们直接看代码：

```java
    class RandomizedSet {
    public:
        // 存储元素的值
        vector<int> nums;
        // 记录每个元素对应在 nums 中的索引
        unordered_map<int,int> valToIndex;
        
        bool insert(int val) {
            // 若 val 已存在，不用再插入
            if (valToIndex.count(val)) {
                return false;
            }
            // 若 val 不存在，插入到 nums 尾部，
            // 并记录 val 对应的索引值
            valToIndex[val] = nums.size();
            nums.push_back(val);
            return true;
        }
         
        bool remove(int val) {
            // 若 val 不存在，不用再删除
            if (!valToIndex.count(val)) {
                return false;
            }
            // 先拿到 val 的索引
            int index = valToIndex[val];
            // 将最后一个元素对应的索引修改为 index
            valToIndex[nums.back()] = index;
            // 交换 val 和最后一个元素
            swap(nums[index], nums.back());
            // 在数组中删除元素 val
            nums.pop_back();
            // 删除元素 val 对应的索引
            valToIndex.erase(val);
            return true;
        }
        
        int getRandom() {
            // 随机获取 nums 中的一个元素
            return nums[rand() % nums.size()];
        }
    };

```

注意 ` remove(val) ` 函数，对 ` nums ` 进行插入、删除、交换时，都要记得修改哈希表 ` valToIndex `，否则会出现错误。

至此，这道题就解决了，每个操作的复杂度都是 O(1)，且随机抽取的元素概率是相等的。

### 避开黑名单的随机数

有了上面一道题的铺垫，我们来看一道更难一些的题目，力扣第 710 题，我来描述一下题目：

给你输入一个正整数 ` N ` ，代表左闭右开区间 ` [0,N) ` ，再给你输入一个数组 ` blacklist ` ，其中包含一些「黑名单数字」，且
` blacklist ` 中的数字都是区间 ` [0,N) ` 中的数字。

现在要求你设计如下数据结构：

```java
    class Solution {
    public:
        // 构造函数，输入参数
        Solution(int N, vector<int>& blacklist) {}
        
        // 在区间 [0,N) 中等概率随机选取一个元素并返回
        // 这个元素不能是 blacklist 中的元素
        int pick() {}
    };

```

` pick ` 函数会被多次调用，每次调用都要在区间 ` [0,N) ` 中「等概率随机」返回一个「不在 ` blacklist ` 中」的整数。

这应该不难理解吧，比如给你输入 ` N = 5, blacklist = [1,3] ` ，那么多次调用 ` pick ` 函数，会等概率随机返回 0, 2, 4 中的某一个数字。

**而且题目要求，在` pick ` 函数中应该尽可能少调用随机数生成函数 ` rand() ` ** 。

这句话什么意思呢，比如说我们可能想出如下拍脑袋的解法：

```java
    int pick() {
        int res = rand() % N;
        while (res exists in blacklist) {
            // 重新随机一个结果
            res = rand() % N;
        }
        return res;
    }

```

这个函数会多次调用 ` rand() ` 函数，执行效率竟然和随机数相关，不是一个漂亮的解法。

**聪明的解法类似上一道题，我们可以将区间` [0,N) ` 看做一个数组，然后将 ` blacklist `中的元素移到数组的最末尾，同时用一个哈希表进行映射 ** ：

根据这个思路，我们可以写出第一版代码（还存在几处错误）：

```java
    class Solution {
    public:
        int sz;
        unordered_map<int, int> mapping;
        
        Solution(int N, vector<int>& blacklist) {
            // 最终数组中的元素个数
            sz = N - blacklist.size();
            // 最后一个元素的索引
            int last = N - 1;
            // 将黑名单中的索引换到最后去
            for (int b : blacklist) {
                mapping[b] = last;
                last--;
            }
        }
    };

```

![](https://labuladong.gitee.io/algo/images/%e9%9a%8f%e6%9c%ba%e9%9b%86%e5%90%88/1.jpeg)

如上图，相当于把黑名单中的数字都交换到了区间 ` [sz, N) ` 中，同时把 ` [0, sz) ` 中的黑名单数字映射到了正常数字。

根据这个逻辑，我们可以写出 ` pick ` 函数：

```java
    int pick() {
        // 随机选取一个索引
        int index = rand() % sz;
        // 这个索引命中了黑名单，
        // 需要被映射到其他位置
        if (mapping.count(index)) {
            return mapping[index];
        }
        // 若没命中黑名单，则直接返回
        return index;
    }

```

这个 ` pick ` 函数已经没有问题了，但是构造函数还有两个问题。

**第一个问题** ，如下这段代码：

```java
    int last = N - 1;
    // 将黑名单中的索引换到最后去
    for (int b : blacklist) {
        mapping[b] = last;
        last--;
    }

```

我们将黑名单中的 ` b ` 映射到 ` last ` ，但是我们能确定 ` last ` 不在 ` blacklist ` 中吗？

比如下图这种情况，我们的预期应该是 1 映射到 3，但是错误地映射到 4：

![](https://labuladong.gitee.io/algo/images/%e9%9a%8f%e6%9c%ba%e9%9b%86%e5%90%88/2.jpeg)

**在对` mapping[b] ` 赋值时，要保证 ` last ` 一定不在 ` blacklist ` 中 ** ，可以如下操作：

```java
    // 构造函数
    Solution(int N, vector<int>& blacklist) {
        sz = N - blacklist.size();
        // 先将所有黑名单数字加入 map
        for (int b : blacklist) { 
            // 这里赋值多少都可以
            // 目的仅仅是把键存进哈希表
            // 方便快速判断数字是否在黑名单内
            mapping[b] = 666;
        }
    
        int last = N - 1;
        for (int b : blacklist) {
            // 跳过所有黑名单中的数字
            while (mapping.count(last)) {
                last--;
            }
            // 将黑名单中的索引映射到合法数字
            mapping[b] = last;
            last--;
        }
    }

```

**第二个问题** ，如果 ` blacklist ` 中的黑名单数字本身就存在区间 ` [sz, N) ` 中，那么就没必要在 ` mapping `中建立映射，比如这种情况：

![](https://labuladong.gitee.io/algo/images/%e9%9a%8f%e6%9c%ba%e9%9b%86%e5%90%88/3.jpeg)

我们根本不用管 4，只希望把 1 映射到 3，但是按照 ` blacklist ` 的顺序，会把 4 映射到 3，显然是错误的。

我们可以稍微修改一下，写出正确的解法代码：

```java
    class Solution {
    public:
        int sz;
        unordered_map<int, int> mapping;
        
        Solution(int N, vector<int>& blacklist) {
            sz = N - blacklist.size();
            for (int b : blacklist) {
                mapping[b] = 666;
            }
    
            int last = N - 1;
            for (int b : blacklist) {
                // 如果 b 已经在区间 [sz, N)
                // 可以直接忽略
                if (b >= sz) {
                    continue;
                }
                while (mapping.count(last)) {
                    last--;
                }
                mapping[b] = last;
                last--;
            }
        }
    
        // 见上文代码实现
        int pick() {}
    };

```

至此，这道题也解决了，总结一下本文的核心思想：

1、如果想高效地，等概率地随机获取元素，就要使用数组作为底层容器。

2、如果要保持数组元素的紧凑性，可以把待删除元素换到最后，然后 ` pop ` 掉末尾的元素，这样时间复杂度就是 O(1)了。当然，我们需要额外的哈希表记录值到索引的映射。

3、对于第二题，数组中含有「空洞」（黑名单数字），也可以利用哈希表巧妙处理映射关系，让数组在逻辑上是紧凑的，方便随机取元素。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


## 一道数组去重的算法题把我整不会了


读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 316. 去除重复字母（中等） ](https://leetcode-cn.com/problems/remove-duplicate-letters)

[ 1081. 不同字符的最小子序列（中等） ](https://leetcode-cn.com/problems/smallest-
subsequence-of-distinct-characters)

**———–**

关于去重算法，应该没什么难度，往哈希集合里面塞不就行了么？

最多给你加点限制，问你怎么给有序数组原地去重，这个我们旧文 [ 如何高效地给有序数组/链表去重 ](https://labuladong.gitee.io/algo/4/29/120/) 。

本文讲的问题应该是去重相关算法中难度最大的了，把这个问题搞懂，就再也不用怕数组去重问题了。

这是力扣第 316 题「去除重复字母」，题目如下：

![](https://labuladong.gitee.io/algo/images/%e5%8d%95%e8%b0%83%e6%a0%88%e5%8e%bb%e9%87%8d/title.png)

这道题和第 1081 题「不同字符的最小子序列」的解法是完全相同的，你可以把这道题的解法代码直接粘过去把 1081 题也干掉。

题目的要求总结出来有三点：

要求一、 **要去重** 。

要求二、去重字符串中的字符顺序 **不能打乱` s ` 中字符出现的相对顺序 ** 。

要求三、在所有符合上一条要求的去重字符串中， **字典序最小** 的作为最终结果。

上述三条要求中，要求三可能有点难理解，举个例子。

比如说输入字符串 ` s = "babc" ` ，去重且符合相对位置的字符串有两个，分别是 ` "bac" ` 和 ` "abc" `，但是我们的算法得返回 ` "abc" ` ，因为它的字典序更小。

按理说，如果我们想要有序的结果，那就得对原字符串排序对吧，但是排序后就不能保证符合 ` s ` 中字符出现顺序了，这似乎是矛盾的。

其实这里会借鉴前文 [ 单调栈解题框架 ](https://labuladong.gitee.io/algo/2/19/48/) 中讲到的「单调栈」的思路，没看过也无妨，等会你就明白了。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**

应合作方要求，本文不便在此发布，请扫码关注回复关键词「单调栈」查看：

![](https://labuladong.gitee.io/algo/images/qrcode.jpg)

## 一文秒杀四道原地修改数组的算法题


读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 26. 删除有序数组中的重复项（简单） ](https://leetcode-cn.com/problems/remove-duplicates-
from-sorted-array/)

[ 83. 删除排序链表中的重复元素（简单） ](https://leetcode-cn.com/problems/remove-duplicates-
from-sorted-list/)

[ 27. 移除元素（简单） ](https://leetcode-cn.com/problems/remove-element/)

[ 283. 移动零（简单） ](https://leetcode-cn.com/problems/move-zeroes/)

**———–**

我们知道对于数组来说，在尾部插入、删除元素是比较高效的，时间复杂度是 O(1)，但是如果在中间或者开头插入、删除元素，就会涉及数据的搬移，时间复杂度为 O(N)，效率较低。

所以上篇文章 [ 常数时间删除/查找数组中的任意元素 ](https://labuladong.gitee.io/algo/2/20/61/)就讲了一种技巧，把待删除元素交换到最后一个，然后再删除，就可以避免数据搬移。

那么这篇文章我们换一个场景，来讲一讲如何在原地修改数组，避免数据的搬移。

### 有序数组/链表去重

先讲讲如何对一个有序数组去重，先看下题目：

![](https://labuladong.gitee.io/algo/images/%e6%95%b0%e7%bb%84%e5%8e%bb%e9%87%8d/title.png)

函数签名如下：

```java
    int removeDuplicates(int[] nums);

```

显然，由于数组已经排序，所以重复的元素一定连在一起，找出它们并不难，但如果毎找到一个重复元素就立即删除它，就是在数组中间进行删除操作，整个时间复杂度是会达到 O(N^2)。

简单解释一下什么是原地修改：

如果不是原地修改的话，我们直接 new 一个 ` int[] ` 数组，把去重之后的元素放进这个新数组中，然后返回这个新数组即可。

但是原地删除，不允许我们 new 新数组，只能在原数组上操作，然后返回一个长度，这样就可以通过返回的长度和原始数组得到我们去重后的元素有哪些了。

这种需求在数组相关的算法题中时非常常见的， **通用解法就是我们前文[ 双指针技巧 ](https://labuladong.gitee.io/algo/2/20/55/) 中的快慢指针技巧 ** 。

我们让慢指针 ` slow ` 走在后面，快指针 ` fast ` 走在前面探路，找到一个不重复的元素就告诉 ` slow ` 并让 ` slow `前进一步。这样当 ` fast ` 指针遍历完整个数组 ` nums ` 后， **` nums[0..slow] ` 就是不重复元素 ** 。

```java
    int removeDuplicates(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        int slow = 0, fast = 0;
        while (fast < nums.length) {
            if (nums[fast] != nums[slow]) {
                slow++;
                // 维护 nums[0..slow] 无重复
                nums[slow] = nums[fast];
            }
            fast++;
        }
        // 数组长度为索引 + 1
        return slow + 1;
    }

```

看下算法执行的过程：

![](https://labuladong.gitee.io/algo/images/%e6%95%b0%e7%bb%84%e5%8e%bb%e9%87%8d/1.gif)

再简单扩展一下，如果给你一个有序链表，如何去重呢？这是力扣第 83 题，其实和数组去重是一模一样的，唯一的区别是把数组赋值操作变成操作指针而已：

```java
    ListNode deleteDuplicates(ListNode head) {
        if (head == null) return null;
        ListNode slow = head, fast = head;
        while (fast != null) {
            if (fast.val != slow.val) {
                // nums[slow] = nums[fast];
                slow.next = fast;
                // slow++;
                slow = slow.next;
            }
            // fast++
            fast = fast.next;
        }
        // 断开与后面重复元素的连接
        slow.next = null;
        return head;
    }

```

![](https://labuladong.gitee.io/algo/images/%e6%95%b0%e7%bb%84%e5%8e%bb%e9%87%8d/2.gif)

### 移除元素

这是力扣第 27 题，看下题目：

![](https://labuladong.gitee.io/algo/images/%e6%95%b0%e7%bb%84%e5%8e%bb%e9%87%8d/title1.png)

函数签名如下：

```java
    int removeElement(int[] nums, int val);

```

题目要求我们把 ` nums ` 中所有值为 ` val ` 的元素原地删除，依然需要使用 [ 双指针技巧 ](https://labuladong.gitee.io/algo/2/20/55/)中的快慢指针：

如果 ` fast ` 遇到需要去除的元素，则直接跳过，否则就告诉 ` slow ` 指针，并让 ` slow ` 前进一步。

这和前面说到的数组去重问题解法思路是完全一样的，就不画 GIF 了，直接看代码：

```java
    int removeElement(int[] nums, int val) {
        int fast = 0, slow = 0;
        while (fast < nums.length) {
            if (nums[fast] != val) {
                nums[slow] = nums[fast];
                slow++;
            }
            fast++;
        }
        return slow;
    }

```

**注意这里和有序数组去重的解法有一个重要不同** ，我们这里是先给 ` nums[slow] ` 赋值然后再给 ` slow++ ` ，这样可以保证 `nums[0..slow-1] ` 是不包含值为 ` val ` 的元素的，最后的结果数组长度就是 ` slow ` 。

### 移动零

这是力扣第 283 题，我来描述下题目：

给你输入一个数组 ` nums ` ，请你 **原地修改** ，将数组中的所有值为 0 的元素移到数组末尾，函数签名如下：

```java
    void moveZeroes(int[] nums);

```

比如说给你输入 ` nums = [0,1,4,0,2] ` ，你的算法没有返回值，但是会把 ` nums ` 数组原地修改成 ` [1,4,2,0,0]
` 。

结合之前说到的几个题目，你是否有已经有了答案呢？

题目让我们将所有 0 移到最后，其实就相当于移除 ` nums ` 中的所有 0，然后再把后面的元素都赋值为 0 即可。

所以我们可以复用上一题的 ` removeElement ` 函数：

```java
    void moveZeroes(int[] nums) {
        // 去除 nums 中的所有 0
        // 返回去除 0 之后的数组长度
        int p = removeElement(nums, 0);
        // 将 p 之后的所有元素赋值为 0
        for (; p < nums.length; p++) {
            nums[p] = 0;
        }
    }
    
    // 见上文代码实现
    int removeElement(int[] nums, int val);

```

至此，四道「原地修改」的算法问题就讲完了，其实核心还是快慢指针技巧，你学会了吗？

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


## twoSum问题的核心思想


读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 1. 两数之和（简单） ](https://leetcode-cn.com/problems/two-sum)

[ 170. 两数之和 III - 数据结构设计（简单） ](https://leetcode-cn.com/problems/two-sum-iii-
data-structure-design)

**———–**

Two Sum 系列问题在 LeetCode 上有好几道，这篇文章就挑出有代表性的几道，介绍一下这种问题怎么解决。

### TwoSum I

这个问题的 **最基本形式** 是这样：给你一个数组和一个整数 ` target ` ，可以保证数组中 **存在** 两个数的和为 ` target `，请你返回这两个数的索引。

比如输入 ` nums = [3,1,3,6], target = 6 ` ，算法应该返回数组 ` [0,2] ` ，因为 3 + 3 = 6。

这个问题如何解决呢？首先最简单粗暴的办法当然是穷举了：

```java
    int[] twoSum(int[] nums, int target) {
    
        for (int i = 0; i < nums.length; i++) 
            for (int j = i + 1; j < nums.length; j++) 
                if (nums[j] == target - nums[i]) 
                    return new int[] { i, j };
    
        // 不存在这么两个数
        return new int[] {-1, -1};
    }

```

这个解法非常直接，时间复杂度 O(N^2)，空间复杂度 O(1)。

可以通过一个哈希表减少时间复杂度：

```java
    int[] twoSum(int[] nums, int target) {
        int n = nums.length;
        HashMap<Integer, Integer> index = new HashMap<>();
        // 构造一个哈希表：元素映射到相应的索引
        for (int i = 0; i < n; i++)
            index.put(nums[i], i);
        
        for (int i = 0; i < n; i++) {
            int other = target - nums[i];
            // 如果 other 存在且不是 nums[i] 本身
            if (index.containsKey(other) && index.get(other) != i)
                return new int[] {i, index.get(other)};
        }
        
        return new int[] {-1, -1};
    }

```

这样，由于哈希表的查询时间为 O(1)，算法的时间复杂度降低到 O(N)，但是需要 O(N) 的空间复杂度来存储哈希表。不过综合来看，是要比暴力解法高效的。

**我觉得 Two Sum 系列问题就是想教我们如何使用哈希表处理问题** 。我们接着往后看。

### TwoSum II

这里我们稍微修改一下上面的问题。我们设计一个类，拥有两个 API：

```java
    class TwoSum {
        // 向数据结构中添加一个数 number
        public void add(int number);
        // 寻找当前数据结构中是否存在两个数的和为 value
        public boolean find(int value);
    }

```

如何实现这两个 API 呢，我们可以仿照上一道题目，使用一个哈希表辅助 ` find ` 方法：

```java
    class TwoSum {
        Map<Integer, Integer> freq = new HashMap<>();
    
        public void add(int number) {
            // 记录 number 出现的次数
            freq.put(number, freq.getOrDefault(number, 0) + 1);
        }
        
        public boolean find(int value) {
            for (Integer key : freq.keySet()) {
                int other = value - key;
                // 情况一
                if (other == key && freq.get(key) > 1)
                    return true;
                // 情况二
                if (other != key && freq.containsKey(other))
                    return true;
            }
            return false;
        }
    }

```

进行 ` find ` 的时候有两种情况，举个例子：

情况一： ` add ` 了 ` [3,3,2,5] ` 之后，执行 ` find(6) ` ，由于 3 出现了两次，3 + 3 = 6，所以返回 true。

情况二： ` add ` 了 ` [3,3,2,5] ` 之后，执行 ` find(7) ` ，那么 ` key ` 为 2， ` other ` 为 5 时算法可以返回 true。

除了上述两种情况外， ` find ` 只能返回 false 了。

对于这个解法的时间复杂度呢， ` add ` 方法是 O(1)， ` find ` 方法是 O(N)，空间复杂度为 O(N)，和上一道题目比较类似。

**但是对于 API 的设计，是需要考虑现实情况的** 。比如说，我们设计的这个类，使用 ` find ` 方法非常频繁，那么每次都要 O(N)的时间，岂不是很浪费费时间吗？对于这种情况，我们是否可以做些优化呢？

是的，对于频繁使用 ` find ` 方法的场景，我们可以进行优化。我们可以参考上一道题目的暴力解法，借助 **哈希集合** 来针对性优化 ` find `方法：

```java
    class TwoSum {
        Set<Integer> sum = new HashSet<>();
        List<Integer> nums = new ArrayList<>();
    
        public void add(int number) {
            // 记录所有可能组成的和
            for (int n : nums)
                sum.add(n + number);
            nums.add(number);
        }
        
        public boolean find(int value) {
            return sum.contains(value);
        }
    }

```

这样 ` sum ` 中就储存了所有加入数字可能组成的和，每次 ` find ` 只要花费 O(1)的时间在集合中判断一下是否存在就行了，显然非常适合频繁使用 ` find ` 的场景。

### 三、总结

对于 TwoSum 问题，一个难点就是给的数组 **无序** 。对于一个无序的数组，我们似乎什么技巧也没有，只能暴力穷举所有可能。

**一般情况下，我们会首先把数组排序再考虑双指针技巧** 。TwoSum 启发我们，HashMap 或者 HashSet 也可以帮助我们处理无序数组相关的简单问题。

另外，设计的核心在于权衡，利用不同的数据结构，可以得到一些针对性的加强。

最后，如果 TwoSum I 中给的数组是有序的，应该如何编写算法呢？答案很简单，前文 [ 双指针技巧汇总 ](https://labuladong.gitee.io/algo/2/20/55/) 写过：

```java
    int[] twoSum(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left < right) {
            int sum = nums[left] + nums[right];
            if (sum == target) {
                return new int[]{left, right};
            } else if (sum < target) {
                left++; // 让 sum 大一点
            } else if (sum > target) {
                right--; // 让 sum 小一点
            }
        }
        // 不存在这样两个数
        return new int[]{-1, -1};
    }

```

