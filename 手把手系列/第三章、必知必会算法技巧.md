 # 第三章、必知必会算法技巧

1、《算法秘籍》和《刷题笔记》两本 PDF 下载 [ 点这里

](https://mp.weixin.qq.com/s/X-fE9sR4BLi6T9pn7xP4pg) 。

2、刷题插件下载及使用手册 [ 点这里 ](https://mp.weixin.qq.com/s/wIxflO1dvXzDlibhEcENcQ) 。

3、公众号菜单栏参与 [ 21 天算法挑战活动 ](https://mp.weixin.qq.com/s/eUG2OOzY3k_ZTz-CFvtv5Q) 。

 # 暴力搜索算法

1、《算法秘籍》和《刷题笔记》两本 PDF 下载 [ 点这里

](https://mp.weixin.qq.com/s/X-fE9sR4BLi6T9pn7xP4pg) 。

2、刷题插件下载及使用手册 [ 点这里 ](https://mp.weixin.qq.com/s/wIxflO1dvXzDlibhEcENcQ) 。

3、公众号菜单栏参与 [ 21 天算法挑战活动 ](https://mp.weixin.qq.com/s/eUG2OOzY3k_ZTz-CFvtv5Q) 。

 ## 回溯算法解题套路框架
 读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 46. 全排列（中等） ](https://leetcode-cn.com/problems/permutations)

[ 51. N皇后（困难） ](https://leetcode-cn.com/problems/n-queens)

**———–**

本文有视频版： [ 回溯算法框架套路详解 ](https://www.bilibili.com/video/BV1P5411N7Xc)

这篇文章是很久之前的一篇 [ 回溯算法详解 ](https://mp.weixin.qq.com/s/trILKSiN9EoS58pXmvUtUQ)
的进阶版，之前那篇不够清楚，就不必看了，看这篇就行。把框架给你讲清楚，你会发现回溯算法问题都是一个套路。

本文解决几个问题：

回溯算法是什么？解决回溯算法相关的问题有什么技巧？如何学习回溯算法？回溯算法代码是否有规律可循？

其实回溯算法其实就是我们常说的 DFS 算法，本质上就是一种暴力穷举算法。

废话不多说，直接上回溯算法框架。 **解决一个回溯问题，实际上就是一个决策树的遍历过程** 。你只需要思考 3 个问题：

1、路径：也就是已经做出的选择。

2、选择列表：也就是你当前可以做的选择。

3、结束条件：也就是到达决策树底层，无法再做选择的条件。

如果你不理解这三个词语的解释，没关系，我们后面会用「全排列」和「N 皇后问题」这两个经典的回溯算法问题来帮你理解这些词语是什么意思，现在你先留着印象。

代码方面，回溯算法的框架：

```java
    result = []
    def backtrack(路径, 选择列表):
        if 满足结束条件:
            result.add(路径)
            return
        
        for 选择 in 选择列表:
            做选择
            backtrack(路径, 选择列表)
            撤销选择

```

**其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」** ，特别简单。

什么叫做选择和撤销选择呢，这个框架的底层原理是什么呢？下面我们就通过「全排列」这个问题来解开之前的疑惑，详细探究一下其中的奥妙！

### 一、全排列问题

我们在高中的时候就做过排列组合的数学题，我们也知道 ` n ` 个不重复的数，全排列共有 ` n! ` 个。

> PS： **为了简单清晰起见，我们这次讨论的全排列问题不包含重复的数字** 。

那么我们当时是怎么穷举全排列的呢？比方说给三个数 ` [1,2,3] ` ，你肯定不会无规律地乱穷举，一般是这样：

先固定第一位为 1，然后第二位可以是 2，那么第三位只能是 3；然后可以把第二位变成 3，第三位就只能是 2 了；然后就只能变化第一位，变成 2，然后再穷举后两位……

其实这就是回溯算法，我们高中无师自通就会用，或者有的同学直接画出如下这棵回溯树：

![](https://labuladong.gitee.io/algo/images/backtracking/1.jpg)

只要从根遍历这棵树，记录路径上的数字，其实就是所有的全排列。 **我们不妨把这棵树称为回溯算法的「决策树」** 。

**为啥说这是决策树呢，因为你在每个节点上其实都在做决策** 。比如说你站在下图的红色节点上：

![](https://labuladong.gitee.io/algo/images/backtracking/2.jpg)

你现在就在做决策，可以选择 1 那条树枝，也可以选择 3 那条树枝。为啥只能在 1 和 3 之中选择呢？因为 2 这个树枝在你身后，这个选择你之前做过了，而全排列是不允许重复使用数字的。

**现在可以解答开头的几个名词：` [2] ` 就是「路径」，记录你已经做过的选择； ` [1,3]`就是「选择列表」，表示你当前可以做出的选择；「结束条件」就是遍历到树的底层，在这里就是选择列表为空的时候 ** 。

如果明白了这几个名词， **可以把「路径」和「选择」列表作为决策树上每个节点的属性** ，比如下图列出了几个节点的属性：

![](https://labuladong.gitee.io/algo/images/backtracking/3.jpg)

**我们定义的` backtrack ` 函数其实就像一个指针，在这棵树上游走，同时要正确维护每个节点的属性，每当走到树的底层，其「路径」就是一个全排列

** 。

再进一步，如何遍历一棵树？这个应该不难吧。回忆一下之前 [ 学习数据结构的框架思维 ](https://labuladong.gitee.io/algo/1/2/)
写过，各种搜索问题其实都是树的遍历问题，而多叉树的遍历框架就是这样：

```java
    void traverse(TreeNode root) {
        for (TreeNode child : root.childern)
           // 前序遍历需要的操作
            traverse(child);
           // 后序遍历需要的操作
    }

```

而所谓的前序遍历和后序遍历，他们只是两个很有用的时间点，我给你画张图你就明白了：

![](https://labuladong.gitee.io/algo/images/backtracking/4.jpg)

**前序遍历的代码在进入某一个节点之前的那个时间点执行，后序遍历代码在离开某个节点之后的那个时间点执行** 。

回想我们刚才说的，「路径」和「选择」是每个节点的属性，函数在树上游走要正确维护节点的属性，那么就要在这两个特殊时间点搞点动作：

![](https://labuladong.gitee.io/algo/images/backtracking/5.jpg)

现在，你是否理解了回溯算法的这段核心框架？

```java
    for 选择 in 选择列表:
         做选择
        将该选择从选择列表移除
        路径.add(选择)
        backtrack(路径, 选择列表)
         撤销选择
        路径.remove(选择)
        将该选择再加入选择列表

```

**我们只要在递归之前做出选择，在递归之后撤销刚才的选择** ，就能正确得到每个节点的选择列表和路径。

下面，直接看全排列代码：

```java
    List<List<Integer>> res = new LinkedList<>();
    
   /* 主函数，输入一组不重复的数字，返回它们的全排列 */
    List<List<Integer>> permute(int[] nums) {
       // 记录「路径」
        LinkedList<Integer> track = new LinkedList<>();
        backtrack(nums, track);
        return res;
    }
    
   // 路径：记录在 track 中
   // 选择列表：nums 中不存在于 track 的那些元素
   // 结束条件：nums 中的元素全都在 track 中出现
    void backtrack(int[] nums, LinkedList<Integer> track) {
       // 触发结束条件
        if (track.size() == nums.length) {
            res.add(new LinkedList(track));
            return;
        }
        
        for (int i = 0; i < nums.length; i++) {
           // 排除不合法的选择
            if (track.contains(nums[i]))
                continue;
           // 做选择
            track.add(nums[i]);
           // 进入下一层决策树
            backtrack(nums, track);
           // 取消选择
            track.removeLast();
        }
    }

```

我们这里稍微做了些变通，没有显式记录「选择列表」，而是通过 ` nums ` 和 ` track ` 推导出当前的选择列表：

![](https://labuladong.gitee.io/algo/images/backtracking/6.jpg)

至此，我们就通过全排列问题详解了回溯算法的底层原理。当然，这个算法解决全排列不是很高效，应为对链表使用 ` contains ` 方法需要 O(N)
的时间复杂度。有更好的方法通过交换元素达到目的，但是难理解一些，这里就不写了，有兴趣可以自行搜索一下。

但是必须说明的是，不管怎么优化，都符合回溯框架，而且时间复杂度都不可能低于 O(N!)，因为穷举整棵决策树是无法避免的。
**这也是回溯算法的一个特点，不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高** 。

明白了全排列问题，就可以直接套回溯算法框架了，下面简单看看 N 皇后问题。

### 二、N 皇后问题

这个问题很经典了，简单解释一下：给你一个 N×N 的棋盘，让你放置 N 个皇后，使得它们不能互相攻击。

> PS：皇后可以攻击同一行、同一列、左上左下右上右下四个方向的任意单位。

这个问题本质上跟全排列问题差不多，决策树的每一层表示棋盘上的每一行；每个节点可以做出的选择是，在该行的任意一列放置一个皇后。

因为 C++ 代码对字符串的操作方便一些，所以这道题我用 C++ 来写解法，直接套用回溯算法框架:

```java
    vector<vector<string>> res;
    
   /* 输入棋盘边长 n，返回所有合法的放置 */
    vector<vector<string>> solveNQueens(int n) {
       // '.' 表示空，'Q' 表示皇后，初始化空棋盘。
        vector<string> board(n, string(n, '.'));
        backtrack(board, 0);
        return res;
    }
    
   // 路径：board 中小于 row 的那些行都已经成功放置了皇后
   // 选择列表：第 row 行的所有列都是放置皇后的选择
   // 结束条件：row 超过 board 的最后一行
    void backtrack(vector<string>& board, int row) {
       // 触发结束条件
        if (row == board.size()) {
            res.push_back(board);
            return;
        }
        
        int n = board[row].size();
        for (int col = 0; col < n; col++) {
           // 排除不合法选择
            if (!isValid(board, row, col)) 
                continue;
           // 做选择
            board[row][col] = 'Q';
           // 进入下一行决策
            backtrack(board, row + 1);
           // 撤销选择
            board[row][col] = '.';
        }
    }

```

这部分主要代码，其实跟全排列问题差不多， ` isValid ` 函数的实现也很简单：

```java
   /* 是否可以在 board[row][col] 放置皇后？ */
    bool isValid(vector<string>& board, int row, int col) {
        int n = board.size();
       // 检查列是否有皇后互相冲突
        for (int i = 0; i < n; i++) {
            if (board[i][col] == 'Q')
                return false;
        }
       // 检查右上方是否有皇后互相冲突
        for (int i = row - 1, j = col + 1; 
                i >= 0 && j < n; i--, j++) {
            if (board[i][j] == 'Q')
                return false;
        }
       // 检查左上方是否有皇后互相冲突
        for (int i = row - 1, j = col - 1;
                i >= 0 && j >= 0; i--, j--) {
            if (board[i][j] == 'Q')
                return false;
        }
        return true;
    }

```

> PS：肯定有读者问，按照 N 皇后问题的描述，我们为什么不检查左下角，右下角和下方的格子，只检查了左上角，右上角和上方的格子呢？

因为皇后是一行一行从上往下放的，所以左下方，右下方和正下方不用检查（还没放皇后）；因为一行只会放一个皇后，所以每行不用检查。也就是最后只用检查上面，左上，右上三个方向。

函数 ` backtrack ` 依然像个在决策树上游走的指针，通过 ` row ` 和 ` col ` 就可以表示函数遍历到的位置，通过`isValid ` 函数可以将不符合条件的情况剪枝：

![](https://labuladong.gitee.io/algo/images/backtracking/7.jpg)

如果直接给你这么一大段解法代码，可能是懵逼的。但是现在明白了回溯算法的框架套路，还有啥难理解的呢？无非是改改做选择的方式，排除不合法选择的方式而已，只要框架存于心，你面对的只剩下小问题了。

当 ` N = 8`时，就是八皇后问题，数学大佬高斯穷尽一生都没有数清楚八皇后问题到底有几种可能的放置方法，但是我们的算法只需要一秒就可以算出来所有可能的结果。

不过真的不怪高斯。这个问题的复杂度确实非常高，看看我们的决策树，虽然有 ` isValid ` 函数剪枝，但是最坏时间复杂度仍然是 O(N^(N+1))，而且无法优化。如果 ` N = 10 ` 的时候，计算就已经很耗时了。

**有的时候，我们并不想得到所有合法的答案，只想要一个答案，怎么办呢** ？比如解数独的算法，找所有解法复杂度太高，只要找到一种解法就可以。

其实特别简单，只要稍微修改一下回溯算法的代码即可：

```java
   // 函数找到一个答案后就返回 true
    bool backtrack(vector<string>& board, int row) {
       // 触发结束条件
        if (row == board.size()) {
            res.push_back(board);
            return true;
        }
        ...
        for (int col = 0; col < n; col++) {
            ...
            board[row][col] = 'Q';
    
            if (backtrack(board, row + 1))
                return true;
            
            board[row][col] = '.';
        }
    
        return false;
    }

```

这样修改后，只要找到一个答案，for 循环的后续递归穷举都会被阻断。也许你可以在 N 皇后问题的代码框架上，稍加修改，写一个解数独的算法？

### 三、最后总结

回溯算法就是个多叉树的遍历问题，关键就是在前序遍历和后序遍历的位置做一些操作，算法框架如下：

```java
    def backtrack(...):
        for 选择 in 选择列表:
            做选择
            backtrack(...)
            撤销选择

```

**写` backtrack ` 函数时，需要维护走过的「路径」和当前可以做的「选择列表」，当触发「结束条件」时，将「路径」记入结果集 ** 。

其实想想看，回溯算法和动态规划是不是有点像呢？我们在动态规划系列文章中多次强调，动态规划的三个需要明确的点就是「状态」「选择」和「base case」，是不是就对应着走过的「路径」，当前的「选择列表」和「结束条件」？

某种程度上说，动态规划的暴力求解阶段就是回溯算法。只是有的问题具有重叠子问题性质，可以用 dp table
或者备忘录优化，将递归树大幅剪枝，这就变成了动态规划。而今天的两个问题，都没有重叠子问题，也就是回溯算法问题了，复杂度非常高是不可避免的。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


 ## 回溯算法牛逼：集合划分问题
 读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 698. 划分为k个相等的子集（中等） ](https://leetcode-cn.com/problems/partition-to-k-equal-
sum-subsets/)

**———–**

之前说过回溯算法是笔试中最好用的算法，只要你没什么思路，就用回溯算法暴力求解，即便不能通过所有测试用例，多少能过一点。

回溯算法的技巧也不难，前文 [ 回溯算法框架套路 ](https://labuladong.gitee.io/algo/4/28/105/)
说过，回溯算法就是穷举一棵决策树的过程，只要在递归之前「做选择」，在递归之后「撤销选择」就行了。

但是，就算暴力穷举，不同的思路也有优劣之分。

本文就来看一道非常经典的回溯算法问题，子集划分问题，可以帮你更深刻理解回溯算法的思维，得心应手地写出回溯函数。

题目非常简单：

给你输入一个数组 ` nums ` 和一个正整数 ` k ` ，请你判断 ` nums ` 是否能够被平分为元素和相同的 ` k ` 个子集。

函数签名如下：

```java
    boolean canPartitionKSubsets(int[] nums, int k);

```

我们之前 [ 背包问题之子集划分 ](https://labuladong.gitee.io/algo/3/24/81/)
写过一次子集划分问题，不过那道题只需要我们把集合划分成两个相等的集合，可以转化成背包问题用动态规划技巧解决。

但是如果划分成多个相等的集合，解法一般只能通过暴力穷举，时间复杂度爆表，是练习回溯算法和递归思维的好机会。

### 一、思路分析

把装有 ` n ` 个数字的数组 ` nums ` 分成 ` k ` 个和相同的集合，你可以想象将 ` n ` 个数字分配到 ` k ` 个「桶」里，最后这
` k ` 个「桶」里的数字之和要相同。

前文 [ 回溯算法框架套路 ](https://labuladong.gitee.io/algo/4/28/105/) 说过，回溯算法的关键在哪里？

关键是要知道怎么「做选择」，这样才能利用递归函数进行穷举。

那么回想我们这个问题，将 ` n ` 个数字分配到 ` k ` 个桶里，我们可以有两种视角：

**视角一，如果我们切换到这` n ` 个数字的视角，每个数字都要选择进入到 ` k ` 个桶中的某一个 ** 。

**视角二，如果我们切换到这` k ` 个桶的视角，对于每个桶，都要遍历 ` nums ` 中的 ` n`个数字，然后选择是否将当前遍历到的数字装进自己这个桶里 ** 。

你可能问，这两种视角有什么不同？

**用不同的视角进行穷举，虽然结果相同，但是解法代码的逻辑完全不同；对比不同的穷举视角，可以帮你更深刻地理解回溯算法，我们慢慢道来** 。

### 二、以数字的视角

用 for 循环迭代遍历 ` nums ` 数组大家肯定都会：

```java
    for (int index = 0; index < nums.length; index++) {
        System.out.println(nums[index]);
    }

```

递归遍历数组你会不会？其实也很简单：

```java
    void traverse(int[] nums, int index) {
        if (index == nums.length) {
            return;
        }
        System.out.println(nums[index]);
        traverse(nums, index + 1);
    }

```

只要调用 ` traverse(nums, 0) ` ，和 for 循环的效果是完全一样的。

那么回到这道题，以数字的视角，选择 ` k ` 个桶，用 for 循环写出来是下面这样：

```java
   // k 个桶（集合），记录每个桶装的数字之和
    int[] bucket = new int[k];
    
   // 穷举 nums 中的每个数字
    for (int index = 0; index < nums.length; index++) {
       // 穷举每个桶
        for (int i = 0; i < k; i++) {
           // nums[index] 选择是否要进入第 i 个桶
           // ...
        }
    }

```

如果改成递归的形式，就是下面这段代码逻辑：

```java
   // k 个桶（集合），记录每个桶装的数字之和
    int[] bucket = new int[k];
    
   // 穷举 nums 中的每个数字
    void backtrack(int[] nums, int index) {
       // base case
        if (index == nums.length) {
            return;
        }
       // 穷举每个桶
        for (int i = 0; i < bucket.length; i++) {
           // 选择装进第 i 个桶
            bucket[i] += nums[index];
           // 递归穷举下一个数字的选择
            backtrack(nums, index + 1);
           // 撤销选择
            bucket[i] -= nums[index];
        }
    }

```

虽然上述代码仅仅是穷举逻辑，还不能解决我们的问题，但是只要略加完善即可：

```java
   // 主函数
    boolean canPartitionKSubsets(int[] nums, int k) {
       // 排除一些基本情况
        if (k > nums.length) return false;
        int sum = 0;
        for (int v : nums) sum += v;
        if (sum % k != 0) return false;
    
       // k 个桶（集合），记录每个桶装的数字之和
        int[] bucket = new int[k];
       // 理论上每个桶（集合）中数字的和
        int target = sum/ k;
       // 穷举，看看 nums 是否能划分成 k 个和为 target 的子集
        return backtrack(nums, 0, bucket, target);
    }
    
   // 递归穷举 nums 中的每个数字
    boolean backtrack(
        int[] nums, int index, int[] bucket, int target) {
    
        if (index == nums.length) {
           // 检查所有桶的数字之和是否都是 target
            for (int i = 0; i < bucket.length; i++) {
                if (bucket[i] != target) {
                    return false;
                }
            }
           // nums 成功平分成 k 个子集
            return true;
        }
        
       // 穷举 nums[index] 可能装入的桶
        for (int i = 0; i < bucket.length; i++) {
           // 剪枝，桶装装满了
            if (bucket[i] + nums[index] > target) {
                continue;
            }
           // 将 nums[index] 装入 bucket[i]
            bucket[i] += nums[index];
           // 递归穷举下一个数字的选择
            if (backtrack(nums, index + 1, bucket, target)) {
                return true;
            }
           // 撤销选择
            bucket[i] -= nums[index];
        }
    
       // nums[index] 装入哪个桶都不行
        return false;
    }

```

有之前的铺垫，相信这段代码是比较容易理解的。这个解法虽然能够通过，但是耗时比较多，其实我们可以再做一个优化。

主要看 ` backtrack ` 函数的递归部分：

```java
    for (int i = 0; i < bucket.length; i++) {
       // 剪枝
        if (bucket[i] + nums[index] > target) {
            continue;
        }
    
        if (backtrack(nums, index + 1, bucket, target)) {
            return true;
        }
    }

```

**如果我们让尽可能多的情况命中剪枝的那个 if 分支，就可以减少递归调用的次数，一定程度上减少时间复杂度** 。

如何尽可能多的命中这个 if 分支呢？要知道我们的 ` index ` 参数是从 0 开始递增的，也就是递归地从 0 开始遍历 ` nums ` 数组。

如果我们提前对 ` nums ` 数组排序，把大的数字排在前面，那么大的数字会先被分配到 ` bucket ` 中，对于之后的数字， ` bucket[i]

+ nums[index] ` 会更大，更容易触发剪枝的 if 条件。

所以可以在之前的代码中再添加一些代码：

```java
    boolean canPartitionKSubsets(int[] nums, int k) {
       // 其他代码不变
       // ...
       /* 降序排序 nums 数组 */
        Arrays.sort(nums);
        int i = 0, j = nums.length - 1;
        for (; i < j; i++, j--) {
           // 交换 nums[i] 和 nums[j]
            int temp = nums[i];
            nums[i] = nums[j];
            nums[j] = temp;
        }
       /*******************/
        return backtrack(nums, 0, bucket, target);
    }

```

由于 Java 的语言特性，这段代码通过先升序排序再反转，达到降序排列的目的。

### 三、以桶的视角

文章开头说了， **以桶的视角进行穷举，每个桶需要遍历` nums`中的所有数字，决定是否把当前数字装进桶中；当装满一个桶之后，还要装下一个桶，直到所有桶都装满为止 ** 。

这个思路可以用下面这段代码表示出来：

```java
   // 装满所有桶为止
    while (k > 0) {
       // 记录当前桶中的数字之和
        int bucket = 0;
        for (int i = 0; i < nums.length; i++) {
           // 决定是否将 nums[i] 放入当前桶中
            bucket += nums[i] or 0;
            if (bucket == target) {
               // 装满了一个桶，装下一个桶
                k--;
                break;
            }
        }
    }

```

那么我们也可以把这个 while 循环改写成递归函数，不过比刚才略微复杂一些，首先写一个 ` backtrack ` 递归函数出来：

```java
    boolean backtrack(int k, int bucket, 
        int[] nums, int start, boolean[] used, int target);

```

不要被这么多参数吓到，我会一个个解释这些参数。 **如果你能够透彻理解本文，也能得心应手地写出这样的回溯函数** 。

这个 ` backtrack ` 函数的参数可以这样解释：

现在 ` k ` 号桶正在思考是否应该把 ` nums[start] ` 这个元素装进来；目前 ` k ` 号桶里面已经装的数字之和为 ` bucket`； ` used ` 标志某一个元素是否已经被装到桶中； ` target ` 是每个桶需要达成的目标和。

根据这个函数定义，可以这样调用 ` backtrack ` 函数：

```java
    boolean canPartitionKSubsets(int[] nums, int k) {
       // 排除一些基本情况
        if (k > nums.length) return false;
        int sum = 0;
        for (int v : nums) sum += v;
        if (sum % k != 0) return false;
        
        boolean[] used = new boolean[nums.length];
        int target = sum/ k;
       // k 号桶初始什么都没装，从 nums[0] 开始做选择
        return backtrack(k, 0, nums, 0, used, target);
    }

```

实现 ` backtrack ` 函数的逻辑之前，再重复一遍，从桶的视角：

1、需要遍历 ` nums ` 中所有数字，决定哪些数字需要装到当前桶中。

2、如果当前桶装满了（桶内数字和达到 ` target ` ），则让下一个桶开始执行第 1 步。

下面的代码就实现了这个逻辑：

```java
    boolean backtrack(int k, int bucket, 
        int[] nums, int start, boolean[] used, int target) {
       // base case
        if (k == 0) {
           // 所有桶都被装满了，而且 nums 一定全部用完了
           // 因为 target == sum/ k
            return true;
        }
        if (bucket == target) {
           // 装满了当前桶，递归穷举下一个桶的选择
           // 让下一个桶从 nums[0] 开始选数字
            return backtrack(k - 1, 0 ,nums, 0, used, target);
        }
    
       // 从 start 开始向后探查有效的 nums[i] 装入当前桶
        for (int i = start; i < nums.length; i++) {
           // 剪枝
            if (used[i]) {
               // nums[i] 已经被装入别的桶中
                continue;
            }
            if (nums[i] + bucket > target) {
               // 当前桶装不下 nums[i]
                continue;
            }
           // 做选择，将 nums[i] 装入当前桶中
            used[i] = true;
            bucket += nums[i];
           // 递归穷举下一个数字是否装入当前桶
            if (backtrack(k, bucket, nums, i + 1, used, target)) {
                return true;
            }
           // 撤销选择
            used[i] = false;
            bucket -= nums[i];
        }
       // 穷举了所有数字，都无法装满当前桶
        return false;
    }

```

至此，这道题的第二种思路也完成了。

### 四、最后总结

本文写的这两种思路都可以通过所有测试用例，不过第一种解法即便经过了排序优化，也明显比第二种解法慢很多，这是为什么呢？

我们来分析一下这两个算法的时间复杂度，假设 ` nums ` 中的元素个数为 ` n ` 。

先说第一个解法，也就是从数字的角度进行穷举， ` n ` 个数字，每个数字有 ` k ` 个桶可供选择，所以组合出的结果个数为 ` k^n`，时间复杂度也就是 ` O(k^n) ` 。

第二个解法，每个桶要遍历 ` n ` 个数字，选择「装入」或「不装入」，组合的结果有 ` 2^n ` 种；而我们有 ` k ` 个桶，所以总的时间复杂度为
` O(k*2^n) ` 。

**当然，这是理论上的最坏复杂度，实际的复杂度肯定要好一些，毕竟我们添加了这么多剪枝逻辑** 。不过，从复杂度的上界已经可以看出第一种思路要慢很多了。

所以，谁说回溯算法没有技巧性的？虽然回溯算法就是暴力穷举，但穷举也分聪明的穷举方式和低效的穷举方式，关键看你以谁的「视角」进行穷举。

通俗来说，我们应该尽量「少量多次」，就是说宁可多做几次选择，也不要给太大的选择空间；宁可「二选一」选 ` k ` 次，也不要 「 ` k ` 选一」选一次。

这道题我们从两种视角进行穷举，虽然代码量看起来多，但核心逻辑都是类似的，相信你通过本文能够更深刻地理解回溯算法。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


 ## 回溯算法团灭子集、排列、组合问题
 读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 78. 子集（中等） ](https://leetcode-cn.com/problems/subsets)

[ 46. 全排列（中等） ](https://leetcode-cn.com/problems/permutations)

[ 77. 组合（中等） ](https://leetcode-cn.com/problems/combinations)

**———–**

今天就来聊三道考察频率高，而且容易让人搞混的算法问题，分别是求子集（subset），求排列（permutation），求组合（combination）。

这几个问题都可以用回溯算法模板解决，同时子集问题还可以用数学归纳思想解决。读者可以记住这几个问题的回溯套路，就不怕搞不清了。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**

应合作方要求，本文不便在此发布，请扫码关注回复关键词「回溯」查看：

![](https://labuladong.gitee.io/algo/images/qrcode.jpg)

 ## 回溯算法最佳实践：解数独
 读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 37. 解数独（困难） ](https://leetcode-cn.com/problems/sudoku-solver)

**———–**

经常拿回溯算法来说事儿的，无非就是八皇后问题和数独问题了。那我们今天就通过 **实际且有趣的例子** 来讲一下如何用回溯算法来解决数独问题。

### 一、直观感受

说实话我小的时候也尝试过玩数独游戏，但从来都没有完成过一次。做数独是有技巧的，我记得一些比较专业的数独游戏软件，他们会教你玩数独的技巧，不过在我看来这些技巧都太复杂，我根本就没有兴趣看下去。

不过自从我学习了算法，多困难的数独问题都拦不住我了。下面是我用程序完成数独的一个例子：

![](https://labuladong.gitee.io/algo/images/sudoku/sudoku_slove.gif)

> PS：GIF 可能出现 bug，若卡住​点开查看即可，​下同。​

这是一个安卓手机中的数独游戏，我使用一个叫做 Auto.js 的脚本引擎，配合回溯算法来实现自动完成填写，并且算法记录了执行次数。
**在后文，我会给出该脚本的实现思路代码以及软件工具的下载，你也可以拿来装逼用** 。

可以观察到前两次都执行了 1 万多次，而最后一次只执行了 100 多次就算出了答案，这说明对于不同的局面，回溯算法得到答案的时间是不相同的。

那么计算机如何解决数独问题呢？其实非常的简单，就是穷举嘛，下面我可视化了求解过程：

![](https://labuladong.gitee.io/algo/images/sudoku/sudoku_process.gif)

**算法的核心思路非常非常的简单，就是对每一个空着的格子穷举 1 到 9，如果遇到不合法的数字（在同一行或同一列或同一个 3×3 的区域中存在相同的数字）则跳过，如果找到一个合法的数字，则继续穷举下一个空格子** 。

对于数独游戏，也许我们还会有另一个误区：就是下意识地认为如果给定的数字越少那么这个局面的难度就越大。

这个结论对人来说应该没毛病，但对于计算机而言，给的数字越少，反而穷举的步数就越少，得到答案的速度越快，至于为什么，我们后面探讨代码实现的时候会讲。

上一个 GIF 是最后一关 70 关，下图是第 52 关，数字比较多，看起来似乎不难，但是我们看一下算法执行的过程：

![](https://labuladong.gitee.io/algo/images/sudoku/sudoku3.gif)

可以看到算法在前两行穷举了半天都没有走出去，由于时间原因我就没有继续录制了，事实上，这个局面穷举的次数大概是上一个局面的 10 倍。

**言归正传，下面我们就来具体探讨一下如何用算法来求解数独问题，顺便说说我是如何可视化这个求解过程的** 。

### 二、代码实现

首先，我们不用管游戏的 UI，先单纯地解决回溯算法，LeetCode 第 37 题就是解数独的问题，算法函数签名如下：

```java
    void solveSudoku(char[][] board);

```

输入是一个9x9的棋盘，空白格子用点号字符 ` . ` 表示，算法需要在原地修改棋盘，将空白格子填上数字，得到一个可行解。

至于数独的要求，大家想必都很熟悉了，每行，每列以及每一个 3×3 的小方格都不能有相同的数字出现。那么，现在我们直接套回溯框架即可求解。

**前文[ 回溯算法详解 ](https://labuladong.gitee.io/algo/4/28/105/) ，已经写过了回溯算法的套路框架，如果还没看过那篇文章的，建议先看看 ** 。

回忆刚才的 GIF 图片，我们求解数独的思路很简单粗暴，就是对每一个格子所有可能的数字进行穷举。对于每个位置，应该如何穷举，有几个选择呢？

**很简单啊，从 1 到 9 就是选择，全部试一遍不就行了** ：

```java
   // 对 board[i][j] 进行穷举尝试
    void backtrack(char[][] board, int i, int j) {
        int m = 9, n = 9;
        for (char ch = '1'; ch <= '9'; ch++) {
           // 做选择
            board[i][j] = ch;
           // 继续穷举下一个
            backtrack(board, i, j + 1);
           // 撤销选择
            board[i][j] = '.';
        }
    }

```

emmm，再继续细化，并不是 1 到 9 都可以取到的，有的数字不是不满足数独的合法条件吗？而且现在只是给 ` j ` 加一，那如果 ` j`加到最后一列了，怎么办？

**很简单，当` j ` 到达超过每一行的最后一个索引时，转为增加 ` i ` 开始穷举下一行，并且在穷举之前添加一个判断，跳过不满足条件的数字 ** ：

```java
    void backtrack(char[][] board, int i, int j) {
        int m = 9, n = 9;
        if (j == n) {
           // 穷举到最后一列的话就换到下一行重新开始。
            backtrack(board, i + 1, 0);
            return;
        }
        
       // 如果该位置是预设的数字，不用我们操心
        if (board[i][j] != '.') {
            backtrack(board, i, j + 1);
            return;
        } 
    
        for (char ch = '1'; ch <= '9'; ch++) {
           // 如果遇到不合法的数字，就跳过
            if (!isValid(board, i, j, ch))
                continue;
            
            board[i][j] = ch;
            backtrack(board, i, j + 1);
            board[i][j] = '.';
        }
    }
    
   // 判断 board[i][j] 是否可以填入 n
    boolean isValid(char[][] board, int r, int c, char n) {
        for (int i = 0; i < 9; i++) {
           // 判断行是否存在重复
            if (board[r][i] == n) return false;
           // 判断列是否存在重复
            if (board[i][c] == n) return false;
           // 判断 3 x 3 方框是否存在重复
            if (board[(r/3)*3 + i/3][(c/3)*3 + i%3] == n)
                return false;
        }
        return true;
    }

```

emmm，现在基本上差不多了，还剩最后一个问题：这个算法没有 base case，永远不会停止递归。这个好办，什么时候结束递归？ **显然` r == m
` 的时候就说明穷举完了最后一行，完成了所有的穷举，就是 base case ** 。

另外，前文也提到过，为了减少复杂度，我们可以让 ` backtrack ` 函数返回值为 ` boolean ` ，如果找到一个可行解就返回 true，这样就可以阻止后续的递归。只找一个可行解，也是题目的本意。

最终代码修改如下：

```java
    boolean backtrack(char[][] board, int i, int j) {
        int m = 9, n = 9;
        if (j == n) {
           // 穷举到最后一列的话就换到下一行重新开始。
            return backtrack(board, i + 1, 0);
        }
        if (i == m) {
           // 找到一个可行解，触发 base case
            return true;
        }
    
        if (board[i][j] != '.') {
           // 如果有预设数字，不用我们穷举
            return backtrack(board, i, j + 1);
        } 
    
        for (char ch = '1'; ch <= '9'; ch++) {
           // 如果遇到不合法的数字，就跳过
            if (!isValid(board, i, j, ch))
                continue;
            
            board[i][j] = ch;
           // 如果找到一个可行解，立即结束
            if (backtrack(board, i, j + 1)) {
                return true;
            }
            board[i][j] = '.';
        }
       // 穷举完 1~9，依然没有找到可行解，此路不通
        return false;
    }
    
    boolean isValid(char[][] board, int r, int c, char n) {
       // 见上文
    }

```

**现在可以回答一下之前的问题，为什么有时候算法执行的次数多，有时候少？为什么对于计算机而言，确定的数字越少，反而算出答案的速度越快** ？

我们已经实现了一遍算法，掌握了其原理，回溯就是从 1 开始对每个格子穷举，最后只要试出一个可行解，就会立即停止后续的递归穷举。所以暴力试出答案的次数和随机生成的棋盘关系很大，这个是说不准的。

那么你可能问， **既然运行次数说不准，那么这个算法的时间复杂度是多少呢** ？

对于这种时间复杂度的计算，我们只能给出一个最坏情况，也就是 O(9^M)，其中 ` M ` 是棋盘中空着的格子数量。你想嘛，对每个空格子穷举 9 个数，结果就是指数级的。

这个复杂度非常高，但稍作思考就能发现，实际上我们并没有真的对每个空格都穷举 9 次，有的数字会跳过，有的数字根本就没有穷举，因为当我们找到一个可行解的时候就立即结束了，后续的递归都没有展开。

这个 O(9^M) 的复杂度实际上是完全穷举，或者说是找到 **所有** 可行解的时间复杂度。

如果给定的数字越少，相当于给出的约束条件越少，对于计算机这种穷举策略来说，是更容易进行下去，而不容易走回头路进行回溯的，所以说
**如果仅仅找出一个可行解** ，这种情况下穷举的速度反而比较快。

至此，回溯算法就完成了，你可以用以上代码通过 LeetCode 的判题系统，下面我们来简单说下我是如何把这个回溯过程可视化出来的。

### 三、算法可视化

让算法帮我玩游戏的核心是算法，如果你理解了这个算法，剩下就是借助安卓脚本引擎 Auto.js 调 API 操作手机了，工具我都放在后台了，你等会儿就可以下载。

用伪码简单说下思路，我可以写两个函数：

```java
    void setNum(Button b, char n) {
       // 输入一个方格，将该方格设置为数字 n
    }
    
    void cancelNum(Button b) {
       // 输入一个方格，将该方格上的数字撤销
    }

```

回溯算法的核心框架如下， **只要在框架对应的位置加上对应的操作，即可将算法做选择、撤销选择的过程完全展示出来** ，也许这就是套路框架的魅力所在：

```java
    for (char ch = '1'; ch <= '9'; ch++) {
        Button b = new Button(r, c);
       // 做选择
        setNum(b, ch);
        board[i][j] = ch;
       // 继续穷举下一个
        backtrack(board, i, j + 1);
       // 撤销选择
        cancelNum(b);
        board[i][j] = '.';
    }

```

以上思路就可以模拟出算法穷举的过程：

![](https://labuladong.gitee.io/algo/images/sudoku/sudoku_process.gif)

**公众号后台回复关键词「数独」即可下载相应脚本、工具和游戏** ，Auto.js 是一款优秀的开源脚本引擎，可以用 JavaScript 操作安卓手机。把脚本代码 copy 进去即可运行， **注意只支持安卓手机哦** 。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


 ## 回溯算法最佳实践：括号生成
 读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 22. 括号生成（中等） ](https://leetcode-cn.com/problems/generate-parentheses)

**———–**

括号问题可以简单分成两类，一类是前文写过的 [ 括号的合法性判断 ](https://labuladong.gitee.io/algo/4/31/135/)
，一类是合法括号的生成。对于括号合法性的判断，主要是借助「栈」这种数据结构，而对于括号的生成，一般都要利用回溯递归的思想。

关于回溯算法，我们前文写过一篇 [ 回溯算法套路框架详解 ](https://labuladong.gitee.io/algo/4/28/105/)
反响非常好，读本文前应该读过那篇文章，这样你就能够进一步了解回溯算法的框架使用方法了。

回到正题，括号生成算法是 LeetCode 第 22 题，要求如下：

请你写一个算法，输入是一个正整数 ` n ` ，输出是 ` n ` 对儿括号的所有合法组合，函数签名如下：

```java
    vector<string> generateParenthesis(int n);

```

比如说，输入 ` n=3 ` ，输出为如下 5 个字符串：

```java
    "((()))",
    "(()())",
    "(())()",
    "()(())",
    "()()()"

```

有关括号问题，你只要记住以下性质，思路就很容易想出来：

**1、一个「合法」括号组合的左括号数量一定等于右括号数量，这个很好理解** 。

**2、对于一个「合法」的括号字符串组合` p ` ，必然对于任何 ` 0 <= i < len(p) ` 都有：子串 ` p[0..i]`中左括号的数量都大于或等于右括号的数量 ** 。

如果不跟你说这个性质，可能不太容易发现，但是稍微想一下，其实很容易理解，因为从左往右算的话，肯定是左括号多嘛，到最后左右括号数量相等，说明这个括号组合是合法的。

反之，比如这个括号组合 ` ))(( ` ，前几个子串都是右括号多于左括号，显然不是合法的括号组合。

下面就来手把手实践一下回溯算法框架。

## 回溯思路

明白了合法括号的性质，如何把这道题和回溯算法扯上关系呢？

算法输入一个整数 ` n ` ，让你计算 **` n ` 对儿括号 ** 能组成几种合法的括号组合，可以改写成如下问题：

**现在有` 2n ` 个位置，每个位置可以放置字符 ` ( ` 或者 ` ) ` ，组成的所有括号组合中，有多少个是合法的 ** ？

这个命题和题目的意思完全是一样的对吧，那么我们先想想如何得到全部 ` 2^(2n)`种组合，然后再根据我们刚才总结出的合法括号组合的性质筛选出合法的组合，不就完事儿了？

如何得到所有的组合呢？这就是标准的暴力穷举回溯框架啊，我们前文 [ 回溯算法套路框架详解 ](https://labuladong.gitee.io/algo/4/28/105/) 都总结过了：

```java
    result = []
    def backtrack(路径, 选择列表):
        if 满足结束条件:
            result.add(路径)
            return
        
        for 选择 in 选择列表:
            做选择
            backtrack(路径, 选择列表)
            撤销选择

```

那么对于我们的需求，如何打印所有括号组合呢？套一下框架就出来了，伪码如下：

```java
    void backtrack(int n, int i, string& track) {
       // i 代表当前的位置，共 2n 个位置
       // 穷举到最后一个位置了，得到一个长度为 2n 组合
        if (i == 2 * n) {
            print(track);
            return;
        }
    
       // 对于每个位置可以是左括号或者右括号两种选择
        for choice in ['(', ')'] {
            track.push(choice);// 做选择
           // 穷举下一个位置
            backtrack(n, i + 1, track);
            track.pop(choice);// 撤销选择
        }
    }

```

那么，现在能够打印所有括号组合了，如何从它们中筛选出合法的括号组合呢？​很简单，加几个条件进行「剪枝」就行了。

对于 ` 2n ` 个位置，必然有 ` n ` 个左括号， ` n ` 个右括号，所以我们不是简单的记录穷举位置 ` i ` ，而是 **用` left`记录还可以使用多少个左括号，用 ` right ` 记录还可以使用多少个右括号 ** ，这样就可以通过刚才总结的合法括号规律进行筛选了：

```java
    vector<string> generateParenthesis(int n) {
        if (n == 0) return {};
       // 记录所有合法的括号组合
        vector<string> res;
       // 回溯过程中的路径
        string track;
       // 可用的左括号和右括号数量初始化为 n
        backtrack(n, n, track, res);
        return res;
    }
    
   // 可用的左括号数量为 left 个，可用的右括号数量为 rgiht 个
    void backtrack(int left, int right, 
                string& track, vector<string>& res) {
       // 若左括号剩下的多，说明不合法
        if (right < left) return;
       // 数量小于 0 肯定是不合法的
        if (left < 0 || right < 0) return;
       // 当所有括号都恰好用完时，得到一个合法的括号组合
        if (left == 0 && right == 0) {
            res.push_back(track);
            return;
        }
        
       // 尝试放一个左括号
        track.push_back('(');// 选择
        backtrack(left - 1, right, track, res);
        track.pop_back();// 撤消选择
    
       // 尝试放一个右括号
        track.push_back(')');// 选择
        backtrack(left, right - 1, track, res);
        track.pop_back();// 撤消选择
    }

```

这样，我们的算法就完成了，算法的复杂度是多少呢？这个比较难分析， **对于递归相关的算法，时间复杂度这样计算（递归次数）*（递归函数本身的时间复杂度）**
。

` backtrack ` 就是我们的递归函数，其中没有任何 for 循环代码，所以递归函数本身的时间复杂度是 O(1)，但关键是这个函数的递归次数是多少？换句话说，给定一个 ` n ` ， ` backtrack`函数递归被调用了多少次？

我们前面怎么分析动态规划算法的递归次数的？主要是看「状态」的个数对吧。其实回溯算法和动态规划的本质都是穷举，只不过动态规划存在「重叠子问题」可以优化，而回溯算法不存在而已。

所以说这里也可以用「状态」这个概念， **对于` backtrack ` 函数，状态有三个，分别是 ` left, right, track ` **
，这三个变量的所有组合个数就是 ` backtrack ` 函数的状态个数（调用次数）。

` left ` 和 ` right ` 的组合好办，他俩取值就是 0~n 嘛，组合起来也就 ` n^2 ` 种而已；这个 ` track`的长度虽然取在 0~2n，但对于每一个长度，它还有指数级的括号组合，这个是不好算的。

说了这么多，就是想让大家知道这个算法的复杂度是指数级，而且不好算，这里就不具体展开了，是 ` 4^n/ sqrt(n)`，有兴趣的读者可以搜索一下「卡特兰数」相关的知识了解一下这个复杂度是怎么算的。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


 ## BFS 算法解题套路框架
 读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 111. 二叉树的最小深度（简单） ](https://leetcode-cn.com/problems/minimum-depth-of-
binary-tree)

[ 752. 打开转盘锁（中等） ](https://leetcode-cn.com/problems/open-the-lock)

**———–**

后台有很多人问起 BFS 和 DFS 的框架，今天就来说说吧。

首先，你要说我没写过 BFS 框架，这话没错，今天写个框架你背住就完事儿了。但要是说没写过 DFS 框架，那你还真是说错了， **其实 DFS 算法就是回溯算法**
，我们前文 [ 回溯算法框架套路详解 ](https://labuladong.gitee.io/algo/4/28/105/)
就写过了，而且写得不是一般得好，建议好好复习，嘿嘿嘿~

BFS 的核心思想应该不难理解的，就是把一些问题抽象成图，从一个点开始，向四周开始扩散。一般来说，我们写 BFS 算法都是用「队列」这种数据结构，每次将一个节点周围的所有节点加入队列。

BFS 相对 DFS 的最主要的区别是： **BFS 找到的路径一定是最短的，但代价就是空间复杂度可能比 DFS 大很多**
，至于为什么，我们后面介绍了框架就很容易看出来了。

本文就由浅入深写两道 BFS 的典型题目，分别是「二叉树的最小高度」和「打开密码锁的最少步数」，手把手教你怎么写 BFS 算法。

### 一、算法框架

要说框架的话，我们先举例一下 BFS 出现的常见场景好吧， **问题的本质就是让你在一幅「图」中找到从起点` start ` 到终点 ` target`的最近距离，这个例子听起来很枯燥，但是 BFS 算法问题其实都是在干这个事儿 ** ，把枯燥的本质搞清楚了，再去欣赏各种问题的包装才能胸有成竹嘛。

这个广义的描述可以有各种变体，比如走迷宫，有的格子是围墙不能走，从起点到终点的最短距离是多少？如果这个迷宫带「传送门」可以瞬间传送呢？

再比如说两个单词，要求你通过某些替换，把其中一个变成另一个，每次只能替换一个字符，最少要替换几次？

再比如说连连看游戏，两个方块消除的条件不仅仅是图案相同，还得保证两个方块之间的最短连线不能多于两个拐点。你玩连连看，点击两个坐标，游戏是如何判断它俩的最短连线有几个拐点的？

再比如……

净整些花里胡哨的，这些问题都没啥奇技淫巧，本质上就是一幅「图」，让你从一个起点，走到终点，问最短路径。这就是 BFS 的本质，框架搞清楚了直接默写就好。

![](https://labuladong.gitee.io/algo/images/BFS/0.jpeg)

记住下面这个框架就 OK 了：

```java
   // 计算从起点 start 到终点 target 的最近距离
    int BFS(Node start, Node target) {
        Queue<Node> q;// 核心数据结构
        Set<Node> visited;// 避免走回头路
        
        q.offer(start);// 将起点加入队列
        visited.add(start);
        int step = 0;// 记录扩散的步数
    
        while (q not empty) {
            int sz = q.size();
           /* 将当前队列中的所有节点向四周扩散 */
            for (int i = 0; i < sz; i++) {
                Node cur = q.poll();
               /* 划重点：这里判断是否到达终点 */
                if (cur is target)
                    return step;
               /* 将 cur 的相邻节点加入队列 */
                for (Node x : cur.adj()) {
                    if (x not in visited) {
                        q.offer(x);
                        visited.add(x);
                    }
                }
            }
           /* 划重点：更新步数在这里 */
            step++;
        }
    }

```

队列 ` q ` 就不说了，BFS 的核心数据结构； ` cur.adj() ` 泛指 ` cur ` 相邻的节点，比如说二维数组中， ` cur`上下左右四面的位置就是相邻节点； ` visited`的主要作用是防止走回头路，大部分时候都是必须的，但是像一般的二叉树结构，没有子节点到父节点的指针，不会走回头路就不需要 ` visited ` 。

### 二、二叉树的最小高度

先来个简单的问题实践一下 BFS 框架吧，判断一棵二叉树的 **最小** 高度，这也是 LeetCode 第 111 题，看一下题目：

![](https://labuladong.gitee.io/algo/images/BFS/title1.jpg)

怎么套到 BFS 的框架里呢？首先明确一下起点 ` start ` 和终点 ` target ` 是什么，怎么判断到达了终点？

**显然起点就是` root ` 根节点，终点就是最靠近根节点的那个「叶子节点」嘛 ** ，叶子节点就是两个子节点都是 ` null ` 的节点：

```java
    if (cur.left == null && cur.right == null) 
       // 到达叶子节点

```

那么，按照我们上述的框架稍加改造来写解法即可：

```java
    int minDepth(TreeNode root) {
        if (root == null) return 0;
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);
       // root 本身就是一层，depth 初始化为 1
        int depth = 1;
        
        while (!q.isEmpty()) {
            int sz = q.size();
           /* 将当前队列中的所有节点向四周扩散 */
            for (int i = 0; i < sz; i++) {
                TreeNode cur = q.poll();
               /* 判断是否到达终点 */
                if (cur.left == null && cur.right == null) 
                    return depth;
               /* 将 cur 的相邻节点加入队列 */
                if (cur.left != null)
                    q.offer(cur.left);
                if (cur.right != null) 
                    q.offer(cur.right);
            }
           /* 这里增加步数 */
            depth++;
        }
        return depth;
    }

```

这里注意这个 ` while ` 循环和 ` for ` 循环的配合， **` while ` 循环控制一层一层往下走， ` for ` 循环利用 ` sz
` 变量控制从左到右遍历每一层二叉树节点 ** ：

![](https://labuladong.gitee.io/algo/images/dijkstra/1.jpeg)

这一点很重要，这个形式在普通 BFS 问题中都很常见，但是在 [ Dijkstra 算法模板框架 ](https://labuladong.gitee.io/algo/2/18/41/)
中我们修改了这种代码模式，读完并理解本文后你可以去看看 BFS 算法是如何演变成 Dijkstra 算法在加权图中寻找最短路径的。

话说回来，二叉树本身是很简单的数据结构，我想上述代码你应该可以理解的，其实其他复杂问题都是这个框架的变形，再探讨复杂问题之前，我们解答两个问题：

**1、为什么 BFS 可以找到最短距离，DFS 不行吗** ？

首先，你看 BFS 的逻辑， ` depth ` 每增加一次，队列中的所有节点都向前迈一步，这保证了第一次到达终点的时候，走的步数是最少的。

DFS 不能找最短路径吗？其实也是可以的，但是时间复杂度相对高很多。你想啊，DFS 实际上是靠递归的堆栈记录走过的路径，你要找到最短路径，肯定得把二叉树中所有树杈都探索完才能对比出最短的路径有多长对不对？而 BFS
借助队列做到一次一步「齐头并进」，是可以在不遍历完整棵树的条件下找到最短距离的。

形象点说，DFS 是线，BFS 是面；DFS 是单打独斗，BFS 是集体行动。这个应该比较容易理解吧。

**2、既然 BFS 那么好，为啥 DFS 还要存在** ？

BFS 可以找到最短距离，但是空间复杂度高，而 DFS 的空间复杂度较低。

还是拿刚才我们处理二叉树问题的例子，假设给你的这个二叉树是满二叉树，节点数为 ` N ` ，对于 DFS 算法来说，空间复杂度无非就是递归堆栈，最坏情况下顶多就是树的高度，也就是 ` O(logN) ` 。

但是你想想 BFS 算法，队列中每次都会储存着二叉树一层的节点，这样的话最坏情况下空间复杂度应该是树的最底层节点的数量，也就是 ` N/2 ` ，用 Big O 表示的话也就是 ` O(N) ` 。

由此观之，BFS 还是有代价的，一般来说在找最短路径的时候使用 BFS，其他时候还是 DFS 使用得多一些（主要是递归代码好写）。

好了，现在你对 BFS 了解得足够多了，下面来一道难一点的题目，深化一下框架的理解吧。

### 三、解开密码锁的最少次数

这道 LeetCode 题目是第 752 题，比较有意思：

![](https://labuladong.gitee.io/algo/images/BFS/title2.jpg)

题目中描述的就是我们生活中常见的那种密码锁，若果没有任何约束，最少的拨动次数很好算，就像我们平时开密码锁那样直奔密码拨就行了。

但现在的难点就在于，不能出现 ` deadends ` ，应该如何计算出最少的转动次数呢？

**第一步，我们不管所有的限制条件，不管` deadends ` 和 ` target`的限制，就思考一个问题：如果让你设计一个算法，穷举所有可能的密码组合，你怎么做 ** ？

穷举呗，再简单一点，如果你只转一下锁，有几种可能？总共有 4 个位置，每个位置可以向上转，也可以向下转，也就是有 8 种可能对吧。

比如说从 ` "0000" ` 开始，转一次，可以穷举出 ` "1000", "9000", "0100", "0900"... ` 共 8 种密码。然后，再以这 8 种密码作为基础，对每个密码再转一下，穷举出所有可能…

**仔细想想，这就可以抽象成一幅图，每个节点有 8 个相邻的节点** ，又让你求最短距离，这不就是典型的 BFS 嘛，框架就可以派上用场了，先写出一个「简陋」的 BFS 框架代码再说别的：

```java
   // 将 s[j] 向上拨动一次
    String plusOne(String s, int j) {
        char[] ch = s.toCharArray();
        if (ch[j] == '9')
            ch[j] = '0';
        else
            ch[j] += 1;
        return new String(ch);
    }
   // 将 s[i] 向下拨动一次
    String minusOne(String s, int j) {
        char[] ch = s.toCharArray();
        if (ch[j] == '0')
            ch[j] = '9';
        else
            ch[j] -= 1;
        return new String(ch);
    }
    
   // BFS 框架，打印出所有可能的密码
    void BFS(String target) {
        Queue<String> q = new LinkedList<>();
        q.offer("0000");
        
        while (!q.isEmpty()) {
            int sz = q.size();
           /* 将当前队列中的所有节点向周围扩散 */
            for (int i = 0; i < sz; i++) {
                String cur = q.poll();
               /* 判断是否到达终点 */
                System.out.println(cur);
    
               /* 将一个节点的相邻节点加入队列 */
                for (int j = 0; j < 4; j++) {
                    String up = plusOne(cur, j);
                    String down = minusOne(cur, j);
                    q.offer(up);
                    q.offer(down);
                }
            }
           /* 在这里增加步数 */
        }
        return;
    }

```

> PS：这段代码当然有很多问题，但是我们做算法题肯定不是一蹴而就的，而是从简陋到完美的。不要完美主义，咱要慢慢来，好不。

**这段 BFS 代码已经能够穷举所有可能的密码组合了，但是显然不能完成题目，有如下问题需要解决** ：

1、会走回头路。比如说我们从 ` "0000" ` 拨到 ` "1000" ` ，但是等从队列拿出 ` "1000" ` 时，还会拨出一个 ` "0000"
` ，这样的话会产生死循环。

2、没有终止条件，按照题目要求，我们找到 ` target ` 就应该结束并返回拨动的次数。

3、没有对 ` deadends ` 的处理，按道理这些「死亡密码」是不能出现的，也就是说你遇到这些密码的时候需要跳过。

如果你能够看懂上面那段代码，真得给你鼓掌，只要按照 BFS 框架在对应的位置稍作修改即可修复这些问题：

```java
    int openLock(String[] deadends, String target) {
       // 记录需要跳过的死亡密码
        Set<String> deads = new HashSet<>();
        for (String s : deadends) deads.add(s);
       // 记录已经穷举过的密码，防止走回头路
        Set<String> visited = new HashSet<>();
        Queue<String> q = new LinkedList<>();
       // 从起点开始启动广度优先搜索
        int step = 0;
        q.offer("0000");
        visited.add("0000");
        
        while (!q.isEmpty()) {
            int sz = q.size();
           /* 将当前队列中的所有节点向周围扩散 */
            for (int i = 0; i < sz; i++) {
                String cur = q.poll();
                
               /* 判断是否到达终点 */
                if (deads.contains(cur))
                    continue;
                if (cur.equals(target))
                    return step;
                
               /* 将一个节点的未遍历相邻节点加入队列 */
                for (int j = 0; j < 4; j++) {
                    String up = plusOne(cur, j);
                    if (!visited.contains(up)) {
                        q.offer(up);
                        visited.add(up);
                    }
                    String down = minusOne(cur, j);
                    if (!visited.contains(down)) {
                        q.offer(down);
                        visited.add(down);
                    }
                }
            }
           /* 在这里增加步数 */
            step++;
        }
       // 如果穷举完都没找到目标密码，那就是找不到了
        return -1;
    }

```

至此，我们就解决这道题目了。有一个比较小的优化：可以不需要 ` dead ` 这个哈希集合，可以直接将这些元素初始化到 ` visited`集合中，效果是一样的，可能更加优雅一些。

### 四、双向 BFS 优化

你以为到这里 BFS 算法就结束了？恰恰相反。BFS 算法还有一种稍微高级一点的优化思路： **双向 BFS** ，可以进一步提高算法的效率。

篇幅所限，这里就提一下区别： **传统的 BFS 框架就是从起点开始向四周扩散，遇到终点时停止；而双向 BFS 则是从起点和终点同时开始扩散，当两边有交集的时候停止** 。

为什么这样能够能够提升效率呢？其实从 Big O 表示法分析算法复杂度的话，它俩的最坏复杂度都是 ` O(N) ` ，但是实际上双向 BFS 确实会快一些，我给你画两张图看一眼就明白了：

![](https://labuladong.gitee.io/algo/images/BFS/1.jpeg) ![](https://labuladong.gitee.io/algo/images/BFS/2.jpeg)

图示中的树形结构，如果终点在最底部，按照传统 BFS 算法的策略，会把整棵树的节点都搜索一遍，最后找到 ` target ` ；而双向 BFS 其实只遍历了半棵树就出现了交集，也就是找到了最短距离。从这个例子可以直观地感受到，双向 BFS
是要比传统 BFS 高效的。

**不过，双向 BFS 也有局限，因为你必须知道终点在哪里** 。比如我们刚才讨论的二叉树最小高度的问题，你一开始根本就不知道终点在哪里，也就无法使用双向 BFS；但是第二个密码锁的问题，是可以使用双向 BFS
算法来提高效率的，代码稍加修改即可：

```java
    int openLock(String[] deadends, String target) {
        Set<String> deads = new HashSet<>();
        for (String s : deadends) deads.add(s);
       // 用集合不用队列，可以快速判断元素是否存在
        Set<String> q1 = new HashSet<>();
        Set<String> q2 = new HashSet<>();
        Set<String> visited = new HashSet<>();
        
        int step = 0;
        q1.add("0000");
        q2.add(target);
        
        while (!q1.isEmpty() && !q2.isEmpty()) {
           // 哈希集合在遍历的过程中不能修改，用 temp 存储扩散结果
            Set<String> temp = new HashSet<>();
    
           /* 将 q1 中的所有节点向周围扩散 */
            for (String cur : q1) {
               /* 判断是否到达终点 */
                if (deads.contains(cur))
                    continue;
                if (q2.contains(cur))
                    return step;
                visited.add(cur);
    
               /* 将一个节点的未遍历相邻节点加入集合 */
                for (int j = 0; j < 4; j++) {
                    String up = plusOne(cur, j);
                    if (!visited.contains(up))
                        temp.add(up);
                    String down = minusOne(cur, j);
                    if (!visited.contains(down))
                        temp.add(down);
                }
            }
           /* 在这里增加步数 */
            step++;
           // temp 相当于 q1
           // 这里交换 q1 q2，下一轮 while 就是扩散 q2
            q1 = q2;
            q2 = temp;
        }
        return -1;
    }

```

双向 BFS 还是遵循 BFS 算法框架的，只是 **不再使用队列，而是使用 HashSet 方便快速判断两个集合是否有交集** 。

另外的一个技巧点就是 **while 循环的最后交换` q1 ` 和 ` q2 ` 的内容 ** ，所以只要默认扩散 ` q1 ` 就相当于轮流扩散`q1 ` 和 ` q2 ` 。

其实双向 BFS 还有一个优化，就是在 while 循环开始时做一个判断：

```java
   // ...
    while (!q1.isEmpty() && !q2.isEmpty()) {
        if (q1.size() > q2.size()) {
           // 交换 q1 和 q2
            temp = q1;
            q1 = q2;
            q2 = temp;
        }
       // ...

```

为什么这是一个优化呢？

因为按照 BFS 的逻辑，队列（集合）中的元素越多，扩散之后新的队列（集合）中的元素就越多；在双向 BFS 算法中，如果我们每次都选择一个较小的集合进行扩散，那么占用的空间增长速度就会慢一些，效率就会高一些。

不过话说回来， **无论传统 BFS 还是双向 BFS，无论做不做优化，从 Big O 衡量标准来看，时间复杂度都是一样的** ，只能说双向 BFS 是一种 trick，算法运行的速度会相对快一点，掌握不掌握其实都无所谓。最关键的是把
BFS 通用框架记下来，反正所有 BFS 算法都可以用它套出解法。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


 ## 如何用 BFS 算法秒杀各种智力题
 读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 773. 滑动谜题（困难） ](https://leetcode-cn.com/problems/sliding-puzzle)

**———–**

滑动拼图游戏大家应该都玩过，下图是一个 4x4 的滑动拼图：

![](https://labuladong.gitee.io/algo/images/sliding_puzzle/1.jpeg)

拼图中有一个格子是空的，可以利用这个空着的格子移动其他数字。你需要通过移动这些数字，得到某个特定排列顺序，这样就算赢了。

我小时候还玩过一款叫做「华容道」的益智游戏，也和滑动拼图比较类似：

![](https://labuladong.gitee.io/algo/images/sliding_puzzle/2.jpeg)

那么这种游戏怎么玩呢？我记得是有一些套路的，类似于魔方还原公式。但是我们今天不来研究让人头秃的技巧，
**这些益智游戏通通可以用暴力搜索算法解决，所以今天我们就学以致用，用 BFS 算法框架来秒杀这些游戏** 。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**

应合作方要求，本文不便在此发布，请扫码关注回复关键词「bfs」查看：

![](https://labuladong.gitee.io/algo/images/qrcode.jpg)

 # 数学运算技巧

1、《算法秘籍》和《刷题笔记》两本 PDF 下载 [ 点这里

](https://mp.weixin.qq.com/s/X-fE9sR4BLi6T9pn7xP4pg) 。

2、刷题插件下载及使用手册 [ 点这里 ](https://mp.weixin.qq.com/s/wIxflO1dvXzDlibhEcENcQ) 。

3、公众号菜单栏参与 [ 21 天算法挑战活动 ](https://mp.weixin.qq.com/s/eUG2OOzY3k_ZTz-CFvtv5Q) 。

 ## 常用的位操作
 读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 191. 位1的个数（简单） ](https://leetcode-cn.com/problems/number-of-1-bits)

[ 231. 2的幂（简单） ](https://leetcode-cn.com/problems/power-of-two/)

[ 136. 只出现一次的数字（简单） ](https://leetcode-cn.com/problems/single-number/)

**———–**

本文分两部分，第一部分列举几个有趣的位操作，第二部分讲解算法中常用的 ` n & (n - 1)`操作，顺便把用到这个技巧的算法题列出来讲解一下。因为位操作很简单，所以假设读者已经了解与、或、异或这三种基本操作。

位操作（Bit Manipulation）可以玩出很多奇技淫巧，但是这些技巧大部分都过于晦涩，没必要深究，读者只要记住一些有用的操作即可。

### 一、几个有趣的位操作

1. **利用或操作` | ` 和空格将英文字符转换为小写 **

```java
    ('a' | ' ') = 'a'
    ('A' | ' ') = 'a'

```

2. **利用与操作` & ` 和下划线将英文字符转换为大写 **

```java
    ('b' & '_') = 'B'
    ('B' & '_') = 'B'

```

3. **利用异或操作` ^ ` 和空格进行英文字符大小写互换 **

```java
    ('d' ^ ' ') = 'D'
    ('D' ^ ' ') = 'd'

```

以上操作能够产生奇特效果的原因在于 ASCII 编码。字符其实就是数字，恰巧这些字符对应的数字通过位运算就能得到正确的结果，有兴趣的读者可以查 ASCII 码表自己算算，本文就不展开讲了。

4. **判断两个数是否异号**

```java
    int x = -1, y = 2;
    bool f = ((x ^ y) < 0);// true
    
    int x = 3, y = 2;
    bool f = ((x ^ y) < 0);// false

```

这个技巧还是很实用的，利用的是补码编码的符号位。如果不用位运算来判断是否异号，需要使用 if else 分支，还挺麻烦的。读者可能想利用乘积或者商来判断两个数是否异号，但是这种处理方式可能造成溢出，从而出现错误。

5. **不用临时变量交换两个数**

```java
    int a = 1, b = 2;
    a ^= b;
    b ^= a;
    a ^= b;
   // 现在 a = 2, b = 1

```

6. **加一**

```java
    int n = 1;
    n = -~n;
   // 现在 n = 2

```

7. **减一**

```java
    int n = 2;
    n = ~-n;
   // 现在 n = 1

```

> PS：上面这三个操作就纯属装逼用的，没啥实际用处，大家了解了解乐呵一下就行。

### 二、算法常用操作

` n&(n-1) ` 这个操作是算法中常见的，作用是消除数字 ` n ` 的二进制表示中的最后一个 1。

看个图就很容易理解了：

![](https://labuladong.gitee.io/algo/images/%E4%BD%8D%E6%93%8D%E4%BD%9C/1.png)

其核心逻辑就是， ` n - 1 ` 一定可以消除最后一个 1，同时把其后的 0 都变成 1，这样再和 ` n ` 做一次 ` &`运算，就可以仅仅把最后一个 1 变成 0 了。

**1、计算汉明权重（Hamming Weight）**

![](https://labuladong.gitee.io/algo/images/%E4%BD%8D%E6%93%8D%E4%BD%9C/title.png)

就是让你返回 ` n ` 的二进制表示中有几个 1。因为 ` n & (n - 1) ` 可以消除最后一个 1，所以可以用一个循环不停地消除 1 同时计数，直到 ` n ` 变成 0 为止。

```java
    int hammingWeight(int n) {
        int res = 0;
        while (n != 0) {
            n = n & (n - 1);
            res++;
        }
        return res;
    }

```

**2、判断一个数是不是 2 的指数**

一个数如果是 2 的指数，那么它的二进制表示一定只含有一个 1：

```java
    2^0 = 1 = 0b0001
    2^1 = 2 = 0b0010
    2^2 = 4 = 0b0100

```

如果使用 ` n & (n-1) ` 的技巧就很简单了（注意运算符优先级，括号不可以省略）：

```java
    boolean isPowerOfTwo(int n) {
        if (n <= 0) return false;
        return (n & (n - 1)) == 0;
    }

```

**3、查找只出现一次的元素**

![](https://labuladong.gitee.io/algo/images/%e4%bd%8d%e6%93%8d%e4%bd%9c/title1.png)

这里就可以运用异或运算的性质：

一个数和它本身做异或运算结果为 0，即 ` a ^ a = 0 ` ；一个数和 0 做异或运算的结果为它本身，即 ` a ^ 0 = a ` 。

对于这道题目，我们只要把所有数字进行异或，成对儿的数字就会变成 0，落单的数字和 0 做异或还是它本身，所以最后异或的结果就是只出现一次的元素：

```java
    int singleNumber(int[] nums) {
        int res = 0;
        for (int n : nums) {
            res ^= n;
        }
        return res;
    }

```

以上便是一些有趣/常用的位操作。其实位操作的技巧很多，有一个叫做 Bit Twiddling Hacks 的外国网站收集了几乎所有位操作的黑科技玩法，感兴趣的读者可以查看：

[ http://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel

](http://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel)

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


 ## 讲两道常考的阶乘算法题
 读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 172. 阶乘后的零（简单） ](https://leetcode-cn.com/problems/factorial-trailing-zeroes)

[ 793. 阶乘后 K 个零（困难） ](https://leetcode-cn.com/problems/preimage-size-of-
factorial-zeroes-function)

**———–**

笔试题中经常看到阶乘相关的题目，今天说两个最常见的题目：

**1、输入一个非负整数` n ` ，请你计算阶乘 ` n! ` 的结果末尾有几个 0 ** 。

比如说输入 ` n = 5 ` ，算法返回 1，因为 ` 5! = 120 ` ，末尾有一个 0。

函数签名如下：

```java
    int trailingZeroes(int n);

```

**2、输入一个非负整数` K ` ，请你计算有多少个 ` n ` ，满足 ` n! ` 的结果末尾恰好有 ` K ` 个 0 ** 。

比如说输入 ` K = 1 ` ，算法返回 5，因为 ` 5!,6!,7!,8!,9! ` 这 5 个阶乘的结果最后只有一个 0，即有 5 个 ` n`满足条件。

函数签名如下：

```java
    int preimageSizeFZF(int K);

```

我把这两个题放在一起，肯定是因为它们有共性，下面我们来逐一分析。

### 题目一

肯定不可能真去把 ` n! ` 的结果算出来，阶乘增长可是比指数增长都恐怖，趁早死了这条心吧。

那么，结果的末尾的 0 从哪里来的？我们有没有投机取巧的方法计算出来？

首先，两个数相乘结果末尾有 0，一定是因为两个数中有因子 2 和 5，因为 10 = 2 x 5。

**也就是说，问题转化为：` n! ` 最多可以分解出多少个因子 2 和 5 ** ？

比如说 ` n = 25 ` ，那么 ` 25! ` 最多可以分解出几个 2 和 5 相乘？这个主要取决于能分解出几个因子 5，因为每个偶数都能分解出因子 2，因子 2 肯定比因子 5 多得多。

` 25! ` 中 5 可以提供一个，10 可以提供一个，15 可以提供一个，20 可以提供一个，25 可以提供两个，总共有 6 个因子 5，所以`25! ` 的结果末尾就有 6 个 0。

**现在，问题转化为：` n! ` 最多可以分解出多少个因子 5 ** ？

难点在于像 25，50，125 这样的数，可以提供不止一个因子 5，怎么才能不漏掉呢？

这样，我们假设 ` n = 125 ` ，来算一算 ` 125! ` 的结果末尾有几个 0：

首先，125/ 5 = 25，这一步就是计算有多少个像 5，15，20，25 这些 5 的倍数，它们一定可以提供一个因子 5。

但是，这些足够吗？刚才说了，像 25，50，75 这些 25 的倍数，可以提供两个因子 5，那么我们再计算出 ` 125! ` 中有 125/ 25 = 5 个 25 的倍数，它们每人可以额外再提供一个因子 5。

够了吗？我们发现 125 = 5 x 5 x 5，像 125，250 这些 125 的倍数，可以提供 3 个因子 5，那么我们还得再计算出 ` 125!`中有 125/ 125 = 1 个 125 的倍数，它还可以额外再提供一个因子 5。

这下应该够了， ` 125! ` 最多可以分解出 25 + 5 + 1 = 31 个因子 5，也就是说阶乘结果的末尾有 31 个 0。

理解了这个思路，就可以理解解法代码了：

```java
    int trailingZeroes(int n) {
        int res = 0;
        long divisor = 5;
        while (divisor <= n) {
            res += n/ divisor;
            divisor *= 5;
        }
        return res;
    }

```

这里 ` divisor ` 变量使用 long 型，因为假如 ` n ` 比较大，考虑 while 循环的结束条件， ` divisor`可能出现整型溢出。

上述代码可以改写地更简单一些：

```java
    int trailingZeroes(int n) {
        int res = 0;
        for (int d = n; d/ 5 > 0; d = d/ 5) {
            res += d/ 5;
        }
        return res;
    }

```

这样，这道题就解决了，时间复杂度是底数为 5 的对数，也就是 ` O(logN) ` ，我们看看下如何基于这道题的解法完成下一道题目。

### 第二题

现在是给你一个非负整数 ` K ` ，问你有多少个 ` n ` ，使得 ` n! ` 结果末尾有 ` K ` 个 0。

一个直观地暴力解法就是穷举呗，因为随着 ` n ` 的增加， ` n! ` 肯定是递增的， ` trailingZeroes(n!)`肯定也是递增的，伪码逻辑如下：

```java
    int res = 0;
    for (int n = 0; n < +inf; n++) {
        if (trailingZeroes(n) < K) {
            continue;
        }
        if (trailingZeroes(n) > K) {
            break;
        }
        if (trailingZeroes(n) == K) {
            res++;
        }
    }
    return res;

```

前文 [ 二分查找如何运用 ](https://labuladong.gitee.io/algo/2/20/58/) 说过， **对于这种具有单调性的函数，用 for 循环遍历，可以用二分查找进行降维打击** ，对吧？

搜索有多少个 ` n ` 满足 ` trailingZeroes(n) == K ` ，其实就是在问， **满足条件的` n`最小是多少，最大是多少，最大值和最小值一减，就可以算出来有多少个 ` n ` 满足条件了 ** ，对吧？那不就是 [ 二分查找

](https://labuladong.gitee.io/algo/2/20/57/) 中「搜索左侧边界」和「搜索右侧边界」这两个事儿嘛？

先不急写代码，因为二分查找需要给一个搜索区间，也就是上界和下界，上述伪码中 ` n ` 的下界显然是 0，但上界是 ` +inf`，这个正无穷应该如何表示出来呢？

首先，数学上的正无穷肯定是无法编程表示出来的，我们一般的方法是用一个非常大的值，大到这个值一定不会被取到。比如说 int 类型的最大值 ` INT_MAX
` （2^31 - 1，大约 31 亿），还不够的话就 long 类型的最大值 ` LONG_MAX ` （2^63 - 1，这个值就大到离谱了）。

那么我怎么知道需要多大才能「一定不会被取到」呢？ **这就需要认真读题，看看题目给的数据范围有多大** 。

这道题目实际上给了限制， ` K ` 是在 ` [0, 10^9] ` 区间内的整数，也就是说， ` trailingZeroes(n)`的结果最多可以达到 ` 10^9 ` 。

然后我们可以反推，当 ` trailingZeroes(n) ` 结果为 ` 10^9 ` 时， ` n`为多少？这个不需要你精确计算出来，你只要找到一个数 ` hi ` ，使得 ` trailingZeroes(hi) ` 比 ` 10^9 ` 大，就可以把
` hi ` 当做正无穷，作为搜索区间的上界。

刚才说了， ` trailingZeroes ` 函数是单调函数，那我们就可以猜，先算一下 ` trailingZeroes(INT_MAX)`的结果，比 ` 10^9 ` 小一些，那再用 ` LONG_MAX ` 算一下，远超 ` 10^9 ` 了，所以 ` LONG_MAX`可以作为搜索的上界。

**注意为了避免整型溢出的问题，` trailingZeroes ` 函数需要把所有数据类型改成 long ** ：

```java
   // 逻辑不变，数据类型全部改成 long
    long trailingZeroes(long n) {
        long res = 0;
        for (long d = n; d/ 5 > 0; d = d/ 5) {
            res += d/ 5;
        }
        return res;
    }

```

现在就明确了问题：

**在区间` [0, LONG_MAX] ` 中寻找满足 ` trailingZeroes(n) == K ` 的左侧边界和右侧边界 ** 。

根据前文 [ 二分查找算法框架 ](https://labuladong.gitee.io/algo/2/20/57/) ，可以直接把搜索左侧边界和右侧边界的框架 copy 过来：

```java
   /* 主函数 */
    public int preimageSizeFZF(int K) {
       // 左边界和右边界之差 + 1 就是答案
        return (int)(right_bound(K) - left_bound(K) + 1);
    }
    
   /* 搜索 trailingZeroes(n) == K 的左侧边界 */
    long left_bound(int target) {
        long lo = 0, hi = Long.MAX_VALUE;
        while (lo < hi) {
            long mid = lo + (hi - lo)/ 2;
            if (trailingZeroes(mid) < target) {
                lo = mid + 1;
            } else if (trailingZeroes(mid) > target) {
                hi = mid;
            } else {
                hi = mid;
            }
        }
        return lo;
    }
    
   /* 搜索 trailingZeroes(n) == K 的右侧边界 */
    long right_bound(int target) {
        long lo = 0, hi = Long.MAX_VALUE;
        while (lo < hi) {
            long mid = lo + (hi - lo)/ 2;
            if (trailingZeroes(mid) < target) {
                lo = mid + 1;
            } else if (trailingZeroes(mid) > target) {
                hi = mid;
            } else {
                lo = mid + 1;
            }
        }
        return lo - 1;
    }

```

如果对二分查找的框架有任何疑问，建议好好复习一下前文 [ 二分查找算法框架 ](https://labuladong.gitee.io/algo/2/20/57/) ，这里就不展开了。

现在，这道题基本上就解决了，我们来分析一下它的时间复杂度吧。

时间复杂度主要是二分搜索，从数值上来说 ` LONG_MAX ` 是 2^63 - 1，大得离谱，但是二分搜索是对数级的复杂度，log(LONG_MAX)
是一个常数；每次二分的时候都会调用一次 ` trailingZeroes ` 函数，复杂度 O(logK)；所以总体的时间复杂度就是 O(logK)。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


 ## 如何高效寻找素数
 读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 204. 计数质数（简单） ](https://leetcode-cn.com/problems/count-primes)

**———–**

素数的定义看起来很简单，如果一个数如果只能被 1 和它本身整除，那么这个数就是素数。

不要觉得素数的定义简单，恐怕没多少人真的能把素数相关的算法写得高效。比如让你写这样一个函数：

```java
   // 返回区间 [2, n) 中有几个素数 
    int countPrimes(int n)
    
   // 比如 countPrimes(10) 返回 4
   // 因为 2,3,5,7 是素数

```

你会如何写这个函数？我想大家应该会这样写：

```java
    int countPrimes(int n) {
        int count = 0;
        for (int i = 2; i < n; i++)
            if (isPrime(i)) count++;
        return count;
    }
    
   // 判断整数 n 是否是素数
    boolean isPrime(int n) {
        for (int i = 2; i < n; i++)
            if (n % i == 0)
               // 有其他整除因子
                return false;
        return true;
    }

```

这样写的话时间复杂度 O(n^2)，问题很大。 **首先你用 isPrime 函数来辅助的思路就不够高效；而且就算你要用 isPrime 函数，这样写算法也是存在计算冗余的** 。

先来简单说下 **如果你要判断一个数是不是素数，应该如何写算法** 。只需稍微修改一下上面的 isPrime 代码中的 for 循环条件：

```java
    boolean isPrime(int n) {
        for (int i = 2; i * i <= n; i++)
            ...
    }

```

换句话说， ` i ` 不需要遍历到 ` n ` ，而只需要到 ` sqrt(n) ` 即可。为什么呢，我们举个例子，假设 ` n = 12 ` 。

```java
    12 = 2 × 6
    12 = 3 × 4
    12 = sqrt(12) × sqrt(12)
    12 = 4 × 3
    12 = 6 × 2

```

可以看到，后两个乘积就是前面两个反过来，反转临界点就在 ` sqrt(n) ` 。

换句话说，如果在 ` [2,sqrt(n)] ` 这个区间之内没有发现可整除因子，就可以直接断定 ` n ` 是素数了，因为在区间`[sqrt(n),n] ` 也一定不会发现可整除因子。

现在， ` isPrime ` 函数的时间复杂度降为 O(sqrt(N))， **但是我们实现` countPrimes ` 函数其实并不需要这个函数 **
，以上只是希望读者明白 ` sqrt(n) ` 的含义，因为等会还会用到。

### 高效实现 ` countPrimes`
高效解决这个问题的核心思路是和上面的常规思路反着来：

首先从 2 开始，我们知道 2 是一个素数，那么 2 × 2 = 4, 3 × 2 = 6, 4 × 2 = 8… 都不可能是素数了。

然后我们发现 3 也是素数，那么 3 × 2 = 6, 3 × 3 = 9, 3 × 4 = 12… 也都不可能是素数了。

看到这里，你是否有点明白这个排除法的逻辑了呢？先看我们的第一版代码：

```java
    int countPrimes(int n) {
        boolean[] isPrime = new boolean[n];
       // 将数组都初始化为 true
        Arrays.fill(isPrime, true);
    
        for (int i = 2; i < n; i++) 
            if (isPrime[i]) 
               // i 的倍数不可能是素数了
                for (int j = 2 * i; j < n; j += i) 
                        isPrime[j] = false;
        
        int count = 0;
        for (int i = 2; i < n; i++)
            if (isPrime[i]) count++;
        
        return count;
    }

```

如果上面这段代码你能够理解，那么你已经掌握了整体思路，但是还有两个细微的地方可以优化。

首先，回想刚才判断一个数是否是素数的 ` isPrime ` 函数，由于因子的对称性，其中的 for 循环只需要遍历 ` [2,sqrt(n)]`就够了。这里也是类似的，我们外层的 for 循环也只需要遍历到 ` sqrt(n) ` ：

```java
    for (int i = 2; i * i < n; i++) 
        if (isPrime[i]) 
            ...

```

除此之外，很难注意到内层的 for 循环也可以优化。我们之前的做法是：

```java
    for (int j = 2 * i; j < n; j += i) 
        isPrime[j] = false;

```

这样可以把 ` i ` 的整数倍都标记为 ` false ` ，但是仍然存在计算冗余。

比如 ` n = 25 ` ， ` i = 4 ` 时算法会标记 4 × 2 = 8，4 × 3 = 12 等等数字，但是这两个数字已经被 ` i = 2
` 和 ` i = 3 ` 的 2 × 4 和 3 × 4 标记了。

我们可以稍微优化一下，让 ` j ` 从 ` i ` 的平方开始遍历，而不是从 ` 2 * i ` 开始：

```java
    for (int j = i * i; j < n; j += i) 
        isPrime[j] = false;

```

这样，素数计数的算法就高效实现了，其实这个算法有一个名字，叫做 Sieve of Eratosthenes。看下完整的最终代码：

```java
    int countPrimes(int n) {
        boolean[] isPrime = new boolean[n];
        Arrays.fill(isPrime, true);
        for (int i = 2; i * i < n; i++) 
            if (isPrime[i]) 
                for (int j = i * i; j < n; j += i) 
                    isPrime[j] = false;
        
        int count = 0;
        for (int i = 2; i < n; i++)
            if (isPrime[i]) count++;
        
        return count;
    }

```

**该算法的时间复杂度比较难算** ，显然时间跟这两个嵌套的 for 循环有关，其操作数应该是：

n/2 + n/3 + n/5 + n/7 + … = n × (1/2 + 1/3 + 1/5 + 1/7…)

括号中是素数的倒数。其最终结果是 O(N * loglogN)，有兴趣的读者可以查一下该算法的时间复杂度证明。

以上就是素数算法相关的全部内容。怎么样，是不是看似简单的问题却有不少细节可以打磨呀？

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


 ## 如何高效进行模幂运算
 读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 372. 超级次方（中等） ](https://leetcode-cn.com/problems/super-pow)

**———–**

今天来聊一道与数学运算有关的题目，LeetCode 372 题 Super Pow，让你进行巨大的幂运算，然后求余数。

```java
    int superPow(int a, vector<int>& b);

```

**要求你的算法返回幂运算` a^b ` 的计算结果与 1337 取模（mod，也就是余数）后的结果 ** 。就是你先得计算幂 ` a^b ` ，但是这个
` b ` 会非常大，所以 ` b ` 是用数组的形式表示的。

这个算法其实就是广泛应用于离散数学的模幂算法，至于为什么要对 1337 求模我们不管，单就这道题可以有三个难点：

**一是如何处理用数组表示的指数** ，现在 ` b ` 是一个数组，也就是说 ` b`可以非常大，没办法直接转成整型，否则可能溢出。你怎么把这个数组作为指数，进行运算呢？

**二是如何得到求模之后的结果** ？按道理，起码应该先把幂运算结果算出来，然后做 ` % 1337`这个运算。但问题是，指数运算你懂得，真实结果肯定会大得吓人，也就是说，算出来真实结果也没办法表示，早都溢出报错了。

**三是如何高效进行幂运算** ，进行幂运算也是有算法技巧的，如果你不了解这个算法，后文会讲解。

那么对于这几个问题，我们分开思考，逐个击破。

### 如何处理数组指数

**首先明确问题** ：现在 ` b ` 是一个数组，不能表示成整型，而且数组的特点是随机访问，删除最后一个元素比较高效。

不考虑求模的要求，以 ` b = [1,5,6,4] ` 来举例，结合指数运算的法则，我们可以发现这样的一个规律：

![](https://labuladong.gitee.io/algo/images/superPower/formula1.png)

看到这，我们的老读者肯定已经敏感地意识到了，这就是递归的标志呀！因为问题的规模缩小了：

```java
        superPow(a, [1,5,6,4])
    =>  superPow(a, [1,5,6])

```

那么，发现了这个规律，我们可以先简单翻译出代码框架：

```java
   // 计算 a 的 k 次方的结果
   // 后文我们会手动实现
    int mypow(int a, int k);
    
    int superPow(int a, vector<int>& b) {
       // 递归的 base case
        if (b.empty()) return 1;
       // 取出最后一个数
        int last = b.back();
        b.pop_back();
       // 将原问题化简，缩小规模递归求解
        int part1 = mypow(a, last);
        int part2 = mypow(superPow(a, b), 10);
       // 合并出结果
        return part1 * part2;
    }

```

到这里，应该都不难理解吧！我们已经解决了 ` b ` 是一个数组的问题，现在来看看如何处理 mod，避免结果太大而导致的整型溢出。

### 如何处理 mod 运算

**首先明确问题** ：由于计算机的编码方式，形如 ` (a * b) % base`这样的运算，乘法的结果可能导致溢出，我们希望找到一种技巧，能够化简这种表达式，避免溢出同时得到结果。

比如在二分查找中，我们求中点索引时用 ` (l+r)/2 ` 转化成 ` l+(r-l)/2 ` ，避免溢出的同时得到正确的结果。

那么，说一个关于模运算的技巧吧，毕竟模运算在算法中比较常见：

**` (a * b) % k = (a % k)(b % k) % k ` **

证明很简单，假设：

` a = Ak +B；b = Ck + D`
其中 ` A,B,C,D ` 是任意常数，那么：

` ab = ACk^2 + ADk + BCk +BD`
` ab % k = BD % k`
又因为：

` a % k = B；b % k = D`
所以：

` (a % k)(b % k) % k = BD % k`
综上，就可以得到我们化简求模的等式了。

**换句话说，对乘法的结果求模，等价于先对每个因子都求模，然后对因子相乘的结果再求模** 。

那么扩展到这道题，求一个数的幂不就是对这个数连乘么？所以说只要简单扩展刚才的思路，即可给幂运算求模：

```java
    int base = 1337;
   // 计算 a 的 k 次方然后与 base 求模的结果
    int mypow(int a, int k) {
       // 对因子求模
        a %= base;
        int res = 1;
        for (int _ = 0; _ < k; _++) {
           // 这里有乘法，是潜在的溢出点
            res *= a;
           // 对乘法结果求模
            res %= base;
        }
        return res;
    }
    
    int superPow(int a, vector<int>& b) {
        if (b.empty()) return 1;
        int last = b.back();
        b.pop_back();
        
        int part1 = mypow(a, last);
        int part2 = mypow(superPow(a, b), 10);
       // 每次乘法都要求模
        return (part1 * part2) % base;
    }

```

你看， **先对因子` a ` 求模，然后每次都对乘法结果 ` res ` 求模 ** ，这样可以保证 ` res *= a`这句代码执行时两个因子都是小于 ` base ` 的，也就一定不会造成溢出，同时结果也是正确的。

至此，这个问题就已经完全解决了，已经可以通过 LeetCode 的判题系统了。

但是有的读者可能会问，这个求幂的算法就这么简单吗，直接一个 for 循环累乘就行了？复杂度会不会比较高，有没有更高效地算法呢？

有更高效地算法的，但是单就这道题来说，已经足够了。

因为你想想，调用 ` mypow ` 函数传入的 ` k ` 最多有多大？ ` k ` 不过是 ` b ` 数组中的一个数，也就是在 0 到 9 之间，所以可以说这里每次调用 ` mypow ` 的时间复杂度就是 O(1)
。整个算法的时间复杂度是 O(N)，N 为 ` b ` 的长度。

但是既然说到幂运算了，不妨顺带说一下如何高效计算幂运算吧。

### 如何高效求幂

快速求幂的算法不止一个，就说一个我们应该掌握的基本思路吧。利用幂运算的性质，我们可以写出这样一个递归式：

![](https://labuladong.gitee.io/algo/images/superPower/formula2.png)

这个思想肯定比直接用 for 循环求幂要高效，因为有机会直接把问题规模（ ` b ` 的大小）直接减小一半，该算法的复杂度肯定是 log 级了。

那么就可以修改之前的 ` mypow ` 函数，翻译这个递归公式，再加上求模的运算：

```java
    int base = 1337;
    
    int mypow(int a, int k) {
        if (k == 0) return 1;
        a %= base;
    
        if (k % 2 == 1) {
           // k 是奇数
            return (a * mypow(a, k - 1)) % base;
        } else {
           // k 是偶数
            int sub = mypow(a, k/ 2);
            return (sub * sub) % base;
        }
    }

```

虽然对于题目，这个优化没有啥特别明显的效率提升，但是这个求幂算法已经升级了，以后如果别人让你写幂算法，起码要写出这个算法。

至此，Super Pow 就算完全解决了，包括了递归思想以及处理模运算、幂运算的技巧，可以说这个题目还是挺有意思的，你有什么有趣的题目，不妨留言分享一下。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


 ## 如何寻找缺失的元素
 读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 268. 丢失的数字（简单） ](https://leetcode-cn.com/problems/missing-number/)

**———–**

之前也有文章写过几个有趣的智力题，今天再聊一道巧妙的题目。

题目非常简单：

![](https://labuladong.gitee.io/algo/images/%e7%bc%ba%e5%a4%b1%e5%85%83%e7%b4%a0/title.png)

给一个长度为 n 的数组，其索引应该在 ` [0,n) ` ，但是现在你要装进去 n + 1 个元素 ` [0,n]`，那么肯定有一个元素装不下嘛，请你找出这个缺失的元素。

这道题不难的，我们应该很容易想到，把这个数组排个序，然后遍历一遍，不就很容易找到缺失的那个元素了吗？

或者说，借助数据结构的特性，用一个 HashSet 把数组里出现的数字都储存下来，再遍历 ` [0,n] ` 之间的数字，去 HashSet 中查询，也可以很容易查出那个缺失的元素。

排序解法的时间复杂度是 O(NlogN)，HashSet 的解法时间复杂度是 O(N)，但是还需要 O(N) 的空间复杂度存储 HashSet。

**第三种方法是位运算** 。

对于异或运算（ ` ^ ` ），我们知道它有一个特殊性质：一个数和它本身做异或运算结果为 0，一个数和 0 做异或运算还是它本身。

而且异或运算满足交换律和结合律，也就是说：

2 ^ 3 ^ 2 = 3 ^ (2 ^ 2) = 3 ^ 0 = 3

而这道题索就可以通过这些性质巧妙算出缺失的那个元素。比如说 ` nums = [0,3,1,4] ` ：

![](https://labuladong.gitee.io/algo/images/%e7%bc%ba%e5%a4%b1%e5%85%83%e7%b4%a0/1.jpg)

为了容易理解，我们假设先把索引补一位，然后让每个元素和自己相等的索引相对应：

![](https://labuladong.gitee.io/algo/images/%e7%bc%ba%e5%a4%b1%e5%85%83%e7%b4%a0/2.jpg)

这样做了之后，就可以发现除了缺失元素之外，所有的索引和元素都组成一对儿了，现在如果把这个落单的索引 2 找出来，也就找到了缺失的那个元素。

如何找这个落单的数字呢， **只要把所有的元素和索引做异或运算，成对儿的数字都会消为 0，只有这个落单的元素会剩下** ，也就达到了我们的目的。

```java
    int missingNumber(int[] nums) {
        int n = nums.length;
        int res = 0;
       // 先和新补的索引异或一下
        res ^= n;
       // 和其他的元素、索引做异或
        for (int i = 0; i < n; i++)
            res ^= i ^ nums[i];
        return res;
    }

```

![](https://labuladong.gitee.io/algo/images/%e7%bc%ba%e5%a4%b1%e5%85%83%e7%b4%a0/3.jpg)

由于异或运算满足交换律和结合律，所以总是能把成对儿的数字消去，留下缺失的那个元素的。

至此，时间复杂度 O(N)，空间复杂度 O(1)，已经达到了最优，我们是否就应该打道回府了呢？

如果这样想，说明我们受算法的毒害太深，随着我们学习的知识越来越多，反而容易陷入思维定式，这个问题其实还有一个特别简单的解法： **等差数列求和公式** 。

题目的意思可以这样理解：现在有个等差数列 0, 1, 2,…, n，其中少了某一个数字，请你把它找出来。那这个数字不就是 ` sum(0,1,..n) - sum(nums) ` 嘛？

```java
    int missingNumber(int[] nums) {
        int n = nums.length;
       // 公式：(首项 + 末项) * 项数/ 2
        int expect = (0 + n) * (n + 1)/ 2;
    
        int sum = 0;
        for (int x : nums) 
            sum += x;
        return expect - sum;

```

你看，这种解法应该是最简单的，但说实话，我自己也没想到这个解法，而且我去问了几个大佬，他们也没想到这个最简单的思路。相反，如果去问一个初中生，他也许很快就能想到。

做到这一步了，我们是否就应该打道回府了呢？

如果这样想，说明我们对细节的把控还差点火候。在用求和公式计算 ` expect ` 时，你考虑过 **整型溢出**
吗？如果相乘的结果太大导致溢出，那么结果肯定是错误的。

刚才我们的思路是把两个和都加出来然后相减，为了避免溢出，干脆一边求和一边减算了。很类似刚才位运算解法的思路，仍然假设 ` nums = [0,3,1,4]
` ，先补一位索引再让元素跟索引配对：

![](https://labuladong.gitee.io/algo/images/%e7%bc%ba%e5%a4%b1%e5%85%83%e7%b4%a0/xor.png)

我们让每个索引减去其对应的元素，再把相减的结果加起来，不就是那个缺失的元素吗？

```java
    public int missingNumber(int[] nums) {
        int n = nums.length;
        int res = 0;
       // 新补的索引
        res += n - 0;
       // 剩下索引和元素的差加起来
        for (int i = 0; i < n; i++) 
            res += i - nums[i];
        return res;
    }

```

由于加减法满足交换律和结合律，所以总是能把成对儿的数字消去，留下缺失的那个元素的。

至此这道算法题目经历九曲十八弯，终于再也没有什么坑了。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


 ## 如何同时寻找缺失和重复的元素
 读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 645. 错误的集合（简单） ](https://leetcode-cn.com/problems/set-mismatch)

**———–**

今天就聊一道很看起来简单却十分巧妙的问题，寻找缺失和重复的元素。之前的一篇文章「寻找缺失元素」也写过类似的问题，不过这次的和上次的问题使用的技巧不同。

这是 LeetCode 645 题，我来描述一下这个题目：

给一个长度为 ` N ` 的数组 ` nums ` ，其中本来装着 ` [1..N] ` 这 ` N ` 个元素，无序。但是现在出现了一些错误，`nums ` 中的一个元素出现了重复，也就同时导致了另一个元素的缺失。请你写一个算法，找到 ` nums ` 中的重复元素和缺失元素的值。

```java
   // 返回两个数字，分别是 {dup, missing}
    int[] findErrorNums(int[] nums);

```

比如说输入： ` nums = [1,2,2,4] ` ，算法返回 ` [2,3] ` 。

其实很容易解决这个问题，先遍历一次数组，用一个哈希表记录每个数字出现的次数，然后遍历一次 ` [1..N] ` ，看看那个元素重复出现，那个元素没有出现，就 OK 了。

但问题是，这个常规解法需要一个哈希表，也就是 O(N) 的空间复杂度。你看题目给的条件那么巧，在 ` [1..N]`的几个数字中恰好有一个重复，一个缺失， **事出反常必有妖** ，对吧。

O(N) 的时间复杂度遍历数组是无法避免的，所以我们可以想想办法如何降低空间复杂度，是否可以在 O(1) 的空间复杂度之下找到重复和确实的元素呢？

### 思路分析

这个问题的特点是，每个元素和数组索引有一定的对应关系。

我们现在自己改造下问题， **暂且将` nums ` 中的元素变为 ` [0..N-1] ` ，这样每个元素就和一个数组索引完全对应了，这样方便理解一些

** 。

如果说 ` nums ` 中不存在重复元素和缺失元素，那么每个元素就和唯一一个索引值对应，对吧？

现在的问题是，有一个元素重复了，同时导致一个元素缺失了，这会产生什么现象呢？ **会导致有两个元素对应到了同一个索引，而且会有一个索引没有元素对应过去**
。

那么，如果我能够通过某些方法，找到这个重复对应的索引，不就是找到了那个重复元素么？找到那个没有元素对应的索引，不就是找到了那个缺失的元素了么？

那么，如何不使用额外空间判断某个索引有多少个元素对应呢？这就是这个问题的精妙之处了：

**通过将每个索引对应的元素变成负数，以表示这个索引被对应过一次了** ：

![](https://labuladong.gitee.io/algo/images/dupmissing/1.gif)

如果出现重复元素 ` 4 ` ，直观结果就是，索引 ` 4 ` 所对应的元素已经是负数了：

![](https://labuladong.gitee.io/algo/images/dupmissing/2.jpg)

对于缺失元素 ` 3 ` ，直观结果就是，索引 ` 3 ` 所对应的元素是正数：

![](https://labuladong.gitee.io/algo/images/dupmissing/3.jpg)

对于这个现象，我们就可以翻译成代码了：

```java
    int[] findErrorNums(int[] nums) {
        int n = nums.length;
        int dup = -1;
        for (int i = 0; i < n; i++) {
            int index = Math.abs(nums[i]);
           // nums[index] 小于 0 则说明重复访问
            if (nums[index] < 0)
                dup = Math.abs(nums[i]);
            else
                nums[index] *= -1;
        }
    
        int missing = -1;
        for (int i = 0; i < n; i++)
           // nums[i] 大于 0 则说明没有访问
            if (nums[i] > 0)
                missing = i;
        
        return new int[]{dup, missing};
    }

```

这个问题就基本解决了，别忘了我们刚才为了方便分析，假设元素是 ` [0..N-1] ` ，但题目要求是 ` [1..N]`，所以只要简单修改两处地方即可得到原题的答案：

```java
    int[] findErrorNums(int[] nums) {
        int n = nums.length;
        int dup = -1;
        for (int i = 0; i < n; i++) {
           // 现在的元素是从 1 开始的
            int index = Math.abs(nums[i]) - 1;
            if (nums[index] < 0)
                dup = Math.abs(nums[i]);
            else
                nums[index] *= -1;
        }
    
        int missing = -1;
        for (int i = 0; i < n; i++)
            if (nums[i] > 0)
               // 将索引转换成元素
                missing = i + 1;
    
        return new int[]{dup, missing};
    }

```

其实，元素从 1 开始是有道理的，也必须从一个非零数开始。因为如果元素从 0 开始，那么 0 的相反数还是自己，所以如果数字 0 出现了重复或者缺失，算法就无法判断 0 是否被访问过。我们之前的假设只是为了简化题目，更通俗易懂。

### 最后总结

对于这种数组问题， **关键点在于元素和索引是成对儿出现的，常用的方法是排序、异或、映射** 。

映射的思路就是我们刚才的分析，将每个索引和元素映射起来，通过正负号记录某个元素是否被映射。

排序的方法也很好理解，对于这个问题，可以想象如果元素都被从小到大排序，如果发现索引对应的元素如果不相符，就可以找到重复和缺失的元素。

异或运算也是常用的，因为异或性质 ` a ^ a = 0, a ^ 0 = a`，如果将索引和元素同时异或，就可以消除成对儿的索引和元素，留下的就是重复或者缺失的元素。可以看看前文 [ 寻找缺失元素

](https://labuladong.gitee.io/algo/4/29/117/) ，介绍过这种方法。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


 ## 如何在无限序列中随机抽取元素
 读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 382. 链表随机节点（中等） ](https://leetcode-cn.com/problems/linked-list-random-node)

[ 398. 随机数索引（中等） ](https://leetcode-cn.com/problems/random-pick-index)

**———–**

我最近在力扣上做到两道非常有意思的题目，382 和 398 题，关于水塘抽样算法（Reservoir Sampling），本质上是一种随机概率算法，解法应该说会者不难，难者不会。

我第一次见到这个算法问题是谷歌的一道算法题：给你一个 **未知长度** 的链表，请你设计一个算法， **只能遍历一次** ，随机地返回链表中的一个节点。

这里说的随机是均匀随机（uniform random），也就是说，如果有 ` n ` 个元素，每个元素被选中的概率都是 ` 1/n`，不可以有统计意义上的偏差。

一般的想法就是，我先遍历一遍链表，得到链表的总长度 ` n ` ，再生成一个 ` [1,n]`之间的随机数为索引，然后找到索引对应的节点，不就是一个随机的节点了吗？

但题目说了，只能遍历一次，意味着这种思路不可行。题目还可以再泛化，给一个未知长度的序列，如何在其中随机地选择 ` k`个元素？想要解决这个问题，就需要著名的水塘抽样算法了。

### 算法实现

**先解决只抽取一个元素的问题** ，这个问题的难点在于，随机选择是「动态」的，比如说你现在你有 5 个元素，你已经随机选取了其中的某个元素 ` a`作为结果，但是现在再给你一个新元素 ` b ` ，你应该留着 ` a ` 还是将 ` b ` 作为结果呢，以什么逻辑选择 ` a ` 和 ` b`呢，怎么证明你的选择方法在概率上是公平的呢？

**先说结论，当你遇到第` i ` 个元素时，应该有 ` 1/i ` 的概率选择该元素， ` 1 - 1/i ` 的概率保持原有的选择 **
。看代码容易理解这个思路：

```java
   /* 返回链表中一个随机节点的值 */
    int getRandom(ListNode head) {
        Random r = new Random();
        int i = 0, res = 0;
        ListNode p = head;
       // while 循环遍历链表
        while (p != null) {
            i++;
           // 生成一个 [0, i) 之间的整数
           // 这个整数等于 0 的概率就是 1/i
            if (0 == r.nextInt(i)) {
                res = p.val;
            }
            p = p.next;
        }
        return res;
    }

```

对于概率算法，代码往往都是很浅显的，但是这种问题的关键在于证明，你的算法为什么是对的？为什么每次以 ` 1/i`的概率更新结果就可以保证结果是平均随机（uniform random）？

**证明** ：假设总共有 ` n ` 个元素，我们要的随机性无非就是每个元素被选择的概率都是 ` 1/n ` 对吧，那么对于第 ` i`个元素，它被选择的概率就是：

![](https://labuladong.gitee.io/algo/images/%e6%b0%b4%e5%a1%98%e6%8a%bd%e6%a0%b7/formula1.png)

第 ` i ` 个元素被选择的概率是 ` 1/i ` ，第 ` i+1 ` 次不被替换的概率是 ` 1 - 1/(i+1) ` ，以此类推，相乘就是第`i ` 个元素最终被选中的概率，就是 ` 1/n ` 。

因此，该算法的逻辑是正确的。

**同理，如果要随机选择` k ` 个数，只要在第 ` i ` 个元素处以 ` k/i ` 的概率选择该元素，以 ` 1 - k/i`的概率保持原有选择即可 ** 。代码如下：

```java
   /* 返回链表中 k 个随机节点的值 */
    int[] getRandom(ListNode head, int k) {
        Random r = new Random();
        int[] res = new int[k];
        ListNode p = head;
    
       // 前 k 个元素先默认选上
        for (int j = 0; j < k && p != null; j++) {
            res[j] = p.val;
            p = p.next;
        }
    
        int i = k;
       // while 循环遍历链表
        while (p != null) {
           // 生成一个 [0, i) 之间的整数
            int j = r.nextInt(++i);
           // 这个整数小于 k 的概率就是 k/i
            if (j < k) {
                res[j] = p.val;
            }
            p = p.next;
        }
        return res;
    }

```

对于数学证明，和上面区别不大：

![](https://labuladong.gitee.io/algo/images/%e6%b0%b4%e5%a1%98%e6%8a%bd%e6%a0%b7/formula2.png)

因为虽然每次更新选择的概率增大了 ` k ` 倍，但是选到具体第 ` i ` 个元素的概率还是要乘 ` 1/k ` ，也就回到了上一个推导。

### 拓展延伸

以上的抽样算法时间复杂度是 O(n)，但不是最优的方法，更优化的算法基于几何分布（geometric distribution），时间复杂度为 O(k + klog(n/k))
。由于涉及的数学知识比较多，这里就不列出了，有兴趣的读者可以自行搜索一下。

还有一种思路是基于「Fisher–Yates 洗牌算法」的。随机抽取 ` k ` 个元素，等价于对所有元素洗牌，然后选取前 ` k`个。只不过，洗牌算法需要对元素的随机访问，所以只能对数组这类支持随机存储的数据结构有效。

另外有一种思路也比较有启发意义：给每一个元素关联一个随机数，然后把每个元素插入一个容量为 ` k`的二叉堆（优先级队列）按照配对的随机数进行排序，最后剩下的 ` k ` 个元素也是随机的。

这个方案看起来似乎有点多此一举，因为插入二叉堆需要 O(logk) 的时间复杂度，所以整个抽样算法就需要 O(nlogk)
的复杂度，还不如我们最开始的算法。但是，这种思路可以指导我们解决 **加权随机抽样算法**
，权重越高，被随机选中的概率相应增大，这种情况在现实生活中是很常见的，比如你不往游戏里充钱，就永远抽不到皮肤。

最后，我想说随机算法虽然不多，但其实很有技巧的，读者不妨思考两个常见且看起来很简单的问题：

1、如何对带有权重的样本进行加权随机抽取？比如给你一个数组 ` w ` ，每个元素 ` w[i] ` 代表权重，请你写一个算法，按照权重随机抽取索引。比如
` w = [1,99] ` ，算法抽到索引 0 的概率是 1%，抽到索引 1 的概率是 99%。

2、实现一个生成器类，构造函数传入一个很长的数组，请你实现 ` randomGet`方法，每次调用随机返回数组中的一个元素，多次调用不能重复返回相同索引的元素。要求不能对该数组进行任何形式的修改，且操作的时间复杂度是 O(1)。

这两个问题都是比较困难的，以后有时间我会写一写相关的文章。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


 ## 如何去除有序数组的重复元素
 读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 26. 删除有序数组中的重复项（简单） ](https://leetcode-cn.com/problems/remove-duplicates-
from-sorted-array/)

[ 83. 删除排序链表中的重复元素（简单） ](https://leetcode-cn.com/problems/remove-duplicates-
from-sorted-list/)

[ 27. 移除元素（简单） ](https://leetcode-cn.com/problems/remove-element/)

[ 283. 移动零（简单） ](https://leetcode-cn.com/problems/move-zeroes/)

**———–**

我们知道对于数组来说，在尾部插入、删除元素是比较高效的，时间复杂度是 O(1)，但是如果在中间或者开头插入、删除元素，就会涉及数据的搬移，时间复杂度为 O(N)，效率较低。

所以上篇文章 [ 常数时间删除/查找数组中的任意元素 ](https://labuladong.gitee.io/algo/2/20/61/)
就讲了一种技巧，把待删除元素交换到最后一个，然后再删除，就可以避免数据搬移。

那么这篇文章我们换一个场景，来讲一讲如何在原地修改数组，避免数据的搬移。

### 有序数组/链表去重

先讲讲如何对一个有序数组去重，先看下题目：

![](https://labuladong.gitee.io/algo/images/%e6%95%b0%e7%bb%84%e5%8e%bb%e9%87%8d/title.png)

函数签名如下：

```java
    int removeDuplicates(int[] nums);

```

显然，由于数组已经排序，所以重复的元素一定连在一起，找出它们并不难，但如果毎找到一个重复元素就立即删除它，就是在数组中间进行删除操作，整个时间复杂度是会达到 O(N^2)。

简单解释一下什么是原地修改：

如果不是原地修改的话，我们直接 new 一个 ` int[] ` 数组，把去重之后的元素放进这个新数组中，然后返回这个新数组即可。

但是原地删除，不允许我们 new 新数组，只能在原数组上操作，然后返回一个长度，这样就可以通过返回的长度和原始数组得到我们去重后的元素有哪些了。

这种需求在数组相关的算法题中时非常常见的， **通用解法就是我们前文[ 双指针技巧 ](https://labuladong.gitee.io/algo/2/20/55/) 中的快慢指针技巧 ** 。

我们让慢指针 ` slow ` 走在后面，快指针 ` fast ` 走在前面探路，找到一个不重复的元素就告诉 ` slow ` 并让 ` slow`前进一步。这样当 ` fast ` 指针遍历完整个数组 ` nums ` 后， **` nums[0..slow] ` 就是不重复元素 ** 。

```java
    int removeDuplicates(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        int slow = 0, fast = 0;
        while (fast < nums.length) {
            if (nums[fast] != nums[slow]) {
                slow++;
               // 维护 nums[0..slow] 无重复
                nums[slow] = nums[fast];
            }
            fast++;
        }
       // 数组长度为索引 + 1
        return slow + 1;
    }

```

看下算法执行的过程：

![](https://labuladong.gitee.io/algo/images/%e6%95%b0%e7%bb%84%e5%8e%bb%e9%87%8d/1.gif)

再简单扩展一下，如果给你一个有序链表，如何去重呢？这是力扣第 83 题，其实和数组去重是一模一样的，唯一的区别是把数组赋值操作变成操作指针而已：

```java
    ListNode deleteDuplicates(ListNode head) {
        if (head == null) return null;
        ListNode slow = head, fast = head;
        while (fast != null) {
            if (fast.val != slow.val) {
               // nums[slow] = nums[fast];
                slow.next = fast;
               // slow++;
                slow = slow.next;
            }
           // fast++
            fast = fast.next;
        }
       // 断开与后面重复元素的连接
        slow.next = null;
        return head;
    }

```

![](https://labuladong.gitee.io/algo/images/%e6%95%b0%e7%bb%84%e5%8e%bb%e9%87%8d/2.gif)

### 移除元素

这是力扣第 27 题，看下题目：

![](https://labuladong.gitee.io/algo/images/%e6%95%b0%e7%bb%84%e5%8e%bb%e9%87%8d/title1.png)

函数签名如下：

```java
    int removeElement(int[] nums, int val);

```

题目要求我们把 ` nums ` 中所有值为 ` val ` 的元素原地删除，依然需要使用 [ 双指针技巧 ](https://labuladong.gitee.io/algo/2/20/55/)
中的快慢指针：

如果 ` fast ` 遇到需要去除的元素，则直接跳过，否则就告诉 ` slow ` 指针，并让 ` slow ` 前进一步。

这和前面说到的数组去重问题解法思路是完全一样的，就不画 GIF 了，直接看代码：

```java
    int removeElement(int[] nums, int val) {
        int fast = 0, slow = 0;
        while (fast < nums.length) {
            if (nums[fast] != val) {
                nums[slow] = nums[fast];
                slow++;
            }
            fast++;
        }
        return slow;
    }

```

**注意这里和有序数组去重的解法有一个重要不同** ，我们这里是先给 ` nums[slow] ` 赋值然后再给 ` slow++ ` ，这样可以保证`nums[0..slow-1] ` 是不包含值为 ` val ` 的元素的，最后的结果数组长度就是 ` slow ` 。

### 移动零

这是力扣第 283 题，我来描述下题目：

给你输入一个数组 ` nums ` ，请你 **原地修改** ，将数组中的所有值为 0 的元素移到数组末尾，函数签名如下：

```java
    void moveZeroes(int[] nums);

```

比如说给你输入 ` nums = [0,1,4,0,2] ` ，你的算法没有返回值，但是会把 ` nums ` 数组原地修改成 ` [1,4,2,0,0]
` 。

结合之前说到的几个题目，你是否有已经有了答案呢？

题目让我们将所有 0 移到最后，其实就相当于移除 ` nums ` 中的所有 0，然后再把后面的元素都赋值为 0 即可。

所以我们可以复用上一题的 ` removeElement ` 函数：

```java
    void moveZeroes(int[] nums) {
       // 去除 nums 中的所有 0
       // 返回去除 0 之后的数组长度
        int p = removeElement(nums, 0);
       // 将 p 之后的所有元素赋值为 0
        for (; p < nums.length; p++) {
            nums[p] = 0;
        }
    }
    
   // 见上文代码实现
    int removeElement(int[] nums, int val);

```

至此，四道「原地修改」的算法问题就讲完了，其实核心还是快慢指针技巧，你学会了吗？

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


 ## 一行代码就能解决的算法题
 读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 292. Nim游戏（简单） ](https://leetcode-cn.com/problems/nim-game)

[ 877. 石子游戏（中等） ](https://leetcode-cn.com/problems/stone-game)

[ 319. 灯泡开关（中等） ](https://leetcode-cn.com/problems/bulb-switcher)

**———–**

下文是我在 LeetCode 刷题过程中总结的三道有趣的「脑筋急转弯」题目，可以使用算法编程解决，但只要稍加思考，就能找到规律，直接想出答案。

### 一、Nim 游戏

游戏规则是这样的：你和你的朋友面前有一堆石子，你们轮流拿，一次至少拿一颗，最多拿三颗，谁拿走最后一颗石子谁获胜。

假设你们都很聪明，由你第一个开始拿，请你写一个算法，输入一个正整数 ` n ` ，返回你是否能赢（true 或 false）。

比如现在有 4 颗石子，算法应该返回 false。因为无论你拿 1 颗 2 颗还是 3 颗，对方都能一次性拿完，拿走最后一颗石子，所以你一定会输。

首先，这道题肯定可以使用动态规划，因为显然原问题存在子问题，且子问题存在重复。但是因为你们都很聪明，涉及到你和对手的博弈，动态规划会比较复杂。

**我们解决这种问题的思路一般都是反着思考** ：

如果我能赢，那么最后轮到我取石子的时候必须要剩下 1~3 颗石子，这样我才能一把拿完。

如何营造这样的一个局面呢？显然，如果对手拿的时候只剩 4 颗石子，那么无论他怎么拿，总会剩下 1~3 颗石子，我就能赢。

如何逼迫对手面对 4 颗石子呢？要想办法，让我选择的时候还有 5~7 颗石子，这样的话我就有把握让对方不得不面对 4 颗石子。

如何营造 5~7 颗石子的局面呢？让对手面对 8 颗石子，无论他怎么拿，都会给我剩下 5~7 颗，我就能赢。

这样一直循环下去，我们发现只要踩到 4 的倍数，就落入了圈套，永远逃不出 4 的倍数，而且一定会输。所以这道题的解法非常简单：

```java
    boolean canWinNim(int n) {
       // 如果上来就踩到 4 的倍数，那就认输吧
       // 否则，可以把对方控制在 4 的倍数，必胜
        return n % 4 != 0;
    }

```

### 二、石头游戏

游戏规则是这样的：你和你的朋友面前有一排石头堆，用一个数组 ` piles ` 表示， ` piles[i] ` 表示第 ` i`堆石子有多少个。你们轮流拿石头，一次拿一堆，但是只能拿走最左边或者最右边的石头堆。所有石头被拿完后，谁拥有的石头多，谁获胜。

**假设你们都很聪明** ，由你第一个开始拿，请你写一个算法，输入一个数组 ` piles ` ，返回你是否能赢（true 或 false）。

注意，石头的堆的数量为偶数，所以你们两人拿走的堆数一定是相同的。石头的总数为奇数，也就是你们最后不可能拥有相同多的石头，一定有胜负之分。

举个例子， ` piles=[2, 1, 9, 5] ` ，你先拿，可以拿 2 或者 5，你选择 2。

` piles=[1, 9, 5] ` ，轮到对手，可以拿 1 或 5，他选择 5。

` piles=[1, 9] ` 轮到你拿，你拿 9。

最后，你的对手只能拿 1 了。

这样下来，你总共拥有 ` 2 + 9 = 11 ` 颗石头，对手有 ` 5 + 1 = 6 ` 颗石头，你是可以赢的，所以算法应该返回 true。

你看到了，并不是简单的挑数字大的选，为什么第一次选择 2 而不是 5 呢？因为 5 后面是 9，你要是贪图一时的利益，就把 9 这堆石头暴露给对手了，那你就要输了。

这也是强调双方都很聪明的原因，算法也是求最优决策过程下你是否能赢。

这道题又涉及到两人的博弈，也可以用动态规划算法暴力试，比较麻烦。但我们只要对规则深入思考，就会大惊失色：只要你足够聪明，你是必胜无疑的，因为你是先手。

```java
    boolean stoneGame(int[] piles) {
        return true;
    }

```

这是为什么呢，因为题目有两个条件很重要：一是石头总共有偶数堆，石头的总数是奇数。这两个看似增加游戏公平性的条件，反而使该游戏成为了一个割韭菜游戏。我们以`piles=[2, 1, 9, 5] ` 讲解，假设这四堆石头从左到右的索引分别是 1，2，3，4。

如果我们把这四堆石头按索引的奇偶分为两组，即第 1、3 堆和第 2、4 堆，那么这两组石头的数量一定不同，也就是说一堆多一堆少。因为石头的总数是奇数，不能被平分。

而作为第一个拿石头的人，你可以控制自己拿到所有偶数堆，或者所有的奇数堆。

你最开始可以选择第 1 堆或第 4 堆。如果你想要偶数堆，你就拿第 4 堆，这样留给对手的选择只有第 1、3 堆，他不管怎么拿，第 2 堆又会暴露出来，你就可以拿。同理，如果你想拿奇数堆，你就拿第 1 堆，留给对手的只有第 2、4
堆，他不管怎么拿，第 3 堆又给你暴露出来了。

也就是说，你可以在第一步就观察好，奇数堆的石头总数多，还是偶数堆的石头总数多，然后步步为营，就一切尽在掌控之中了。知道了这个漏洞，可以整一整不知情的同学了。

### 三、电灯开关问题

这个问题是这样描述的：有 ` n ` 盏电灯，最开始时都是关着的。现在要进行 ` n ` 轮操作：

第 1 轮操作是把每一盏电灯的开关按一下（全部打开）。

第 2 轮操作是把每两盏灯的开关按一下（就是按第 2，4，6… 盏灯的开关，它们被关闭）。

第 3 轮操作是把每三盏灯的开关按一下（就是按第 3，6，9… 盏灯的开关，有的被关闭，比如 3，有的被打开，比如 6）…

如此往复，直到第 ` n ` 轮，即只按一下第 ` n ` 盏灯的开关。

现在给你输入一个正整数 ` n ` 代表电灯的个数，问你经过 ` n ` 轮操作后，这些电灯有多少盏是亮的？

我们当然可以用一个布尔数组表示这些灯的开关情况，然后模拟这些操作过程，最后去数一下就能出结果。但是这样显得没有灵性，最好的解法是这样的：

```java
    int bulbSwitch(int n) {
        return (int)Math.sqrt(n);
    }

```

什么？这个问题跟平方根有什么关系？其实这个解法挺精妙，如果没人告诉你解法，还真不好想明白。

首先，因为电灯一开始都是关闭的，所以某一盏灯最后如果是点亮的，必然要被按奇数次开关。

我们假设只有 6 盏灯，而且我们只看第 6 盏灯。需要进行 6 轮操作对吧，请问对于第 6 盏灯，会被按下几次开关呢？这不难得出，第 1 轮会被按，第 2 轮，第 3 轮，第 6 轮都会被按。

为什么第 1、2、3、6 轮会被按呢？因为 ` 6=1*6=2*3`。一般情况下，因子都是成对出现的，也就是说开关被按的次数一般是偶数次。但是有特殊情况，比如说总共有 16 盏灯，那么第 16 盏灯会被按几次?

` 16 = 1*16 = 2*8 = 4*4`
其中因子 4 重复出现，所以第 16 盏灯会被按 5 次，奇数次。现在你应该理解这个问题为什么和平方根有关了吧？

不过，我们不是要算最后有几盏灯亮着吗，这样直接平方根一下是啥意思呢？稍微思考一下就能理解了。

就假设现在总共有 16 盏灯，我们求 16 的平方根，等于 4，这就说明最后会有 4 盏灯亮着，它们分别是第 ` 1*1=1 ` 盏、第 ` 2*2=4`盏、第 ` 3*3=9 ` 盏和第 ` 4*4=16 ` 盏。

就算有的 ` n ` 平方根结果是小数，强转成 int 型，也相当于一个最大整数上界，比这个上界小的所有整数，平方后的索引都是最后亮着的灯的索引。所以说我们直接把平方根转成整数，就是这个问题的答案。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


 ## 几个反直觉的概率问题
 **———–**

上篇文章 [ 洗牌算法详解 ](https://mp.weixin.qq.com/s/c00DFbvvQNCaZqTDfwBWyA)
讲到了验证概率算法的蒙特卡罗方法，今天聊点轻松的内容：几个和概率相关的有趣问题。

计算概率有下面两个最简单的原则：

原则一、计算概率一定要有一个参照系，称作「样本空间」，即随机事件可能出现的所有结果。事件 A 发生的概率 = A 包含的样本点/ 样本空间的样本总数。

原则二、计算概率一定要明白，概率是一个连续的整体，不可以把连续的概率分割开，也就是所谓的条件概率。

上述两个原则高中就学过，但是我们还是很容易犯错，而且犯错的流程也有异曲同工之妙：

先是忽略了原则二，错误地计算了样本空间，然后通过原则一算出了错误的答案。

下面介绍几个简单却具有迷惑性的问题，分别是男孩女孩问题、生日悖论、三门问题。当然，三门问题可能是大家最耳熟的，所以就多说一些有趣的思考。

### 一、男孩女孩问题

假设有一个家庭，有两个孩子，现在告诉你其中有一个男孩，请问另一个也是男孩的概率是多少？

很多人，包括我在内，不假思索地回答：1/2 啊，因为另一个孩子要么是男孩，要么是女孩，而且概率相等呀。但是实际上，答案是 1/3。

上述思想为什么错误呢？因为没有正确计算样本空间，导致原则一计算错误。有两个孩子，那么样本空间为 4，即哥哥妹妹，哥哥弟弟，姐姐妹妹，姐姐弟弟这四种情况。已知有一个男孩，那么排除姐姐妹妹这种情况，所以样本空间变成
3。另一个孩子也是男孩只有哥哥弟弟这 1 种情况，所以概率为 1/3。

为什么计算样本空间会出错呢？因为我们忽略了条件概率，即混淆了下面两个问题：

这个家庭只有一个孩子，这个孩子是男孩的概率是多少？

这个家庭有两个孩子，其中一个是男孩，另一个孩子是男孩的概率是多少？

根据原则二，概率问题是连续的，不可以把上述两个问题混淆。第二个问题需要用条件概率，即求一个孩子是男孩的条件下，另一个也是男孩的概率。运用条件概率的公式也很好算，就不多说了。

通过这个问题，读者应该理解两个概率计算原则的关系了，最具有迷惑性的就是条件概率的忽视。为了不要被迷惑，最简单的办法就是把所有可能结果穷举出来。

最后，对于此问题我见过一个很奇葩的质疑：如果这两个孩子是双胞胎，不存在年龄上的差异怎么办？

我竟然觉得有那么一丝道理！但其实，我们只是通过年龄差异来表示两个孩子的独立性，也就是说即便两个孩子同性，也有两种可能。所以不要用双胞胎抬杠了。

### 二、生日悖论

生日悖论是由这样一个问题引出的：一个屋子里需要有多少人，才能使得存在至少两个人生日是同一天的概率达到 50%？

答案是 23 个人，也就是说房子里如果有 23 个人，那么就有 50% 的概率会存在两个人生日相同。这个结论看起来不可思议，所以被称为悖论。按照直觉，要得到 50% 的概率，起码得有 183 个人吧，因为一年有 365
天呀？其实不是的，觉得这个结论不可思议主要有两个思维误区：

**第一个误区是误解「存在」这个词的含义** 。

读者可能认为，如果 23 个人中出现相同生日的概率就能达到 50%，是不是意味着：

假设现在屋子里坐着 22 个人，然后我走进去，那么有 50% 的概率我可以找到一个人和我生日相同。但这怎么可能呢？

并不是的，你这种想法是以自我为中心，而题目的概率是在描述整体。也就是说「存在」的含义是指 23 人中的任意两个人，涉及排列组合，大概率和你没啥关系。

如果你非要计算存在和自己生日相同的人的概率是多少，可以这样计算：

1 - P(22 个人都和我的生日不同) = 1 -(364/365)^22 = 0.06

这样计算得到的结果是不是看起来合理多了？生日悖论计算对象的不是某一个人，而是一个整体，其中包含了所有人的排列组合，它们的概率之和当然会大得多。

**第二个误区是认为概率是线性变化的** 。

读者可能认为，如果 23 个人中出现相同生日的概率就能达到 50%，是不是意味着 46 个人的概率就能达到 100%？

不是的，就像中奖率 50% 的游戏，你玩两次的中奖率就是 100% 吗？显然不是，你玩两次的中奖率是 75%：

` P(两次能中奖) = P(第一次就中了) + P(第一次没中但第二次中了) = 1/2 + 1/2*1/2 = 75%`
那么换到生日悖论也是一个道理，概率不是简单叠加，而要考虑一个连续的过程，所以这个结论并没有什么不合常理之处。

那为什么只要 23 个人出现相同生日的概率就能大于 50% 了呢？我们先计算 23 个人生日都唯一（不重复）的概率。只有 1 个人的时候，生日唯一的概率是
` 365/365 ` ，2 个人时，生日唯一的概率是 ` 365/365 × 364/365 ` ，以此类推可知 23 人的生日都唯一的概率：

![](https://labuladong.gitee.io/algo/images/%e6%a6%82%e7%8e%87%e9%97%ae%e9%a2%98/p.png)

算出来大约是 0.493，所以存在相同生日的概率就是 0.507，差不多就是 50% 了。实际上，按照这个算法，当人数达到 70 时，存在两个人生日相同的概率就上升到了 99.9%，基本可以认为是 100%
了。所以从概率上说，一个几十人的小团体中存在生日相同的人真没啥稀奇的。

### 三、三门问题

这个游戏很经典了：游戏参与者面对三扇门，其中两扇门后面是山羊，一扇门后面是跑车。参与者只要随便选一扇门，门后面的东西就归他（跑车的价值当然更大）。但是主持人决定帮一下参与者：在他选择之后，先不急着打开这扇门，而是由主持人打开剩下两扇门中的一扇，展示其中的山羊（主持人知道每扇门后面是什么），然后给参与者一次换门的机会，此时参与者应该换门还是不换门呢？

为了防止第一次看到这个问题的读者迷惑，再具体描述一下这个问题：

你是游戏参与者，现在有门 1,2,3，假设你随机选择了门 1，然后主持人打开了门 3 告诉你那后面是山羊。现在，你是坚持你最初的选择门 1，还是选择换成门 2 呢？

![](https://labuladong.gitee.io/algo/images/%e6%a6%82%e7%8e%87%e9%97%ae%e9%a2%98/sanmen.png)

答案是应该换门，换门之后抽到跑车的概率是 2/3，不换的话是 1/3。又一次反直觉，感觉换不换的中奖概率应该都一样啊，因为最后肯定就剩两个门，一个是羊，一个是跑车，这是事实，所以不管选哪个的概率不都是 1/2 吗？

类似前面说的男孩女孩问题，最简单稳妥的方法就是把所有可能结果穷举出来：

![](https://labuladong.gitee.io/algo/images/%e6%a6%82%e7%8e%87%e9%97%ae%e9%a2%98/tree.png)

很容易看到选择换门中奖的概率是 2/3，不换的话是 1/3。

关于这个问题还有更简单的方法：主持人开门实际上在「浓缩」概率。一开始你选择到跑车的概率当然是 1/3，剩下两个门中包含跑车的概率当然是 2/3，这没啥可说的。但是主持人帮你排除了一个含有山羊的门，相当于把那 2/3
的概率浓缩到了剩下的这一扇门上。那么，你说你是抱着原来那扇 1/3 的门，还是换成那扇经过「浓缩」的 2/3 概率的门呢？

再直观一点，假设你三选一，剩下 2 扇门，再给你加入 98 扇装山羊的门，把这 100 扇门随机打乱，问你换不换？肯定不换对吧，这明摆着把概率稀释了，肯定抱着原来的那扇门是最可能中跑车的。再假设，初始有 100
扇门，你选了一扇，然后主持人在剩下 99 扇门中帮你排除 98 个山羊，问你换不换一扇门？肯定换对吧，你手上那扇门是 1%，另一扇门是 99%，或者也可以这样理解，不换只是选择了 1 扇门，换门相当于选择了 99 扇门，这样结果很明显了吧？

以上思想，也许有的读者都思考过，下面我们思考这样一个问题：假设你在决定是否换门的时候，小明破门而入，要求帮你做出选择。他完全不知道之前发生的事，他只知道面前有两扇门，一扇是跑车一扇是山羊，那么他抽中跑车的概率是多大？

当然是 1/2，这也是很多人做错三门问题的根本原因。类似生日悖论，人们总是容易以自我为中心，通过这个小明的视角来计算是否换门，这显然会进入误区。

就好比有两个箱子，一号箱子有 4 个黑球 2 个红球，二号箱子有 2 个黑球 4 个红球，随便选一个箱子，随便摸一个球，问你摸出红球的概率。

对于不知情的小明，他会随机选择一个箱子，随机摸球，摸到红球的概率是：1/2 × 2/6 + 1/2 × 4/6 = 1/2

对于知情的你，你知道在二号箱子摸球概率大，所以只在二号箱摸，摸到红球的概率是：0 × 2/6 + 1 × 4/6 = 2/3

三门问题是有指导意义的。比如你蒙选择题，先蒙了 A，后来灵机一动排除了 B 和 C，请问你是否要把 A 换成 D？答案是，换！

也许读者会问，如果只排除了一个答案，比如说 B，那么我是否应该把 A 换成 C 或者 D 呢？答案是，换！

因为按照刚才「浓缩」概率这个思想，只要进行了排除，都是在进行「浓缩」，均摊下来肯定比你一开始蒙的那个答案概率 1/4 高。比如刚才的例子，C 和 D 的正确概率都是 3/8，而你开始蒙的 A 只有 1/4。

当然，运用此策略蒙题的前提是你真的抓瞎，真的随机乱选答案，这样概率才能作为最后的杀手锏。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


 # 其他算法技巧

1、《算法秘籍》和《刷题笔记》两本 PDF 下载 [ 点这里

](https://mp.weixin.qq.com/s/X-fE9sR4BLi6T9pn7xP4pg) 。

2、刷题插件下载及使用手册 [ 点这里 ](https://mp.weixin.qq.com/s/wIxflO1dvXzDlibhEcENcQ) 。

3、公众号菜单栏参与 [ 21 天算法挑战活动 ](https://mp.weixin.qq.com/s/eUG2OOzY3k_ZTz-CFvtv5Q) 。

 ## 快速排序亲兄弟：快速选择算法
 读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 215. 数组中的第 K 个最大元素（中等） ](https://leetcode-cn.com/problems/kth-largest-
element-in-an-array)

**———–**

快速选择算法是一个非常经典的算法，和快速排序算法是亲兄弟。

原始题目很简单，给你输入一个无序的数组 ` nums ` 和一个正整数 ` k ` ，让你计算 ` nums ` 中第 ` k ` 大的元素。

那你肯定说，给 ` nums ` 数组排个序，然后取第 ` k ` 个元素，也就是 ` nums[k-1] ` ，不就行了吗？

当然可以，但是排序时间复杂度是 ` O(NlogN) ` ，其中 ` N ` 表示数组 ` nums ` 的长度。

我们就想要第 ` k ` 大的元素，却给整个数组排序，有点杀鸡用牛刀的感觉，所以这里就有一些小技巧了，可以把时间复杂度降低到 ` O(NlogK)`甚至是 ` O(N) ` ，下面我们就来具体讲讲。

力扣第 215 题「数组中的第 K 个最大元素」就是一道类似的题目，函数签名如下：

```java
    int findKthLargest(int[] nums, int k);

```

只不过题目要求找 **第` k ` 个最大的元素 ** ，和我们刚才说的 **第` k ` 大的元素 ** 在语义上不太一样，题目的意思相当于是把`nums ` 数组降序排列，然后返回第 ` k ` 个元素。

比如输入 ` nums = [2,1,5,4], k = 2 ` ，算法应该返回 4，因为 4 是 ` nums ` 中第 2 个 **最大** 的元素。

这种问题有两种解法，一种是二叉堆（优先队列）的解法，另一种就是标题说到的快速选择算法（Quick Select），我们分别来看。

### 解法一

**二叉堆的解法比较简单，实际写算法题的时候，推荐大家写这种解法** ，先直接看代码吧：

```java
    int findKthLargest(int[] nums, int k) {
       // 小顶堆，堆顶是最小元素
        PriorityQueue<Integer> 
            pq = new PriorityQueue<>();
        for (int e : nums) {
           // 每个元素都要过一遍二叉堆
            pq.offer(e);
           // 堆中元素多于 k 个时，删除堆顶元素
            if (pq.size() > k) {
                pq.poll();
            }
        }
       // pq 中剩下的是 nums 中 k 个最大元素，
       // 堆顶是最小的那个，即第 k 个最大元素
        return pq.peek();
    }

```

二叉堆（优先队列）是比较常见的数据结构，可以认为它会自动排序，我们前文 [ 手把手实现二叉堆数据结构 ](https://labuladong.gitee.io/algo/2/19/50/)
实现过这种结构，我就默认大家熟悉它的特性了。

看代码应该不难理解，可以把小顶堆 ` pq ` 理解成一个筛子，较大的元素会沉淀下去，较小的元素会浮上来；当堆大小超过 ` k`的时候，我们就删掉堆顶的元素，因为这些元素比较小，而我们想要的是前 ` k ` 个最大元素嘛。

当 ` nums ` 中的所有元素都过了一遍之后，筛子里面留下的就是最大的 ` k ` 个元素，而堆顶元素是堆中最小的元素，也就是「第 ` k`个最大的元素」。

二叉堆插入和删除的时间复杂度和堆中的元素个数有关，在这里我们堆的大小不会超过 ` k ` ，所以插入和删除元素的复杂度是 ` O(logK) ` ，再套一层 for 循环，总的时间复杂度就是 ` O(NlogK)`。空间复杂度很显然就是二叉堆的大小，为 ` O(K) ` 。

这个解法算是比较简单的吧，代码少也不容易出错，所以说如果笔试面试中出现类似的问题，建议用这种解法。唯一注意的是，Java 的 ` PriorityQueue
` 默认实现是小顶堆，有的语言的优先队列可能默认是大顶堆，可能需要做一些调整。

### 解法二

**快速选择算法比较巧妙，时间复杂度更低，是快速排序的简化版，一定要熟悉思路** 。

我们先从快速排序讲起。

快速排序的逻辑是，若要对 ` nums[lo..hi] ` 进行排序，我们先找一个分界点 ` p ` ，通过交换元素使得 ` nums[lo..p-1]`都小于等于 ` nums[p] ` ，且 ` nums[p+1..hi] ` 都大于 ` nums[p] ` ，然后递归地去 ` nums[lo..p-1]
` 和 ` nums[p+1..hi] ` 中寻找新的分界点，最后整个数组就被排序了。

快速排序的代码如下：

```java
   /* 快速排序主函数 */
    void sort(int[] nums) {
       // 一般要在这用洗牌算法将 nums 数组打乱，
       // 以保证较高的效率，我们暂时省略这个细节
        sort(nums, 0, nums.length - 1);
    }
    
   /* 快速排序核心逻辑 */
    void sort(int[] nums, int lo, int hi) {
        if (lo >= hi) return;
       // 通过交换元素构建分界点索引 p
        int p = partition(nums, lo, hi);
       // 现在 nums[lo..p-1] 都小于 nums[p]，
       // 且 nums[p+1..hi] 都大于 nums[p]
        sort(nums, lo, p - 1);
        sort(nums, p + 1, hi);
    }

```

关键就在于这个分界点索引 ` p ` 的确定，我们画个图看下 ` partition ` 函数有什么功效：

![](https://labuladong.gitee.io/algo/images/%e5%bf%ab%e9%80%9f%e9%80%89%e6%8b%a9/1.jpeg)

**索引` p ` 左侧的元素都比 ` nums[p] ` 小，右侧的元素都比 ` nums[p] ` 大，意味着这个元素已经放到了正确的位置上 **
，回顾快速排序的逻辑，递归调用会把 ` nums[p] ` 之外的元素也都放到正确的位置上，从而实现整个数组排序，这就是快速排序的核心逻辑。

那么这个 ` partition ` 函数如何实现的呢？看下代码：

```java
    int partition(int[] nums, int lo, int hi) {
        if (lo == hi) return lo;
       // 将 nums[lo] 作为默认分界点 pivot
        int pivot = nums[lo];
       // j = hi + 1 因为 while 中会先执行 --
        int i = lo, j = hi + 1;
        while (true) {
           // 保证 nums[lo..i] 都小于 pivot
            while (nums[++i] < pivot) {
                if (i == hi) break;
            }
           // 保证 nums[j..hi] 都大于 pivot
            while (nums[--j] > pivot) {
                if (j == lo) break;
            }
            if (i >= j) break;
           // 如果走到这里，一定有：
           // nums[i] > pivot && nums[j] < pivot
           // 所以需要交换 nums[i] 和 nums[j]，
           // 保证 nums[lo..i] < pivot < nums[j..hi]
            swap(nums, i, j);
        }
       // 将 pivot 值交换到正确的位置
        swap(nums, j, lo);
       // 现在 nums[lo..j-1] < nums[j] < nums[j+1..hi]
        return j;
    }
    
   // 交换数组中的两个元素
    void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }

```

熟悉快速排序逻辑的读者应该可以理解这段代码的含义了，这个 ` partition`函数细节较多，上述代码参考《算法4》，是众多写法中最漂亮简洁的一种，所以建议背住，这里就不展开解释了。

好了，对于快速排序的探讨到此结束，我们回到一开始的问题，寻找第 ` k ` 大的元素，和快速排序有什么关系？

注意这段代码：

```java
    int p = partition(nums, lo, hi);

```

我们刚说了， ` partition ` 函数会将 ` nums[p] ` 排到正确的位置，使得 ` nums[lo..p-1] < nums[p] <
nums[p+1..hi] ` 。

**那么我们可以把` p ` 和 ` k ` 进行比较，如果 ` p < k ` 说明第 ` k ` 大的元素在 ` nums[p+1..hi]`中，如果 ` p > k ` 说明第 ` k ` 大的元素在 ` nums[lo..p-1] ` 中 ** 。

所以我们可以复用 ` partition ` 函数来实现这道题目，不过在这之前还是要做一下索引转化：

题目要求的是「第 ` k ` 个最大元素」，这个元素其实就是 ` nums ` 升序排序后「索引」为 ` len(nums) - k ` 的这个元素。

这样就可以写出解法代码：

```java
    int findKthLargest(int[] nums, int k) {
        int lo = 0, hi = nums.length - 1;
       // 索引转化
        k = nums.length - k;
        while (lo <= hi) {
           // 在 nums[lo..hi] 中选一个分界点
            int p = partition(nums, lo, hi);
            if (p < k) {
               // 第 k 大的元素在 nums[p+1..hi] 中
                lo = p + 1;
            } else if (p > k) {
               // 第 k 大的元素在 nums[lo..p-1] 中
                hi = p - 1;
            } else {
               // 找到第 k 大元素
                return nums[p];
            }
        }
        return -1;
    }

```

这个代码框架其实非常像我们前文 [ 二分搜索框架 ](https://labuladong.gitee.io/algo/2/20/57/) 的代码，这也是这个算法高效的原因，但是时间复杂度为什么是`O(N) ` 呢？按理说类似二分搜索的逻辑，时间复杂度应该一定会出现对数才对呀？

其实这个 ` O(N) ` 的时间复杂度是个均摊复杂度，因为我们的 ` partition ` 函数中需要利用 [ 双指针技巧

](https://labuladong.gitee.io/algo/2/20/55/) 遍历 ` nums[lo..hi] ` ，那么总共遍历了多少元素呢？

最好情况下，每次 ` p ` 都恰好是正中间 ` (lo + hi)/ 2 ` ，那么遍历的元素总数就是：

N + N/2 + N/4 + N/8 + … + 1

这就是等比数列求和公式嘛，求个极限就等于 ` 2N ` ，所以遍历元素个数为 ` 2N ` ，时间复杂度为 ` O(N) ` 。

但我们其实不能保证每次 ` p ` 都是正中间的索引的，最坏情况下 ` p ` 一直都是 ` lo + 1 ` 或者一直都是 ` hi - 1`，遍历的元素总数就是：

N + (N - 1) + (N - 2) + … + 1

这就是个等差数列求和，时间复杂度会退化到 ` O(N^2) ` ， **为了尽可能防止极端情况发生，我们需要在算法开始的时候对` nums`数组来一次随机打乱 ** ：

```java
    int findKthLargest(int[] nums, int k) {
       // 首先随机打乱数组
        shuffle(nums);
       // 其他都不变
        int lo = 0, hi = nums.length - 1;
        k = nums.length - k;
        while (lo <= hi) {
           // ...
        }
        return -1;
    }
    
   // 对数组元素进行随机打乱
    void shuffle(int[] nums) {
        int n = nums.length;
        Random rand = new Random();
        for (int i = 0 ; i < n; i++) {
           // 从 i 到最后随机选一个元素
            int r = i + rand.nextInt(n - i);
            swap(nums, i, r);
        }
    }

```

前文 [ 洗牌算法详解 ](https://mp.weixin.qq.com/s/c00DFbvvQNCaZqTDfwBWyA)
写过随机乱置算法，这里就不展开了。当你加上这段代码之后，平均时间复杂度就是 ` O(N) ` 了，提交代码后运行速度大幅提升。

总结一下，快速选择算法就是快速排序的简化版，复用了 ` partition ` 函数，快速定位第 ` k`大的元素。相当于对数组部分排序而不需要完全排序，从而提高算法效率，将平均时间复杂度降到 ` O(N) ` 。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


 ## 分治算法详解：运算优先级
 读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 241. 为运算表达式设计优先级（中等） ](https://leetcode-cn.com/problems/different-ways-to-
add-parentheses)

**———–**

我们号已经写了 [ 动态规划算法 ](https://labuladong.gitee.io/algo/3/22/66/) ， [ 回溯（DFS）算法 ](https://labuladong.gitee.io/algo/4/28/105/) ， [
BFS 算法 ](https://labuladong.gitee.io/algo/4/28/110/) ， [ 贪心算法 ](https://labuladong.gitee.io/algo/3/26/99/) ， [ 双指针算法

](https://labuladong.gitee.io/algo/2/20/55/) ， [ 滑动窗口算法 ](https://labuladong.gitee.io/algo/2/20/56/) ，现在就差个分治算法没写了，今天来写一下。

其实，我觉得回溯、分治和动态规划算法可以划为一类，因为它们都会涉及递归。

回溯算法就一种简单粗暴的算法技巧，说白了就是一个暴力穷举算法，比如让你 [ 用回溯算法求子集、全排列、组合 ](https://labuladong.gitee.io/algo/4/28/107/)
，你就穷举呗，就考你会不会漏掉或者多算某些情况。

动态规划是一类算法问题，肯定是让你求最值的。因为动态规划问题拥有 [ 最优子结构 ](https://labuladong.gitee.io/algo/3/22/68/)
，可以通过状态转移方程从小规模的子问题最优解推导出大规模问题的最优解。

分治算法呢，可以认为是一种算法思想，通过将原问题分解成小规模的子问题，然后根据子问题的结果构造出原问题的答案。这里有点类似动态规划，所以说运用分治算法也需要满足一些条件，你的原问题结果应该可以通过合并子问题结果来计算。

其实这几个算法之间界定并没有那么清晰，有时候回溯算法加个备忘录似乎就成动态规划了，而分治算法有时候也可以加备忘录进行剪枝。

我觉得吧，没必要过分纠结每个算法的定义，定义这东西无非文学词汇而已，反正能把题做出来你说这是啥算法都行，
**所以大家还是得多刷题，刷出感觉，各种算法都手到擒来** 。

最典型的分治算法就是归并排序了，核心逻辑如下：

```java
    void sort(int[] nums, int lo, int hi) {
        int mid = (lo + hi)/ 2;
       /****** 分 ******/
       // 对数组的两部分分别排序
        sort(nums, lo, mid);
        sort(nums, mid + 1, hi);
       /****** 治 ******/
       // 合并两个排好序的子数组
        merge(nums, lo, mid, hi);
    }

```

「对数组排序」是一个可以运用分治思想的算法问题，只要我先把数组的左半部分排序，再把右半部分排序，最后把两部分合并，不就是对整个数组排序了吗？

下面来看一道具体的算法题。

### 添加括号的所有方式

我来借力扣第 241 题讲讲什么是分治算法，先看看题目：

![](https://labuladong.gitee.io/algo/images/%e5%88%86%e6%b2%bb/title.png)

简单说，就是给你输入一个算式，你可以给它随意加括号， **请你穷举出所有可能的加括号方式，并计算出对应的结果** 。

函数签名如下：

```java
   // 计算所有加括号的结果
    List<Integer> diffWaysToCompute(String input);

```

看到这道题的第一感觉肯定是复杂，我要穷举出所有可能的加括号方式，是不是还要考虑括号的合法性？是不是还要考虑计算的优先级？

是的，这些都要考虑，但是不需要我们来考虑。利用分治思想和递归函数，算法会帮我们考虑一切细节，也许这就是算法的魅力吧，哈哈哈。

废话不多说，解决本题的关键有两点：

**1、不要思考整体，而是把目光聚焦局部，只看一个运算符** 。

这一点我们前文经常提及，比如 [ 手把手刷二叉树第一期 ](https://labuladong.gitee.io/algo/2/17/21/)
就告诉你解决二叉树系列问题只要思考每个节点需要做什么，而不要思考整棵树需要做什么。

说白了，解决递归相关的算法问题，就是一个化整为零的过程，你必须瞄准一个小的突破口，然后把问题拆解，大而化小，利用递归函数来解决。

**2、明确递归函数的定义是什么，相信并且利用好函数的定义** 。

这也是前文经常提到的一个点，因为递归函数要自己调用自己，你必须搞清楚函数到底能干嘛，才能正确进行递归调用。

**下面来具体解释下这两个关键点怎么理解** 。

我们先举个例子，比如我给你输入这样一个算式：

` 1 + 2 * 3 - 4 * 5`
请问，这个算式有几种加括号的方式？请在一秒之内回答我。

估计你回答不出来，因为括号可以嵌套，要穷举出来肯定得费点功夫。

不过呢，嵌套这个事情吧，我们人类来看是很头疼的，但对于算法来说嵌套括号不要太简单，一次递归就可以嵌套一层，一次搞不定大不了多递归几次。

所以，作为写算法的人类，我们只需要思考，如果不让括号嵌套（即只加一层括号），有几种加括号的方式？

还是上面的例子，显然我们有四种加括号方式：

` (1) + (2 * 3 - 4 * 5)`
` (1 + 2) * (3 - 4 * 5)`
` (1 + 2 * 3) - (4 * 5)`
` (1 + 2 * 3 - 4) * (5)`
发现规律了么？ **其实就是按照运算符进行分割，给每个运算符的左右两部分加括号** ，这就是之前说的第一个关键点，不要考虑整体，而是聚焦每个运算符。

现在单独说上面的第三种情况：

` (1 + 2 * 3) - (4 * 5)`
我们用减号 ` \- ` 作为分隔，把原算式分解成两个算式 ` 1 + 2 * 3 ` 和 ` 4 * 5 ` 。

分治分治，分而治之， **这一步就是把原问题进行了「分」，我们现在要开始「治」了** 。

` 1 + 2 * 3 ` 可以有两种加括号的方式，分别是：

` (1) + (2 * 3) = 7`
` (1 + 2) * (3) = 9`
或者我们可以写成这种形式：

` 1 + 2 * 3 = [9, 7]`
而 ` 4 * 5 ` 当然只有一种加括号方式，就是 ` 4 * 5 = [20] ` 。

然后呢，你能不能通过上述结果推导出 ` (1 + 2 * 3) - (4 * 5) ` 有几种加括号方式，或者说有几种不同的结果？

显然，可以推导出来 ` (1 + 2 * 3) - (4 * 5) ` 有两种结果，分别是：

` 9 - 20 = -11`
` 7 - 20 = -13`
那你可能要问了， ` 1 + 2 * 3 = [9, 7] ` 的结果是我们自己看出来的，如何让算法计算出来这个结果呢？

这个简单啊，再回头看下题目给出的函数签名：

```java
   // 定义：计算算式 input 所有可能的运算结果
    List<Integer> diffWaysToCompute(String input);

```

这个函数不就是干这个事儿的吗？ **这就是我们之前说的第二个关键点，明确函数的定义，相信并且利用这个函数定义** 。

你甭管这个函数怎么做到的，你相信它能做到，然后用就行了，最后它就真的能做到了。

那么，对于 ` (1 + 2 * 3) - (4 * 5) ` 这个例子，我们的计算逻辑其实就是这段代码：

```java
    List<Integer> diffWaysToCompute("(1 + 2 * 3) - (4 * 5)") {
        List<Integer> res = new LinkedList<>();
       /****** 分 ******/
        List<Integer> left = diffWaysToCompute("1 + 2 * 3");
        List<Integer> right = diffWaysToCompute("4 * 5");
       /****** 治 ******/
        for (int a : left)
            for (int b : right)
                res.add(a - b);
    
        return res;
    }

```

好，现在 ` (1 + 2 * 3) - (4 * 5) ` 这个例子是如何计算的，你应该完全理解了吧，那么回来看我们的原始问题。

原问题 ` 1 + 2 * 3 - 4 * 5 ` 是不是只有 ` (1 + 2 * 3) - (4 * 5) ` 这一种情况？是不是只能从减号 ` \-
` 进行分割？

不是，每个运算符都可以把原问题分割成两个子问题，刚才已经列出了所有可能的分割方式：

` (1) + (2 * 3 - 4 * 5)`
` (1 + 2) * (3 - 4 * 5)`
` (1 + 2 * 3) - (4 * 5)`
` (1 + 2 * 3 - 4) * (5)`
所以，我们需要穷举上述的每一种情况，可以进一步细化一下解法代码：

```java
    List<Integer> diffWaysToCompute(String input) {
        List<Integer> res = new LinkedList<>();
        for (int i = 0; i < input.length(); i++) {
            char c = input.charAt(i);
           // 扫描算式 input 中的运算符
            if (c == '-' || c == '*' || c == '+') {
               /****** 分 ******/
               // 以运算符为中心，分割成两个字符串，分别递归计算
                List<Integer> 
                    left = diffWaysToCompute(input.substring(0, i));
                List<Integer> 
                    right = diffWaysToCompute(input.substring(i + 1));
               /****** 治 ******/
               // 通过子问题的结果，合成原问题的结果
                for (int a : left)
                    for (int b : right)
                        if (c == '+')
                            res.add(a + b);
                        else if (c == '-')
                            res.add(a - b);
                        else if (c == '*')
                            res.add(a * b);
            }
        }
       // base case
       // 如果 res 为空，说明算式是一个数字，没有运算符
        if (res.isEmpty()) {
            res.add(Integer.parseInt(input));
        }
        return res;
    }

```

有了刚才的铺垫，这段代码应该很好理解了吧，就是扫描输入的算式 ` input ` ，每当遇到运算符就进行分割，递归计算出结果后，根据运算符来合并结果。

**这就是典型的分治思路，先「分」后「治」，先按照运算符将原问题拆解成多个子问题，然后通过子问题的结果来合成原问题的结果** 。

当然，一个重点在这段代码：

```java
   // base case
   // 如果 res 为空，说明算式是一个数字，没有运算符
    if (res.isEmpty()) {
        res.add(Integer.parseInt(input));
    }

```

递归函数必须有个 base case 用来结束递归，其实这段代码就是我们分治算法的 base case，代表着你「分」到什么时候可以开始「治」。

我们是按照运算符进行「分」的，一直这么分下去，什么时候是个头？显然，当算式中不存在运算符的时候就可以结束了。

那为什么以 ` res.isEmpty() ` 作为判断条件？因为当算式中不存在运算符的时候，就不会触发 if 语句，也就不会给 ` res`中添加任何元素。

至此，这道题的解法代码就写出来了，但是时间复杂度是多少呢？

如果单看代码，真的很难通过 for 循环的次数看出复杂度是多少，所以我们需要改变思路，本题在求所有可能的计算结果，不就 **相当于在求算式` input`的所有合法括号组合 ** 吗？

那么，对于一个算式，有多少种合法的括号组合呢？这就是著名的「卡特兰数」了，最终结果是一个组合数，推导过程稍有些复杂，我这里就不写了，有兴趣的读者可以自行搜索了解一下。

**其实本题还有一个小的优化，可以进行递归剪枝** ，减少一些重复计算，比如说输入的算式如下：

` 1 + 1 + 1 + 1 + 1`
那么按照算法逻辑，按照运算符进行分割，一定存在下面两种分割情况：

` (1 + 1) + (1 + 1 + 1)`
` (1 + 1 + 1) + (1 + 1)`
算法会依次递归每一种情况，其实就是冗余计算嘛，所以我们可以对解法代码稍作修改，加一个备忘录来避免这种重复计算：

```java
   // 备忘录
    HashMap<String, List<Integer>> memo = new HashMap<>();
    
    List<Integer> diffWaysToCompute(String input) {
       // 避免重复计算
        if (memo.containsKey(input)) {
            return memo.get(input);
        }
       /****** 其他都不变 ******/
        List<Integer> res = new LinkedList<>();
        for (int i = 0; i < input.length(); i++) {
           // ...
        }
        if (res.isEmpty()) {
            res.add(Integer.parseInt(input));
        }
       /***********************/
    
       // 将结果添加进备忘录
        memo.put(input, res);
        return res;
    }

```

当然，这个优化没有改变原始的复杂度，只是对一些特殊情况做了剪枝，提升了效率。

### 最后总结

解决上述算法题利用了分治思想，以每个运算符作为分割点，把复杂问题分解成小的子问题，递归求解子问题，然后再通过子问题的结果计算出原问题的结果。

把大规模的问题分解成小规模的问题递归求解，应该是计算机思维的精髓了吧，建议大家多练，如果本文对你有帮助，记得分享给你的朋友哦~

接下来可阅读：

* [ 回溯算法和动态规划到底谁是谁爹 ](https://labuladong.gitee.io/algo/3/22/71/)

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


 ## 一个方法解决三道区间问题
 读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 1288. 删除被覆盖区间（中等） ](https://leetcode-cn.com/problems/remove-covered-
intervals)

[ 56. 区间合并（中等） ](https://leetcode-cn.com/problems/merge-intervals)

[ 986. 区间列表的交集（中等） ](https://leetcode-cn.com/problems/interval-list-
intersections)

**———–**

经常有读者问区间相关的问题，今天写一篇文章，秒杀三道区间相关的问题。

所谓区间问题，就是线段问题，让你合并所有线段、找出线段的交集等等。主要有两个技巧：

**1、排序**
。常见的排序方法就是按照区间起点排序，或者先按照起点升序排序，若起点相同，则按照终点降序排序。当然，如果你非要按照终点排序，无非对称操作，本质都是一样的。

**2、画图** 。就是说不要偷懒，勤动手，两个区间的相对位置到底有几种可能，不同的相对位置我们的代码应该怎么去处理。

废话不多说，下面我们来做题。

### 区间覆盖问题

这是力扣第 1288 题，看下题目：

![](https://labuladong.gitee.io/algo/images/%e5%8c%ba%e9%97%b4%e5%90%88%e9%9b%86/title.png)

题目问我们，去除被覆盖区间之后，还剩下多少区间， **那么我们可以先算一算，被覆盖区间有多少个，然后和总数相减就是剩余区间数** 。

对于这种区间问题，如果没啥头绪，首先排个序看看，比如我们按照区间的起点进行升序排序：

![](https://labuladong.gitee.io/algo/images/mergeInterval/1.jpg)

排序之后，两个相邻区间可能有如下三种相对位置：

![](https://labuladong.gitee.io/algo/images/%e5%8c%ba%e9%97%b4%e5%90%88%e9%9b%86/1.jpeg)

对于这三种情况，我们应该这样处理：

对于情况一，找到了覆盖区间。

对于情况二，两个区间可以合并，成一个大区间。

对于情况三，两个区间完全不相交。

依据几种情况，我们可以写出如下代码：

```java
    int removeCoveredIntervals(int[][] intvs) {
       // 按照起点升序排列，起点相同时降序排列
        Arrays.sort(intvs, (a, b) -> {
            if (a[0] == b[0]) {
                return b[1] - a[1];
            }
            return a[0] - b[0]; 
        });
    
       // 记录合并区间的起点和终点
        int left = intvs[0][0];
        int right = intvs[0][1];
        
        int res = 0;
        for (int i = 1; i < intvs.length; i++) {
            int[] intv = intvs[i];
           // 情况一，找到覆盖区间
            if (left <= intv[0] && right >= intv[1]) {
                res++;
            }
           // 情况二，找到相交区间，合并
            if (right >= intv[0] && right <= intv[1]) {
                right = intv[1];
            }
           // 情况三，完全不相交，更新起点和终点
            if (right < intv[0]) {
                left = intv[0];
                right = intv[1];
            }
        }
        
        return intvs.length - res;
    }

```

以上就是本题的解法代码，起点升序排列，终点降序排列的目的是防止如下情况：

![](https://labuladong.gitee.io/algo/images/%e5%8c%ba%e9%97%b4%e5%90%88%e9%9b%86/2.jpeg)

对于这两个起点相同的区间，我们需要保证长的那个区间在上面（按照终点降序），这样才会被判定为覆盖，否则会被错误地判定为相交，少算一个覆盖区间。

### 区间合并问题

**＿＿＿＿＿＿＿＿＿＿＿＿＿**

应合作方要求，本文不便在此发布，请扫码关注回复关键词「区间」查看：

![](https://labuladong.gitee.io/algo/images/qrcode.jpg)

 # 经典面试题

1、《算法秘籍》和《刷题笔记》两本 PDF 下载 [ 点这里

](https://mp.weixin.qq.com/s/X-fE9sR4BLi6T9pn7xP4pg) 。

2、刷题插件下载及使用手册 [ 点这里 ](https://mp.weixin.qq.com/s/wIxflO1dvXzDlibhEcENcQ) 。

3、公众号菜单栏参与 [ 21 天算法挑战活动 ](https://mp.weixin.qq.com/s/eUG2OOzY3k_ZTz-CFvtv5Q) 。

 ## 谁能想到，斗地主也能玩出算法
 读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 659. 分割数组为连续子序列（中等） ](https://leetcode-cn.com/problems/split-array-into-
consecutive-subsequences/)

**———–**

斗地主中，大小连续的牌可以作为顺子，有时候我们把对子拆掉，结合单牌，可以组合出更多的顺子，可能更容易赢。

那么如何合理拆分手上的牌，合理地拆出顺子呢？我们今天看一道非常有意思的算法题，连续子序列的划分问题。

这是力扣第 659 题「分割数组为连续子序列」，题目很简单：

给你输入一个 **升序排列** 的数组 ` nums ` （可能包含重复数字），请你判断 ` nums ` 是否能够被分割成若干个 **长度至少为 3**
的子序列，每个子序列都由连续的整数组成。

函数签名如下：

```java
    bool isPossible(vector<int>& nums);

```

比如题目举的例子，输入 ` nums = [1,2,3,3,4,4,5,5] ` ，算法返回 true。

因为 ` nums ` 可以被分割成 ` [1,2,3,4,5] ` 和 ` [3,4,5] ` 两个包含连续整数子序列。

但如果输入 ` nums = [1,2,3,4,4,5] ` ，算法返回 false，因为无法分割成两个长度至少为 3 的连续子序列。

**对于这种涉及连续整数的问题，应该条件反射地想到排序** ，不过题目说了，输入的 ` nums ` 本就是排好序的。

那么，我们如何判断 ` nums ` 是否能够被划分成若干符合条件的子序列呢？

类似前文 [ 回溯算法进行集合划分 ](https://labuladong.gitee.io/algo/4/28/106/) ，我们想把 ` nums`的元素划分到若干个子序列中，其实就是下面这个代码逻辑：

```java
    for (int v : nums) {
        if (...) {
           // 将 v 分配到某个子序列中
        } else {
           // 实在无法分配 v
            return false;
        }
        return true;
    }

```

关键在于，我们怎么知道当前元素 ` v ` 如何进行分配呢？

肯定得分情况讨论，把情况讨论清楚了，题目也就做出来了。

总共有两种情况：

**1、当前元素` v ` 自成一派，「以自己开头」构成一个长度至少为 3 的序列 ** 。

比如输入 ` nums = [1,2,3,6,7,8] ` ，遍历到元素 ` 6 ` 时，它只能自己开头形成一个符合条件的子序列 ` [6,7,8] ` 。

**2、当前元素` v ` 接到已经存在的子序列后面 ** 。

比如输入 ` nums = [1,2,3,4,5] ` ，遍历到元素 ` 4 ` 时，它只能接到已经存在的子序列 ` [1,2,3]`后面。它没办法自成开头形成新的子序列，因为少了个 ` 6 ` 。

但是，如果这两种情况都可以，应该如何选择？

比如说，输入 ` nums = [1,2,3,4,5,5,6,7] ` ，对于元素 ` 4 ` ，你说它应该形成一个新的子序列 ` [4,5,6]`还是接到子序列 ` [1,2,3] ` 后面呢？

显然， ` nums ` 数组的正确划分方法是分成 ` [1,2,3,4,5] ` 和 ` [5,6,7] ` ，所以元素 ` 4 ` 应该
**优先判断自己是否能够接到其他序列后面** ，如果不行，再判断是否可以作为新的子序列开头。

这就是整体的思路，想让算法代码实现这两个选择，需要两个哈希表来做辅助：

` freq ` 哈希表帮助一个元素判断自己是否能够作为开头， ` need ` 哈希表帮助一个元素判断自己是否可以被接到其他序列后面。

**` freq ` 记录每个元素出现的次数 ** ，比如 ` freq[3] == 2 ` 说明元素 ` 3 ` 在 ` nums ` 中出现了 2 次。

那么如果我发现 ` freq[3], freq[4], freq[5] ` 都是大于 0 的，那就说明元素 ` 3 ` 可以作为开头组成一个长度为 3 的子序列。

**` need ` 记录哪些元素可以被接到其他子序列后面 ** 。

比如说现在已经组成了两个子序列 ` [1,2,3,4] ` 和 ` [2,3,4] ` ，那么 ` need[5] ` 的值就应该是 2，说明对元素 ` 5
` 的需求为 2。

明白了这两个哈希表的作用，我们就可以看懂解法了：

```java
    bool isPossible(vector<int>& nums) {
    
        unordered_map<int, int> freq, need;
    
       // 统计 nums 中元素的频率
        for (int v : nums) freq[v]++;
        
        for (int v : nums) {
            if (freq[v] == 0) {
               // 已经被用到其他子序列中
                continue;
            }
           // 先判断 v 是否能接到其他子序列后面
            if (need.count(v) && need[v] > 0) {
               // v 可以接到之前的某个序列后面
                freq[v]--;
               // 对 v 的需求减一
                need[v]--;
               // 对 v + 1 的需求加一
                need[v + 1]++; 
            } else if (freq[v] > 0 && freq[v + 1] > 0 && freq[v + 2] > 0) {
               // 将 v 作为开头，新建一个长度为 3 的子序列 [v,v+1,v+2]
                freq[v]--;
                freq[v + 1]--;
                freq[v + 2]--;
               // 对 v + 3 的需求加一
                need[v + 3]++;
            } else {
               // 两种情况都不符合，则无法分配
                return false;
            }
        }
    
        return true;
    }

```

至此，这道题就解决了。

那你可能会说，斗地主里面顺子至少要 5 张连续的牌，我们这道题只计算长度最小为 3 的子序列，怎么办？

很简单，把我们的 else if 分支修改一下，连续判断 ` v ` 之后的连续 5 个元素就行了。

那么，我们再难为难为自己，如果我想要的不只是一个布尔值，我想要你给我把子序列都打印出来，怎么办？

其实这也很好实现，只要修改 ` need ` ，不仅记录对某个元素的需求个数，而且记录具体是哪些子序列产生的需求：

```java
   // need[6] = 2 说明有两个子序列需要 6
    unordered_map<int, int> need;
    
   // need[6] = {
   //     {3,4,5},
   //     {2,3,4,5},
   // }
   // 记录哪两个子序列需要 6
    unordered_map<int, vector<vector<int>>> need;

```

这样，我们稍微修改一下之前的代码就行了：

```java
    bool isPossible(vector<int>& nums) {
        unordered_map<int, int> freq;
        unordered_map<int, vector<vector<int>>> need;
        
        for (int v : nums) freq[v]++;
        
        for (int v : nums) {
            if (freq[v] == 0) {
                continue;
            }
    
            if (need.count(v) && need[v].size() > 0) {
               // v 可以接到之前的某个序列后面
                freq[v]--;
               // 随便取一个需要 v 的子序列
                vector<int> seq = need[v].back();
                need[v].pop_back();
               // 把 v 接到这个子序列后面
                seq.push_back(v);
               // 这个子序列的需求变成了 v + 1
                need[v + 1].push_back(seq);
    
            } else if (freq[v] > 0 && freq[v + 1] > 0 && freq[v + 2] > 0) {
               // 可以将 v 作为开头
                freq[v]--;
                freq[v + 1]--;
                freq[v + 2]--;
               // 新建一个长度为 3 的子序列 [v,v + 1,v + 2]
                vector<int> seq{v, v + 1, v + 2};
               // 对 v + 3 的需求加一
                need[v + 3].push_back(seq);
    
            } else {
                return false;
            }
        }
        
       // 打印切分出的所有子序列
        for (auto it : need) {
            for (vector<int>& seq : it.second) {
                for (int v : seq) {
                    cout << v << " ";
                }
                cout << endl;
            }
        }
        
        return true;
    }

```

这样，我们记录具体子序列的需求也实现了。

如果本文对你有帮助，点个赞，微信会给你推荐更多相似文章。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


 ## 东哥吃葡萄时竟然吃出一道算法题！
 读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 吃葡萄

](https://www.nowcoder.com/questionTerminal/14c0359fb77a48319f0122ec175c9ada)

**———–**

今天在牛客网上做了一道叫做「吃葡萄」的题目，非常有意思。

有三种葡萄，每种分别有 ` a, b, c`颗，现在有三个人，第一个人只吃第一种和第二种葡萄，第二个人只吃第二种和第三种葡萄，第三个人只吃第一种和第三种葡萄。

现在给你输入 ` a, b, c ` 三个值，请你适当安排，让三个人吃完所有的葡萄，算法返回 **吃的最多的人最少要吃多少颗葡萄** 。

题目链接：

[ https://www.nowcoder.com/questionTerminal/14c0359fb77a48319f0122ec175c9ada

](https://www.nowcoder.com/questionTerminal/14c0359fb77a48319f0122ec175c9ada)

牛客网的题目形式和力扣不一样，我去除输入和输出的处理，题目核心就是让你实现这样一个函数：

```java
   // 输入为三种葡萄的颗数，可能非常大，所以用 long 型
   // 返回吃的最多的人最少要吃多少颗葡萄
    long solution(long a, long b, long c);

```

### 题目解析

首先来理解一下题目，你怎么做到使得「吃得最多的那个人吃得最少」？

可以这样理解， **我们先不管每个人只能吃两种特定葡萄的约束** ，你怎么让「吃得最多的那个人吃得最少」？

显然，只要平均分就行了，每个人吃 ` (a+b+c)/3 ` 颗葡萄。即便不能整除，比如说 ` a+b+c=8 ` ，那也要尽可能平均分，就是说一个人吃 2 颗，另两个人吃 3 颗。

综上，「吃得最多的那个人吃得最少」就是让我们尽可能地平均分配， **而吃的最多的那个人吃掉的葡萄颗数就是` (a+b+c)/3 ` 向上取整的结果，也就是
` (a+b+c+2)/3 ` ** 。

> PS：向上取整是一个常用的算法技巧。大部分编程语言中，如果你想计算 ` M ` 除以 ` N ` ， ` M/ N`> 会向下取整，你想向上取整的话，可以改成 ` (M+(N-1))/ N ` 。

好了，刚才在讨论简单情况，现在考虑一下如果加上「每个人只能吃特定两种葡萄」的限制，怎么做？

也就是说，每个人只能吃特定两种葡萄，你也要 **尽可能** 给三个人平均分配，这样才能使得吃得最多的那个人吃得最少。

这可复杂了，如果用 ` X, Y, Z ` 表示这三个人，就会发现他们组成一个三角关系：

![](https://labuladong.gitee.io/algo/images/%e5%90%83%e8%91%a1%e8%90%84/1.jpeg)

你让某一个人多吃某一种葡萄，就会产生连带效应，想着就头疼，这咋整？

### 思路分析

反正万事靠穷举呗，我一开始想了下回溯算法暴力穷举的可能性：

对于每一颗葡萄，可能被谁吃掉？有两种可能呗，那么我写一个回溯算法，把所有可能穷举出来，然后求个最值行不行？

理论上是可行的，但是暴力算法的复杂度一般都是指数级，如果你以葡萄为「主角」进行穷举，看看变量 ` a, b, c ` 都是 long 型的数据，这个复杂度已经让我脊梁沟冒冷汗了。

那么这道题还是得取巧， **思路还是要回到如何「尽可能地平均分配」上面，那么事情就变得有意思起来** 。

如果把葡萄的颗数 ` a, b, c`作为三条线段，它们的大小作为线段的长度，想一想它们可能组成什么几何图形？我们的目的是否可以转化成「尽可能平分这个几何图形的周长」？

三条线段组成的图形，那不就是三角形嘛？不急，我们小学就学过，三角形是要满足两边之和大于第三边的，假设 ` a < b < c ` ，那么有下面两种情况：

**如果` a + b > c ` ** ，那么可以构成一个三角形，只要把边 ` a, b, c`的中点画出来，这三点就一定可以把这个三角形的周长平分成三份，且每一份都包含两条边：

![](https://labuladong.gitee.io/algo/images/%e5%90%83%e8%91%a1%e8%90%84/2.jpeg)

也就是说，这种情况下，三个人依然是可以平均分配所有葡萄的，吃的最多的人最少可以吃到的葡萄颗数依然是 ` (a+b+c+2)/3 ` 。

**如果` a + b <= c ` ** ，这三条边就不能组成一个封闭的图形了，那么我们可以将最长边 ` c ` 「折断」，也就是形成一个四边形。

这里面有两种情况：

![](https://labuladong.gitee.io/algo/images/%e5%90%83%e8%91%a1%e8%90%84/3.jpeg)

对于情况一， ` a + b ` 和 ` c ` 的差距还不大的时候，可以看到依然能够让三个人平分这个四边形，那么吃的最多的人最少可以吃到的葡萄颗数依然是
` (a+b+c+2)/3 ` 。

随着 ` c ` 的不断增大，就会出现情况二，此时 ` c > 2*(a+b) ` ，由于每个人口味的限制，为了尽可能平分， ` X ` 最多吃完 ` a
` 和 ` b ` ，而 ` c ` 边需要被 ` Y ` 或 ` Z ` 平分，也就是说此时吃的最多的人最少可以吃到的葡萄颗数就是 ` (c+1)/2`，即平分 ` c ` 边向上取整。

以上就是全部情况，翻译成代码如下：

```java
    long solution(long a, long b, long c) {
        long[] nums = new long[]{a, b, c};
        Arrays.sort(nums);
        long sum = a + b + c;
    
       // 能够构成三角形，可完全平分
        if (nums[0] + nums[1] > nums[2]) {
            return (sum + 2)/ 3;
        }
       // 不能构成三角形，平分最长边的情况
        if (2 * (nums[0] + nums[1]) < nums[2]) {
            return (nums[2] + 1)/ 2;
        }
       // 不能构成三角形，但依然可以完全平分的情况
        return (sum + 2)/ 3;
    }

```

至此，这道题就被巧妙地解决了，时间复杂度仅需 O(1)，关键思路在于如何尽可能平分。

谁又能想到，吃个葡萄得借助几何图形？也许这就算法的魅力吧…

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


 ## 烧饼排序算法
 读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 969. 煎饼排序（中等） ](https://leetcode-cn.com/problems/pancake-sorting)

**———–**

烧饼排序是个很有意思的实际问题：假设盘子上有 ` n ` 块 **面积大小不一**
的烧饼，你如何用一把锅铲进行若干次翻转，让这些烧饼的大小有序（小的在上，大的在下）？

![](https://labuladong.gitee.io/algo/images/pancakeSort/1.jpg)

设想一下用锅铲翻转一堆烧饼的情景，其实是有一点限制的，我们每次只能将最上面的若干块饼子翻转：

![](https://labuladong.gitee.io/algo/images/pancakeSort/2.png)

我们的问题是， **如何使用算法得到一个翻转序列，使得烧饼堆变得有序** ？

首先，需要把这个问题抽象，用数组来表示烧饼堆：

![](https://labuladong.gitee.io/algo/images/pancakeSort/title.png)

如何解决这个问题呢？其实类似上篇文章 [ 递归反转链表的一部分 ](https://labuladong.gitee.io/algo/2/16/16/) ，这也是需要 **递归思想** 的。

### 一、思路分析

为什么说这个问题有递归性质呢？比如说我们需要实现这样一个函数：

```java
   // cakes 是一堆烧饼，函数会将前 n 个烧饼排序
    void sort(int[] cakes, int n);

```

如果我们找到了前 ` n ` 个烧饼中最大的那个，然后设法将这个饼子翻转到最底下：

![](https://labuladong.gitee.io/algo/images/pancakeSort/3.jpg)

那么，原问题的规模就可以减小，递归调用 ` pancakeSort(A, n-1) ` 即可：

![](https://labuladong.gitee.io/algo/images/pancakeSort/4.jpg)

接下来，对于上面的这 ` n - 1 ` 块饼，如何排序呢？还是先从中找到最大的一块饼，然后把这块饼放到底下，再递归调用 ` pancakeSort(A, n-1-1) ` ……

你看，这就是递归性质，总结一下思路就是：

1、找到 ` n ` 个饼中最大的那个。

2、把这个最大的饼移到最底下。

3、递归调用 ` pancakeSort(A, n - 1) ` 。

base case： ` n == 1 ` 时，排序 1 个饼时不需要翻转。

那么，最后剩下个问题， **如何设法将某块烧饼翻到最后呢** ？

其实很简单，比如第 3 块饼是最大的，我们想把它换到最后，也就是换到第 ` n ` 块。可以这样操作：

1、用锅铲将前 3 块饼翻转一下，这样最大的饼就翻到了最上面。

2、用锅铲将前 ` n ` 块饼全部翻转，这样最大的饼就翻到了第 ` n ` 块，也就是最后一块。

以上两个流程理解之后，基本就可以写出解法了，不过题目要求我们写出具体的反转操作序列，这也很简单，只要在每次翻转烧饼时记录下来就行了。

### 二、代码实现

只要把上述的思路用代码实现即可，唯一需要注意的是，数组索引从 0 开始，而我们要返回的结果是从 1 开始算的。

```java
   // 记录反转操作序列
    LinkedList<Integer> res = new LinkedList<>();
    
    List<Integer> pancakeSort(int[] cakes) {
        sort(cakes, cakes.length);
        return res;
    }
    
    void sort(int[] cakes, int n) {
       // base case
        if (n == 1) return;
        
       // 寻找最大饼的索引
        int maxCake = 0;
        int maxCakeIndex = 0;
        for (int i = 0; i < n; i++)
            if (cakes[i] > maxCake) {
                maxCakeIndex = i;
                maxCake = cakes[i];
            }
        
       // 第一次翻转，将最大饼翻到最上面
        reverse(cakes, 0, maxCakeIndex);
        res.add(maxCakeIndex + 1);
       // 第二次翻转，将最大饼翻到最下面
        reverse(cakes, 0, n - 1);
        res.add(n);
    
       // 递归调用
        sort(cakes, n - 1);
    }
    
    void reverse(int[] arr, int i, int j) {
        while (i < j) {
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
            i++; j--;
        }
    }

```

通过刚才的详细解释，这段代码应该是很清晰了。

算法的时间复杂度很容易计算，因为递归调用的次数是 ` n ` ，每次递归调用都需要一次 for 循环，时间复杂度是 O(n)，所以总的复杂度是 O(n^2)。

**最后，我们可以思考一个问题​** ：按照我们这个思路，得出的操作序列长度应该为​ ` 2(n - 1) ` ，因为每次递归都要进行 2 次翻转并记录操作，总共有 ` n ` 层递归，但由于 base case
直接返回结果，不进行翻转，所以最终的操作序列长度应该是固定的 ` 2(n - 1)
` 。

显然，这个结果不是最优的（最短的），比如说一堆煎饼 ` [3,2,4,1] ` ，我们的算法得到的翻转序列是 ` [3,4,2,3,1,2]`，但是最快捷的翻转方法应该是 ` [2,3,4] ` ：

```java
    初始状态 ：[3,2,4,1]
    翻前 2 个：[2,3,4,1]
    翻前 3 个：[4,3,2,1]
    翻前 4 个：[1,2,3,4]

```

如果要求你的算法计算排序烧饼的 **最短** 操作序列，你该如何计算呢？或者说，解决这种求最优解法的问题，核心思路什么，一定需要使用什么算法技巧呢？

不妨分享一下你的思考。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


 ## 字符串乘法计算
 读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 43. 字符串相乘（中等） ](https://leetcode-cn.com/problems/multiply-strings)

**———–**

对于比较小的数字，做运算可以直接使用编程语言提供的运算符，但是如果相乘的两个因数非常大，语言提供的数据类型可能就会溢出。一种替代方案就是，运算数以字符串的形式输入，然后模仿我们小学学习的乘法算术过程计算出结果，并且也用字符串表示。

![](https://labuladong.gitee.io/algo/images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%98%E6%B3%95/title.png)

需要注意的是， ` num1 ` 和 ` num2 ` 可以非常长，所以不可以把他们直接转成整型然后运算，唯一的思路就是模仿我们手算乘法。

比如说我们手算 ` 123 × 45 ` ，应该会这样计算：

![](https://labuladong.gitee.io/algo/images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%98%E6%B3%95/1.jpg)

计算 ` 123 × 5 ` ，再计算 ` 123 × 4 ` ，最后错一位相加。这个流程恐怕小学生都可以熟练完成，但是你是否能
**把这个运算过程进一步机械化** ，写成一套算法指令让没有任何智商的计算机来执行呢？

你看这个简单过程，其中涉及乘法进位，涉及错位相加，还涉及加法进位；而且还有一些不易察觉的问题，比如说两位数乘以两位数，结果可能是四位数，也可能是三位数，你怎么想出一个标准化的处理方式？这就是算法的魅力，如果没有计算机思维，简单的问题可能都没办法自动化处理。

首先，我们这种手算方式还是太「高级」了，我们要再「低级」一点， ` 123 × 5 ` 和 ` 123 × 4 ` 的过程还可以进一步分解，最后再相加：

![](https://labuladong.gitee.io/algo/images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%98%E6%B3%95/2.jpg)

现在 ` 123 ` 并不大，如果是个很大的数字的话，是无法直接计算乘积的。我们可以用一个数组在底下接收相加结果：

![](https://labuladong.gitee.io/algo/images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%98%E6%B3%95/3.jpg)

整个计算过程大概是这样， **有两个指针` i，j ` 在 ` num1 ` 和 ` num2 ` 上游走，计算乘积，同时将乘积叠加到 ` res`的正确位置 ** ：

![](https://labuladong.gitee.io/algo/images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%98%E6%B3%95/4.gif)

现在还有一个关键问题，如何将乘积叠加到 ` res ` 的正确位置，或者说，如何通过 ` i，j ` 计算 ` res ` 的对应索引呢？

其实，细心观察之后就发现， **` num1[i] ` 和 ` num2[j] ` 的乘积对应的就是 ` res[i+j] ` 和 ` res[i+j+1]
` 这两个位置 ** 。

![](https://labuladong.gitee.io/algo/images/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%98%E6%B3%95/6.jpg)

明白了这一点，就可以用代码模仿出这个计算过程了：

```java
    string multiply(string num1, string num2) {
        int m = num1.size(), n = num2.size();
       // 结果最多为 m + n 位数
        vector<int> res(m + n, 0);
       // 从个位数开始逐位相乘
        for (int i = m - 1; i >= 0; i--)
            for (int j = n - 1; j >= 0; j--) {
                int mul = (num1[i]-'0') * (num2[j]-'0');
               // 乘积在 res 对应的索引位置
                int p1 = i + j, p2 = i + j + 1;
               // 叠加到 res 上
                int sum = mul + res[p2];
                res[p2] = sum % 10;
                res[p1] += sum/ 10;
            }
       // 结果前缀可能存的 0（未使用的位）
        int i = 0;
        while (i < res.size() && res[i] == 0)
            i++;
       // 将计算结果转化成字符串
        string str;
        for (; i < res.size(); i++)
            str.push_back('0' + res[i]);
        
        return str.size() == 0 ? "0" : str;
    }

```

至此，字符串乘法算法就完成了。

**总结一下**
，我们习以为常的一些思维方式，在计算机看来是非常难以做到的。比如说我们习惯的算术流程并不复杂，但是如果让你再进一步，翻译成代码逻辑，并不简单。算法需要将计算流程再简化，通过边算边叠加的方式来得到结果。

俗话教育我们，不要陷入思维定式，不要程序化，要发散思维，要创新。但我觉得程序化并不是坏事，可以大幅提高效率，减小失误率。算法不就是一套程序化的思维吗，只有程序化才能让计算机帮助我们解决复杂问题呀！

也许算法就是一种 **寻找思维定式的思维** 吧，希望本文对你有帮助。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


 ## 如何实现一个计算器
 读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 224. 基本计算器（困难） ](https://leetcode-cn.com/problems/basic-calculator)

[ 227. 基本计算器II（中等） ](https://leetcode-cn.com/problems/basic-calculator-ii)

[ 772. 基本计算器III（困难） ](https://leetcode-cn.com/problems/basic-calculator-iii)

**———–**

我们最终要实现的计算器功能如下：

1、输入一个字符串，可以包含 ` \+ - */ ` 、数字、括号以及空格，你的算法返回运算结果。

2、要符合运算法则，括号的优先级最高，先乘除后加减。

3、除号是整数除法，无论正负都向 0 取整（5/2=2，-5/2=-2）。

4、可以假定输入的算式一定合法，且计算过程不会出现整型溢出，不会出现除数为 0 的意外情况。

比如输入如下字符串，算法会返回 9：

` 3 * (2-6/(3 -7))`
可以看到，这就已经非常接近我们实际生活中使用的计算器了，虽然我们以前肯定都用过计算器，但是如果简单思考一下其算法实现，就会大惊失色：

1、按照常理处理括号，要先计算最内层的括号，然后向外慢慢化简。这个过程我们手算都容易出错，何况写成算法呢！

2、要做到先乘除，后加减，这一点教会小朋友还不算难，但教给计算机恐怕有点困难。

3、要处理空格。我们为了美观，习惯性在数字和运算符之间打个空格，但是计算之中得想办法忽略这些空格。

我记得很多大学数据结构的教材上，在讲栈这种数据结构的时候，应该都会用计算器举例，但是有一说一，讲的真的垃圾，不知道多少未来的计算机科学家就被这种简单的数据结构劝退了。

那么本文就来聊聊怎么实现上述一个功能完备的计算器功能， **关键在于层层拆解问题，化整为零，逐个击破** ，相信这种思维方式能帮大家解决各种复杂问题。

下面就来拆解，从最简单的一个问题开始。

### 一、字符串转整数

是的，就是这么一个简单的问题，首先告诉我，怎么把一个字符串形式的 **正** 整数，转化成 int 型？

```java
    string s = "458";
    
    int n = 0;
    for (int i = 0; i < s.size(); i++) {
        char c = s[i];
        n = 10 * n + (c - '0');
    }
   // n 现在就等于 458

```

这个还是很简单的吧，老套路了。但是即便这么简单，依然有坑： **` (c - '0') ` 的这个括号不能省略，否则可能造成整型溢出 ** 。

因为变量 ` c ` 是一个 ASCII 码，如果不加括号就会先加后减，想象一下 ` s ` 如果接近 INT_MAX，就会溢出。所以用括号保证先减后加才行。

### 二、处理加减法

现在进一步， **如果输入的这个算式只包含加减法，而且不存在空格** ，你怎么计算结果？我们拿字符串算式 ` 1-12+3 ` 为例，来说一个很简单的思路：

1、先给第一个数字加一个默认符号 ` \+ ` ，变成 ` +1-12+3 ` 。

2、把一个运算符和数字组合成一对儿，也就是三对儿 ` +1 ` ， ` -12 ` ， ` +3 ` ，把它们转化成数字，然后放到一个栈中。

3、将栈中所有的数字求和，就是原算式的结果。

我们直接看代码，结合一张图就看明白了：

```java
    int calculate(string s) {
        stack<int> stk;
       // 记录算式中的数字
        int num = 0;
       // 记录 num 前的符号，初始化为 +
        char sign = '+';
        for (int i = 0; i < s.size(); i++) {
            char c = s[i];
           // 如果是数字，连续读取到 num
            if (isdigit(c)) 
                num = 10 * num + (c - '0');
           // 如果不是数字，就是遇到了下一个符号，
           // 之前的数字和符号就要存进栈中
            if (!isdigit(c) || i == s.size() - 1) {
                switch (sign) {
                    case '+':
                        stk.push(num); break;
                    case '-':
                        stk.push(-num); break;
                }
               // 更新符号为当前符号，数字清零
                sign = c;
                num = 0;
            }
        }
       // 将栈中所有结果求和就是答案
        int res = 0;
        while (!stk.empty()) {
            res += stk.top();
            stk.pop();
        }
        return res;
    }

```

我估计就是中间带 ` switch ` 语句的部分有点不好理解吧， ` i ` 就是从左到右扫描， ` sign ` 和 ` num ` 跟在它身后。当`s[i] ` 遇到一个运算符时，情况是这样的：

![](https://labuladong.gitee.io/algo/images/calculator/1.jpg)

所以说，此时要根据 ` sign ` 的 case 不同选择 ` nums ` 的正负号，存入栈中，然后更新 ` sign ` 并清零 ` nums`记录下一对儿符合和数字的组合。

另外注意，不只是遇到新的符号会触发入栈，当 ` i ` 走到了算式的尽头（ ` i == s.size() - 1`），也应该将前面的数字入栈，方便后续计算最终结果。

![](https://labuladong.gitee.io/algo/images/calculator/2.jpg)

至此，仅处理紧凑加减法字符串的算法就完成了，请确保理解以上内容，后续的内容就基于这个框架修修改改就完事儿了。

### 三、处理乘除法

其实思路跟仅处理加减法没啥区别，拿字符串 ` 2-3*4+5 ` 举例，核心思路依然是把字符串分解成符号和数字的组合。

比如上述例子就可以分解为 ` +2 ` ， ` -3 ` ， ` *4 ` ， ` +5 ` 几对儿，我们刚才不是没有处理乘除号吗，很简单，
**其他部分都不用变** ，在 ` switch ` 部分加上对应的 case 就行了：

```java
    for (int i = 0; i < s.size(); i++) {
        char c = s[i];
        if (isdigit(c)) 
            num = 10 * num + (c - '0');
    
        if (!isdigit(c) || i == s.size() - 1) {
            switch (sign) {
                int pre;
                case '+':
                    stk.push(num); break;
                case '-':
                    stk.push(-num); break;
               // 只要拿出前一个数字做对应运算即可
                case '*':
                    pre = stk.top();
                    stk.pop();
                    stk.push(pre * num);
                    break;
                case '/':
                    pre = stk.top();
                    stk.pop();
                    stk.push(pre/ num);
                    break;
            }
           // 更新符号为当前符号，数字清零
            sign = c;
            num = 0;
        }
    }

```

![](https://labuladong.gitee.io/algo/images/calculator/3.jpg)

**乘除法优先于加减法体现在，乘除法可以和栈顶的数结合，而加减法只能把自己放入栈** 。

现在我们思考一下 **如何处理字符串中可能出现的空格字符** 。其实也非常简单，想想空格字符的出现，会影响我们现有代码的哪一部分？

```java
   // 如果 c 非数字
    if (!isdigit(c) || i == s.size() - 1) {
        switch (c) {...}
        sign = c;
        num = 0;
    }

```

显然空格会进入这个 if 语句，但是我们并不想让空格的情况进入这个 if，因为这里会更新 ` sign ` 并清零 ` nums`，空格根本就不是运算符，应该被忽略。

那么只要多加一个条件即可：

```java
    if ((!isdigit(c) && c != ' ') || i == s.size() - 1) {
        ...
    }

```

好了，现在我们的算法已经可以按照正确的法则计算加减乘除，并且自动忽略空格符，剩下的就是如何让算法正确识别括号了。

### 四、处理括号

处理算式中的括号看起来应该是最难的，但真没有看起来那么难。

为了规避编程语言的繁琐细节，我把前面解法的代码翻译成 Python 版本：

```java
    def calculate(s: str) -> int:
            
        def helper(s: List) -> int:
            stack = []
            sign = '+'
            num = 0
    
            while len(s) > 0:
                c = s.pop(0)
                if c.isdigit():
                    num = 10 * num + int(c)
    
                if (not c.isdigit() and c != ' ') or len(s) == 0:
                    if sign == '+':
                        stack.append(num)
                    elif sign == '-':
                        stack.append(-num)
                    elif sign == '*':
                        stack[-1] = stack[-1] * num
                    elif sign == '/':
                         python 除法向 0 取整的写法
                        stack[-1] = int(stack[-1]/ float(num))                    
                    num = 0
                    sign = c
    
            return sum(stack)
         需要把字符串转成列表方便操作
        return helper(list(s))

```

这段代码跟刚才 C++ 代码完全相同，唯一的区别是，不是从左到右遍历字符串，而是不断从左边 ` pop ` 出字符，本质还是一样的。

那么，为什么说处理括号没有看起来那么难呢， **因为括号具有递归性质** 。我们拿字符串 ` 3*(4-5/2)-6 ` 举例：

calculate( ` 3*(4-5/2)-6 ` ) = 3 * calculate( ` 4-5/2 ` ) - 6 = 3 * 2 - 6 = 0

可以脑补一下，无论多少层括号嵌套，通过 calculate 函数递归调用自己，都可以将括号中的算式化简成一个数字。
**换句话说，括号包含的算式，我们直接视为一个数字就行了** 。

现在的问题是，递归的开始条件和结束条件是什么？ **遇到` ( ` 开始递归，遇到 ` ) ` 结束递归 ** ：

```java
    def calculate(s: str) -> int:
            
        def helper(s: List) -> int:
            stack = []
            sign = '+'
            num = 0
    
            while len(s) > 0:
                c = s.popleft()
                if c.isdigit():
                    num = 10 * num + int(c)
                 遇到左括号开始递归计算 num
                if c == '(':
                    num = helper(s)
    
                if (not c.isdigit() and c != ' ') or len(s) == 0:
                    if sign == '+': ...
                    elif sign == '-': ... 
                    elif sign == '*': ...
                    elif sign == '/': ...
                    num = 0
                    sign = c
                 遇到右括号返回递归结果
                if c == ')': break
            return sum(stack)
    
        return helper(collections.deque(s))

```

![](https://labuladong.gitee.io/algo/images/calculator/4.jpg) ![](https://labuladong.gitee.io/algo/images/calculator/5.jpg)
![](https://labuladong.gitee.io/algo/images/calculator/6.jpg)

你看，加了两三行代码，就可以处理括号了，这就是递归的魅力。至此，计算器的全部功能就实现了，通过对问题的层层拆解化整为零，再回头看，这个问题似乎也没那么复杂嘛。

### 五、最后总结

本文借实现计算器的问题，主要想表达的是一种处理复杂问题的思路。

我们首先从字符串转数字这个简单问题开始，进而处理只包含加减法的算式，进而处理包含加减乘除四则运算的算式，进而处理空格字符，进而处理包含括号的算式。

**可见，对于一些比较困难的问题，其解法并不是一蹴而就的，而是步步推进，螺旋上升的**
。如果一开始给你原题，你不会做，甚至看不懂答案，都很正常，关键在于我们自己如何简化问题，如何以退为进。

**退而求其次是一种很聪明策略** 。你想想啊，假设这是一道考试题，你不会实现这个计算器，但是你写了字符串转整数的算法并指出了容易溢出的陷阱，那起码可以得 20 分吧；如果你能够处理加减法，那可以得 40
分吧；如果你能处理加减乘除四则运算，那起码够 70 分了；再加上处理空格字符，80 有了吧。我就是不会处理括号，那就算了，80 已经很 OK 了好不好。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


 ## 如何高效解决接雨水问题
 读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 42. 接雨水（困难） ](https://leetcode-cn.com/problems/trapping-rain-water)

**———–**

接雨水这道题目挺有意思，在面试题中出现频率还挺高的，本文就来步步优化，讲解一下这道题。

先看一下题目：

![](https://labuladong.gitee.io/algo/images/%e6%8e%a5%e9%9b%a8%e6%b0%b4/title.png)

就是用一个数组表示一个条形图，问你这个条形图最多能接多少水。

```java
    int trap(int[] height);

```

下面就来由浅入深介绍暴力解法 -> 备忘录解法 -> 双指针解法，在 O(N) 时间 O(1) 空间内解决这个问题。

### 一、核心思路

所以对于这种问题，我们不要想整体，而应该去想局部；就像之前的文章写的动态规划问题处理字符串问题，不要考虑如何处理整个字符串，而是去思考应该如何处理每一个字符。

这么一想，可以发现这道题的思路其实很简单。具体来说，仅仅对于位置 ` i ` ，能装下多少水呢？

![](https://labuladong.gitee.io/algo/images/%e6%8e%a5%e9%9b%a8%e6%b0%b4/0.jpg)

能装 2 格水，因为 ` height[i] ` 的高度为 0，而这里最多能盛 2 格水，2-0=2。

为什么位置 ` i ` 最多能盛 2 格水呢？因为，位置 ` i ` 能达到的水柱高度和其左边的最高柱子、右边的最高柱子有关，我们分别称这两个柱子高度为`l_max ` 和 ` r_max ` ； **位置 i 最大的水柱高度就是` min(l_max, r_max) ` ** 。

更进一步，对于位置 ` i ` ，能够装的水为：

```java
    water[i] = min(
                    左边最高的柱子
                   max(height[0..i]),  
                    右边最高的柱子
                   max(height[i..end]) 
                ) - height[i]

```

![](https://labuladong.gitee.io/algo/images/%e6%8e%a5%e9%9b%a8%e6%b0%b4/1.jpg)
![](https://labuladong.gitee.io/algo/images/%e6%8e%a5%e9%9b%a8%e6%b0%b4/2.jpg)

这就是本问题的核心思路，我们可以简单写一个暴力算法：

```java
    int trap(int[] height) {
        int n = height.length;
        int res = 0;
        for (int i = 1; i < n - 1; i++) {
            int l_max = 0, r_max = 0;
           // 找右边最高的柱子
            for (int j = i; j < n; j++)
                r_max = Math.max(r_max, height[j]);
           // 找左边最高的柱子
            for (int j = i; j >= 0; j--)
                l_max = Math.max(l_max, height[j]);
           // 如果自己就是最高的话，
           // l_max == r_max == height[i]
            res += Math.min(l_max, r_max) - height[i];
        }
        return res;
    }

```

有之前的思路，这个解法应该是很直接粗暴的，时间复杂度 O(N^2)，空间复杂度 O(1)。但是很明显这种计算 ` r_max ` 和 ` l_max`的方式非常笨拙，一般的优化方法就是备忘录。

### 二、备忘录优化

之前的暴力解法，不是在每个位置 ` i ` 都要计算 ` r_max ` 和 ` l_max`吗？我们直接把结果都提前计算出来，别傻不拉几的每次都遍历，这时间复杂度不就降下来了嘛。

**我们开两个数组` r_max ` 和 ` l_max ` 充当备忘录， ` l_max[i] ` 表示位置 ` i ` 左边最高的柱子高度，`r_max[i] ` 表示位置 ` i ` 右边最高的柱子高度 ** 。预先把这两个数组计算好，避免重复计算：

```java
    int trap(int[] height) {
        if (height.length == 0) {
            return 0;
        }
        int n = height.length;
        int res = 0;
       // 数组充当备忘录
        int[] l_max = new int[n];
        int[] r_max = new int[n];
       // 初始化 base case
        l_max[0] = height[0];
        r_max[n - 1] = height[n - 1];
       // 从左向右计算 l_max
        for (int i = 1; i < n; i++)
            l_max[i] = Math.max(height[i], l_max[i - 1]);
       // 从右向左计算 r_max
        for (int i = n - 2; i >= 0; i--)
            r_max[i] = Math.max(height[i], r_max[i + 1]);
       // 计算答案
        for (int i = 1; i < n - 1; i++)
            res += Math.min(l_max[i], r_max[i]) - height[i];
        return res;
    }

```

这个优化其实和暴力解法思路差不多，就是避免了重复计算，把时间复杂度降低为 O(N)，已经是最优了，但是空间复杂度是 O(N)。下面来看一个精妙一些的解法，能够把空间复杂度降低到 O(1)。

### 三、双指针解法

这种解法的思路是完全相同的，但在实现手法上非常巧妙，我们这次也不要用备忘录提前计算了，而是用双指针 **边走边算** ，节省下空间复杂度。

首先，看一部分代码：

```java
    int trap(int[] height) {
        int left = 0, right = height.length - 1;
        int l_max = 0, r_max = 0;
        
        while (left < right) {
            l_max = Math.max(l_max, height[left]);
            r_max = Math.max(r_max, height[right]);
           // 此时 l_max 和 r_max 分别表示什么？
            left++; right--;
        }
    }

```

对于这部分代码，请问 ` l_max ` 和 ` r_max ` 分别表示什么意义呢？

很容易理解， **` l_max ` 是 ` height[0..left] ` 中最高柱子的高度， ` r_max ` 是`height[right..end] ` 的最高柱子的高度 ** 。

明白了这一点，直接看解法：

```java
    int trap(int[] height) {
        int left = 0, right = height.length - 1;
        int l_max = 0, r_max = 0;
    
        int res = 0;
        while (left < right) {
            l_max = Math.max(l_max, height[left]);
            r_max = Math.max(r_max, height[right]);
    
           // res += min(l_max, r_max) - height[i]
            if (l_max < r_max) {
                res += l_max - height[left];
                left++;
            } else {
                res += r_max - height[right];
                right--;
            }
        }
        return res;
    }

```

你看，其中的核心思想和之前一模一样，换汤不换药。但是细心的读者可能会发现次解法还是有点细节差异：

之前的备忘录解法， ` l_max[i] ` 和 ` r_max[i] ` 分别代表 ` height[0..i] ` 和 ` height[i..end]
` 的最高柱子高度。

```java
    res += Math.min(l_max[i], r_max[i]) - height[i];

```

![](https://labuladong.gitee.io/algo/images/%e6%8e%a5%e9%9b%a8%e6%b0%b4/3.jpg)

但是双指针解法中， ` l_max ` 和 ` r_max ` 代表的是 ` height[0..left] ` 和`height[right..end] ` 的最高柱子高度。比如这段代码：

```java
    if (l_max < r_max) {
        res += l_max - height[left];
        left++; 
    } 

```

![](https://labuladong.gitee.io/algo/images/%e6%8e%a5%e9%9b%a8%e6%b0%b4/4.jpg)

此时的 ` l_max ` 是 ` left ` 指针左边的最高柱子，但是 ` r_max ` 并不一定是 ` left`指针右边最高的柱子，这真的可以得到正确答案吗？

其实这个问题要这么思考，我们只在乎 ` min(l_max, r_max) ` 。 **对于上图的情况，我们已经知道` l_max < r_max`了，至于这个 ` r_max ` 是不是右边最大的，不重要。重要的是 ` height[i] ` 能够装的水只和较低的 ` l_max ` 之差有关 **
：

![](https://labuladong.gitee.io/algo/images/%e6%8e%a5%e9%9b%a8%e6%b0%b4/5.jpg)

这样，接雨水问题就解决了。

### 扩展延伸

下面我们看一道和接雨水问题非常类似的题目，力扣第 11 题「盛最多水的容器」：

![](https://labuladong.gitee.io/algo/images/%e6%8e%a5%e9%9b%a8%e6%b0%b4/title1.png)

函数签名如下：

```java
    int maxArea(int[] height);

```

这题和接雨水问题很类似，可以完全套用前文的思路，而且还更简单。两道题的区别在于：

**接雨水问题给出的类似一幅直方图，每个横坐标都有宽度，而本题给出的每个横坐标是一条竖线，没有宽度** 。

我们前文讨论了半天 ` l_max ` 和 ` r_max ` ，实际上都是为了计算 ` height[i] ` 能够装多少水；而本题中`height[i] ` 没有了宽度，那自然就好办多了。

举个例子，如果在接雨水问题中，你知道了 ` height[left] ` 和 ` height[right] ` 的高度，你能算出 ` left ` 和`right ` 之间能够盛下多少水吗？

不能，因为你不知道 ` left ` 和 ` right ` 之间每个柱子具体能盛多少水，你得通过每个柱子的 ` l_max ` 和 ` r_max`来计算才行。

反过来，就本题而言，你知道了 ` height[left] ` 和 ` height[right] ` 的高度，能算出 ` left ` 和 ` right
` 之间能够盛下多少水吗？

可以，因为本题中竖线没有宽度，所以 ` left ` 和 ` right ` 之间能够盛的水就是：

```java
    min(height[left], height[right]) * (right - left)

```

类似接雨水问题，高度是由 ` height[left] ` 和 ` height[right] ` 较小的值决定的。

解决这道题的思路依然是双指针技巧：

**用` left ` 和 ` right ` 两个指针从两端向中心收缩，一边收缩一边计算 ` [left, right]`之间的矩形面积，取最大的面积值即是答案 ** 。

先直接看解法代码吧：

```java
    int maxArea(int[] height) {
        int left = 0, right = height.length - 1;
        int res = 0;
        while (left < right) {
           // [left, right] 之间的矩形面积
            int cur_area = Math.min(height[left], height[right]) * (right - left);
            res = Math.max(res, cur_area);
           // 双指针技巧，移动较低的一边
            if (height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
        }
        return res;
    }

```

代码和接雨水问题大致相同，不过肯定有读者会问，下面这段 if 语句为什么要移动较低的一边：

```java
   // 双指针技巧，移动较低的一边
    if (height[left] < height[right]) {
        left++;
    } else {
        right--;
    }

```

**其实也好理解，因为矩形的高度是由` min(height[left], height[right]) ` 即较低的一边决定的 ** ：

你如果移动较低的那一边，那条边可能会变高，使得矩形的高度变大，进而就「有可能」使得矩形的面积变大；相反，如果你去移动较高的那一边，矩形的高度是无论如何都不会变大的，所以不可能使矩形的面积变得更大。

至此，这道题也解决了。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


 ## 如何寻找最长回文子串
 读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 5. 最长回文子串（中等） ](https://leetcode-cn.com/problems/longest-palindromic-
substring)

**———–**

回文串是面试常常遇到的问题（虽然问题本身没啥意义），本文就告诉你回文串问题的核心思想是什么。

首先，明确一下什： **回文串就是正着读和反着读都一样的字符串** 。

比如说字符串 ` aba ` 和 ` abba ` 都是回文串，因为它们对称，反过来还是和本身一样。反之，字符串 ` abac ` 就不是回文串。

可以看到回文串的的长度可能是奇数，也可能是偶数，这就添加了回文串问题的难度，解决该类问题的核心是 **双指针**
。下面就通过一道最长回文子串的问题来具体理解一下回文串问题：

![](https://labuladong.gitee.io/algo/images/%e5%9b%9e%e6%96%87/title.png)

```java
    public String longestPalindrome(String s);

```

### 一、思考

对于这个问题，我们首先应该思考的是，给一个字符串 ` s ` ，如何在 ` s ` 中找到一个回文子串？

有一个很有趣的思路：既然回文串是一个正着反着读都一样的字符串，那么如果我们把 ` s ` 反转，称为 ` s' ` ，然后在 ` s ` 和 ` s'`中寻找 **最长公共子串** ，这样应该就能找到最长回文子串。

比如说字符串 ` abacd ` ，反过来是 ` dcaba ` ，它的最长公共子串是 ` aba ` ，也就是最长回文子串。

但是这个思路是错误的，比如说字符串 ` aacxycaa ` ，反转之后是 ` aacyxcaa ` ，最长公共子串是 ` aac`，但是最长回文子串应该是 ` aa ` 。

虽然这个思路不正确，但是 **这种把问题转化为其他形式的思考方式是非常值得提倡的** 。

下面，就来说一下正确的思路，如何使用双指针。

**寻找回文串的问题核心思想是：从中间开始向两边扩散来判断回文串** 。对于最长回文子串，就是这个意思：

```java
    for 0 <= i < len(s):
        找到以 s[i] 为中心的回文串
        更新答案

```

但是呢，我们刚才也说了，回文串的长度可能是奇数也可能是偶数，如果是 ` abba ` 这种情况，没有一个中心字符，上面的算法就没辙了。所以我们可以修改一下：

```java
    for 0 <= i < len(s):
        找到以 s[i] 为中心的回文串
        找到以 s[i] 和 s[i+1] 为中心的回文串
        更新答案

```

> PS：读者可能发现这里的索引会越界，等会会处理。

### 二、代码实现

按照上面的思路，先要实现一个函数来寻找最长回文串，这个函数是有点技巧的：

```java
    String palindrome(String s, int l, int r) {
       // 防止索引越界
        while (l >= 0 && r < s.length()
                && s.charAt(l) == s.charAt(r)) {
           // 向两边展开
            l--; r++;
        }
       // 返回以 s[l] 和 s[r] 为中心的最长回文串
        return s.substring(l + 1, r);
        }

```

为什么要传入两个指针 ` l ` 和 ` r ` 呢？ **因为这样实现可以同时处理回文串长度为奇数和偶数的情况** ：

```java
    for 0 <= i < len(s):
         找到以 s[i] 为中心的回文串
        palindrome(s, i, i)
         找到以 s[i] 和 s[i+1] 为中心的回文串
        palindrome(s, i, i + 1)
        更新答案

```

下面看下 ` longestPalindrome ` 的完整代码：

```java
    public String longestPalindrome(String s) {
        String res = "";
        for (int i = 0; i < s.length(); i++) {
           // 以 s[i] 为中心的最长回文子串
            String s1 = palindrome(s, i, i);
           // 以 s[i] 和 s[i+1] 为中心的最长回文子串
            String s2 = palindrome(s, i, i + 1);
           // res = longest(res, s1, s2)
            res = res.length() > s1.length() ? res : s1;
            res = res.length() > s2.length() ? res : s2;
        }
        return res;
    }

```

至此，这道最长回文子串的问题就解决了，时间复杂度 O(N^2)，空间复杂度 O(1)。

值得一提的是，这个问题可以用动态规划方法解决，时间复杂度一样，但是空间复杂度至少要 O(N^2) 来存储 DP table。这道题是少有的动态规划非最优解法的问题。

另外，这个问题还有一个巧妙的解法，时间复杂度只需要 O(N)，不过该解法比较复杂，我个人认为没必要掌握。该算法的名字叫 Manacher’s Algorithm（马拉车算法），有兴趣的读者可以自行搜索一下。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


 ## 如何解决括号相关的问题
 读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 20. 有效的括号（简单） ](https://leetcode-cn.com/problems/valid-parentheses)

[ 921. 使括号有效的最小添加（中等） ](https://leetcode-cn.com/problems/minimum-add-to-make-
parentheses-valid)

[ 1541. 平衡括号串的最少插入（中等） ](https://leetcode-cn.com/problems/minimum-insertions-
to-balance-a-parentheses-string)

**———–**

### 判断合法括号串

对括号的合法性判断多次在笔试中出现，现实中也很常见，比如说我们写的代码，编辑器会检查括号是否正确闭合。而且我们的代码可能会包含三种括号 ` [](){}`，判断起来有一点难度。

来看一看力扣第 20 题「有效的括号」，输入一个字符串，其中包含 ` [](){} ` 六种括号，请你判断这个字符串组成的括号是否合法。

举几个例子：

```java
    Input: "()[]{}"
    Output: true
    
    Input: "([)]"
    Output: false
    
    Input: "{[]}"
    Output: true

```

解决这个问题之前，我们先降低难度，思考一下， **如果只有一种括号` () ` ** ，应该如何判断字符串组成的括号是否合法呢？

假设字符串中只有圆括号，如果想让括号字符串合法，那么必须做到：

**每个右括号` ) ` 的左边必须有一个左括号 ` ( ` 和它匹配 ** 。

比如说字符串 ` ()))(( ` 中，中间的两个右括号 **左边** 就没有左括号匹配，所以这个括号组合是不合法的。

那么根据这个思路，我们可以写出算法：

```java
    bool isValid(string str) {
       // 待匹配的左括号数量
        int left = 0;
        for (int i = 0; i < str.size(); i++) {
            if (s[i] == '(') {
                left++;
            } else {
               // 遇到右括号
                left--;
            }
    
           // 右括号太多
            if (left == -1)
                return false;
        }
       // 是否所有的左括号都被匹配了
        return left == 0;
    }

```

如果只有圆括号，这样就能正确判断合法性。对于三种括号的情况，我一开始想模仿这个思路，定义三个变量 ` left1 ` ， ` left2 ` ，`left3 ` 分别处理每种括号，虽然要多写不少 if else 分支，但是似乎可以解决问题。

但实际上直接照搬这种思路是不行的，比如说只有一个括号的情况下 ` (()) ` 是合法的，但是多种括号的情况下， ` [(]) ` 显然是不合法的。

仅仅记录每种左括号出现的次数已经不能做出正确判断了，我们要加大存储的信息量，可以利用栈来模仿类似的思路。栈是一种先进后出的数据结构，处理括号问题的时候尤其有用。

我们这道题就用一个名为 ` left ` 的栈代替之前思路中的 ` left ` 变量，
**遇到左括号就入栈，遇到右括号就去栈中寻找最近的左括号，看是否匹配** ：

```java
    bool isValid(string str) {
        stack<char> left;
        for (char c : str) {
            if (c == '(' || c == '{' || c == '[')
                left.push(c);
            else {// 字符 c 是右括号
                if (!left.empty() && leftOf(c) == left.top())
                    left.pop();
                else
                   // 和最近的左括号不匹配
                    return false;
            }
        }
       // 是否所有的左括号都被匹配了
        return left.empty();
    }
    
    char leftOf(char c) {
        if (c == '}') return '{';
        if (c == ')') return '(';
        return '[';
    }

```

接下来讲另外两个常见的问题，如何通过最小的插入次数将括号变成合法的？

### 平衡括号串（一）

先来个简单的，力扣第 921 题「使括号有效的最少添加」：

给你输入一个字符串 ` s ` ，你可以在其中的任意位置插入左括号 ` ( ` 或者右括号 ` ) ` ，请问你最少需要几次插入才能使得 ` s`变成一个合法的括号串？

比如说输入 ` s = "())(" ` ，算法应该返回 2，因为我们至少需要插入两次把 ` s ` 变成 ` "(())()"`，这样每个左括号都有一个右括号匹配， ` s ` 是一个合法的括号串。

这其实和前文的判断括号合法性非常类似，我们直接看代码：

```java
    int minAddToMakeValid(string s) {
       // res 记录插入次数
        int res = 0;
       // need 变量记录右括号的需求量
        int need = 0;
    
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == '(') {
               // 对右括号的需求 + 1
                need++;
            }
            
            if (s[i] == ')') {
               // 对右括号的需求 - 1
                need--;
    
                if (need == -1) {
                    need = 0;
                   // 需插入一个左括号
                    res++;
                }
            }
        }
        
        return res + need;
    }

```

这段代码就是最终解法， **核心思路是以左括号为基准，通过维护对右括号的需求数` need ` ，来计算最小的插入次数 ** 。需要注意两个地方：

**1、当` need == -1 ` 的时候意味着什么 ** ？

因为只有遇到右括号 ` ) ` 的时候才会 ` need-- ` ， ` need == -1 ` 意味着右括号太多了，所以需要插入左括号。

比如说 ` s = "))" ` 这种情况，需要插入 2 个左括号，使得 ` s ` 变成 ` "()()" ` ，才是一个合法括号串。

**2、算法为什么返回` res + need ` ** ？

因为 ` res ` 记录的左括号的插入次数， ` need ` 记录了右括号的需求，当 for 循环结束后，若 ` need ` 不为 0，那么就意味着右括号还不够，需要插入。

比如说 ` s = "))(" ` 这种情况，插入 2 个左括号之后，还要再插入 1 个右括号，使得 ` s ` 变成 ` "()()()"`，才是一个合法括号串。

以上就是这道题的思路，接下来我们看一道进阶题目，如果左右括号不是 1:1 配对，会出现什么问题呢？

### 平衡括号串（二）

这是力扣第 1541 题「平衡括号字符串的最少插入次数」：

现在假设 1 个左括号需要匹配 2 个右括号才叫做合法的括号组合，那么给你输入一个括号串 ` s ` ，请问你如何计算使得 ` s`合法的最小插入次数呢？

**核心思路还是和刚才一样，通过一个` need ` 变量记录对右括号的需求数，根据 ` need ` 的变化来判断是否需要插入 ** 。

第一步，我们按照刚才的思路正确维护 ` need ` 变量：

```java
    int minInsertions(string s) {
       // need 记录需右括号的需求量
        int res = 0, need = 0;
        
        for (int i = 0; i < s.size(); i++) {
           // 一个左括号对应两个右括号
            if (s[i] == '(') {
                need += 2;
            }
            
            if (s[i] == ')') {
                need--;
            }
        }
        
        return res + need;
    }

```

现在想一想，当 ` need ` 为什么值的时候，我们可以确定需要进行插入？

**首先，类似第一题，当` need == -1 ` 时，意味着我们遇到一个多余的右括号，显然需要插入一个左括号 ** 。

比如说当 ` s = ")" ` ，我们肯定需要插入一个左括号让 ` s = "()" ` ，但是由于一个左括号需要两个右括号，所以对右括号的需求量变为 1：

```java
    if (s[i] == ')') {
        need--;
       // 说明右括号太多了
        if (need == -1) {
           // 需要插入一个左括号
            res++;
           // 同时，对右括号的需求变为 1
            need = 1;
        }
    }

```

**另外，当遇到左括号时，若对右括号的需求量为奇数，需要插入 1 个右括号**
。因为一个左括号需要两个右括号嘛，右括号的需求必须是偶数，这一点也是本题的难点。

所以遇到左括号时要做如下判断：

```java
    if (s[i] == '(') {
        need += 2;
        if (need % 2 == 1) {
           // 插入一个右括号
            res++;
           // 对右括号的需求减一
            need--;
        }
    }

```

综上，我们可以写出正确的代码：

```java
    int minInsertions(string s) {
        int res = 0, need = 0;
    
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == '(') {
                need += 2;
                if (need % 2 == 1) {
                    res++;
                    need--;
                }
            }
            
            if (s[i] == ')') {
                need--;
                if (need == -1) {
                    res++;
                    need = 1;
                }
            }
        }
        
        return res + need;
    }

```

综上，三道括号相关的问题就解决了，其实我们前文 [ 合法括号生成算法 ](https://labuladong.gitee.io/algo/4/28/109/)
也是括号相关的问题，但是使用的回溯算法技巧，和本文的几道题差别还是蛮大的，有兴趣的读者可以去看看。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


 ## 如何判定完美矩形
 读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 391. 完美矩形（困难） ](https://leetcode-cn.com/problems/perfect-rectangle/)

**———–**

今天讲一道非常有意思，而且比较有难度的题目。

我们知道一个矩形有四个顶点，但是只要两个顶点的坐标就可以确定一个矩形了（比如左下角和右上角两个顶点坐标）。

今天来看看力扣第 391 题「完美矩形」，题目会给我们输入一个数组 ` rectangles ` ，里面装着若干四元组 ` (x1,y1,x2,y2)`，每个四元组就是记录一个矩形的左下角和右上角坐标。

也就是说，输入的 ` rectangles ` 数组实际上就是很多小矩形，题目要求我们输出一个布尔值，判断这些小矩形能否构成一个「完美矩形」。函数签名如下：

```java
    def isRectangleCover(rectangles: List[List[int]]) -> bool

```

**所谓「完美矩形」，就是说` rectangles ` 中的小矩形拼成图形必须是一个大矩形，且大矩形中不能有重叠和空缺 ** 。

比如说题目给我们举了几个例子：

![](https://labuladong.gitee.io/algo/images/%e5%ae%8c%e7%be%8e%e7%9f%a9%e5%bd%a2/example1.png)
![](https://labuladong.gitee.io/algo/images/%e5%ae%8c%e7%be%8e%e7%9f%a9%e5%bd%a2/example2.png)
![](https://labuladong.gitee.io/algo/images/%e5%ae%8c%e7%be%8e%e7%9f%a9%e5%bd%a2/example3.png)

这个题目难度是 Hard，如果没有做过类似的题目，还真做不出来。

常规的思路，起码要把最终形成的图形表示出来吧，而且你要有方法去判断两个矩形是否有重叠，是否有空隙，虽然可以做到，不过感觉异常复杂。

**其实，想判断最终形成的图形是否是完美矩形，需要从「面积」和「顶点」两个角度来处理** 。

先说说什么叫从「面积」的角度。

` rectangles ` 数组中每个元素都是一个四元组 ` (x1, y1, x2, y2) ` ，表示一个小矩形的左下角顶点坐标和右上角顶点坐标。

那么假设这些小矩形最终形成了一个「完美矩形」，你会不会求这个完美矩形的左下角顶点坐标 ` (X1, Y1) ` 和右上角顶点的坐标 ` (X2, Y2)`？

这个很简单吧，左下角顶点 ` (X1, Y1) ` 就是 ` rectangles ` 中所有小矩形中最靠左下角的那个小矩形的左下角顶点；右上角顶点`(X2, Y2) ` 就是所有小矩形中最靠右上角的那个小矩形的右上角顶点。

注意我们用小写字母表示小矩形的坐标，大写字母表示最终形成的完美矩形的坐标，可以这样写代码：

```java
     左下角顶点，初始化为正无穷，以便记录最小值
    X1, Y1 = float('inf'), float('inf')
     右上角顶点，初始化为负无穷，以便记录最大值
    X2, Y2 = -float('inf'), -float('inf')
    
    for x1, y1, x2, y2 in rectangles:
         取小矩形左下角顶点的最小值
        X1, Y1 = min(X1, x1), min(Y1, y1)
         取小矩形右上角顶点的最大值
        X2, Y2 = max(X2, x2), max(Y2, y2)

```

这样就能求出完美矩形的左下角顶点坐标 ` (X1, Y1) ` 和右上角顶点的坐标 ` (X2, Y2) ` 了。

**计算出的` X1,Y1,X2,Y2 ` 坐标是完美矩形的「理论坐标」 **
，如果所有小矩形的面积之和不等于这个完美矩形的理论面积，那么说明最终形成的图形肯定存在空缺或者重叠，肯定不是完美矩形。

代码可以进一步：

```java
    def isRectangleCover(rectangles: List[List[int]]) -> bool:
        X1, Y1 = float('inf'), float('inf')
        X2, Y2 = -float('inf'), -float('inf')
         记录所有小矩形的面积之和
        actual_area = 0
        for x1, y1, x2, y2 in rectangles:
             计算完美矩形的理论坐标
            X1, Y1 = min(X1, x1), min(Y1, y1)
            X2, Y2 = max(X2, x2), max(Y2, y2)
             累加所有小矩形的面积
            actual_area += (x2 - x1) * (y2 - y1)
    
         计算完美矩形的理论面积
        expected_area = (X2 - X1) * (Y2 - Y1)
         面积应该相同
        if actual_area != expected_area:
            return False
    
        return True

```

这样，「面积」这个维度就完成了，思路其实不难，无非就是假设最终形成的图形是个完美矩形，然后比较面积是否相等，如果不相等的话说明最终形成的图形一定存在空缺或者重叠部分，不是完美矩形。

但是反过来说，如果面积相同，是否可以证明最终形成的图形是完美矩形，一定不存在空缺或者重叠？

肯定是不行的，举个很简单的例子，你假想一个完美矩形，然后我在它中间挖掉一个小矩形，把这个小矩形向下平移一个单位。这样小矩形的面积之和没变，但是原来的完美矩形中就空缺了一部分，也重叠了一部分，已经不是完美矩形了。

**综上，即便面积相同，并不能完全保证不存在空缺或者重叠，所以我们需要从「顶点」的维度来辅助判断** 。

记得小学的时候有一道智力题，给你一个矩形，切一刀，剩下的图形有几个顶点？答案是，如果沿着对角线切，就剩 3 个顶点；如果横着或者竖着切，剩 4 个顶点；如果只切掉一个小角，那么会出现 5 个顶点。

回到这道题，我们接下来的分析也有那么一点智力题的味道。

**显然，完美矩形一定只有四个顶点** 。矩形嘛，按理说应该有四个顶点，如果存在空缺或者重叠的话，肯定不是四个顶点，比如说题目的这两个例子就有不止 4 个顶点：

![](https://labuladong.gitee.io/algo/images/%e5%ae%8c%e7%be%8e%e7%9f%a9%e5%bd%a2/1.png)

> PS：我也不知道应该用「顶点」还是「角」来形容，好像都不太准确，本文统一用「顶点」来形容，大家理解就好~

只要我们想办法计算 ` rectangles ` 中的小矩形最终形成的图形有几个顶点，就能判断最终的图形是不是一个完美矩形了。

那么顶点是如何形成的呢？我们倒是一眼就可以看出来顶点在哪里，问题是如何让计算机，让算法知道某一个点是不是顶点呢？这也是本题的难点所在。

看下图的四种情况：

![](https://labuladong.gitee.io/algo/images/%e5%ae%8c%e7%be%8e%e7%9f%a9%e5%bd%a2/2.jpeg)

图中画红点的地方，什么时候是顶点，什么时候不是顶点？显然，情况一和情况三的时候是顶点，而情况二和情况四的时候不是顶点。

**也就是说，当某一个点同时是 2 个或者 4 个小矩形的顶点时，该点最终不是顶点；当某一个点同时是 1 个或者 3 个小矩形的顶点时，该点最终是一个顶点** 。

注意，2 和 4 都是偶数，1 和 3 都是奇数，我们想计算最终形成的图形中有几个顶点，也就是要筛选出那些出现了奇数次的顶点，可以这样写代码：

```java
    def isRectangleCover(rectangles: List[List[int]]) -> bool:
        X1, Y1 = float('inf'), float('inf')
        X2, Y2 = -float('inf'), -float('inf')
    
        actual_area = 0
         哈希集合，记录最终图形的顶点
        points = set()
        for x1, y1, x2, y2 in rectangles:
            X1, Y1 = min(X1, x1), min(Y1, y1)
            X2, Y2 = max(X2, x2), max(Y2, y2)
    
            actual_area += (x2 - x1) * (y2 - y1)
             先算出小矩形每个点的坐标
            p1, p2 = (x1, y1), (x1, y2)
            p3, p4 = (x2, y1), (x2, y2)
             对于每个点，如果存在集合中，删除它；
             如果不存在集合中，添加它；
             在集合中剩下的点都是出现奇数次的点
            for p in [p1, p2, p3, p4]:
                if p in points: points.remove(p)
                else: points.add(p)
    
        expected_area = (X2 - X1) * (Y2 - Y1)
        if actual_area != expected_area:
            return False
    
        return True

```

这段代码中，我们用一个 ` points ` 集合记录 ` rectangles ` 中小矩形组成的最终图形的顶点坐标，关键逻辑在于如何向 ` points
` 中添加坐标：

**如果某一个顶点` p ` 存在于集合 ` points ` 中，则将它删除；如果不存在于集合 ` points ` 中，则将它插入 ** 。

这个简单的逻辑，让 ` points ` 集合最终只会留下那些出现了 1 次或者 3 次的顶点，那些出现了 2 次或者 4 次的顶点都被消掉了。

那么首先想到， ` points ` 集合中最后应该只有 4 个顶点对吧，如果 ` len(points) != 4`说明最终构成的图形肯定不是完美矩形。

但是如果 ` len(points) == 4 ` 是否能说明最终构成的图形肯定是完美矩形呢？也不行，因为题目并没有说 ` rectangles`中的小矩形不存在重复，比如下面这种情况：

![](https://labuladong.gitee.io/algo/images/%e5%ae%8c%e7%be%8e%e7%9f%a9%e5%bd%a2/3.jpeg)

下面两个矩形重复了，按照我们的算法逻辑，它们的顶点都被消掉了，最终是剩下了四个顶点；再看面积，完美矩形的理论坐标是图中红色的点，计算出的理论面积和实际面积也相同。但是显然这种情况不是题目要求完美矩形。

所以不仅要保证 ` len(points) == 4 ` ，而且要保证 ` points ` 中最终剩下的点坐标就是完美矩形的四个理论坐标，直接看代码吧：

```java
    def isRectangleCover(rectangles: List[List[int]]) -> bool:
        X1, Y1 = float('inf'), float('inf')
        X2, Y2 = -float('inf'), -float('inf')
        
        points = set()
        actual_area = 0
        for x1, y1, x2, y2 in rectangles:
             计算完美矩形的理论顶点坐标
            X1, Y1 = min(X1, x1), min(Y1, y1)
            X2, Y2 = max(X2, x2), max(Y2, y2)
             累加小矩形的面积
            actual_area += (x2 - x1) * (y2 - y1)
             记录最终形成的图形中的顶点
            p1, p2 = (x1, y1), (x1, y2)
            p3, p4 = (x2, y1), (x2, y2)
            for p in [p1, p2, p3, p4]:
                if p in points: points.remove(p)
                else:           points.add(p)
         判断面积是否相同
        expected_area = (X2 - X1) * (Y2 - Y1)
        if actual_area != expected_area:
            return False
         判断最终留下的顶点个数是否为 4
        if len(points) != 4:       return False
         判断留下的 4 个顶点是否是完美矩形的顶点
        if (X1, Y1) not in points: return False
        if (X1, Y2) not in points: return False
        if (X2, Y1) not in points: return False
        if (X2, Y2) not in points: return False
         面积和顶点都对应，说明矩形符合题意
        return True

```

这就是最终的解法代码，从「面积」和「顶点」两个维度来判断：

1、判断面积，通过完美矩形的理论坐标计算出一个理论面积，然后和 ` rectangles ` 中小矩形的实际面积和做对比。

2、判断顶点， ` points ` 集合中应该只剩下 4 个顶点且剩下的顶点必须都是完美矩形的理论顶点。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


 ## 如何调度考生的座位
 读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 855. 考场就座（中等） ](https://leetcode-cn.com/problems/exam-room)

**———–**

这是 LeetCode 第 855 题，有趣且具有一定技巧性。这种题目并不像动态规划这类算法拼智商，而是看你对常用数据结构的理解和写代码的水平，个人认为值得重视和学习。

另外说句题外话，很多读者都问，算法框架是如何总结出来的，其实框架反而是慢慢从细节里抠出来的。希望大家看了我们的文章之后，最好能抽时间把相关的问题亲自做一做，纸上得来终觉浅，绝知此事要躬行嘛。

先来描述一下题目：假设有一个考场，考场有一排共 ` N ` 个座位，索引分别是 ` [0..N-1] ` ，考生会 **陆续** 进入考场考试，并且可能在
**任何时候** 离开考场。

你作为考官，要安排考生们的座位，满足： **每当一个学生进入时，你需要最大化他和最近其他人的距离；如果有多个这样的座位，安排到他到索引最小的那个座位**
。这很符合实际情况对吧，

也就是请你实现下面这样一个类：

```java
    class ExamRoom {
       // 构造函数，传入座位总数 N
        public ExamRoom(int N);
       // 来了一名考生，返回你给他分配的座位
        public int seat();
       // 坐在 p 位置的考生离开了
       // 可以认为 p 位置一定坐有考生
        public void leave(int p);
    }

```

比方说考场有 5 个座位，分别是 ` [0..4] ` ：

第一名考生进入时（调用 ` seat() ` ），坐在任何位置都行，但是要给他安排索引最小的位置，也就是返回位置 0。

第二名学生进入时（再调用 ` seat() ` ），要和旁边的人距离最远，也就是返回位置 4。

第三名学生进入时，要和旁边的人距离最远，应该做到中间，也就是座位 2。

如果再进一名学生，他可以坐在座位 1 或者 3，取较小的索引 1。

以此类推。

刚才所说的情况，没有调用 ` leave ` 函数，不过读者肯定能够发现规律：

**如果将每两个相邻的考生看做线段的两端点，新安排考生就是找最长的线段，然后让该考生在中间把这个线段「二分」，中点就是给他分配的座位。` leave(p)
` 其实就是去除端点 ` p ` ，使得相邻两个线段合并为一个 ** 。

核心思路很简单对吧，所以这个问题实际上实在考察你对数据结构的理解。对于上述这个逻辑，你用什么数据结构来实现呢？

### 一、思路分析

根据上述思路，首先需要把坐在教室的学生抽象成线段，我们可以简单的用一个大小为 2 的数组表示。

另外，思路需要我们找到「最长」的线段，还需要去除线段，增加线段。

**但凡遇到在动态过程中取最值的要求，肯定要使用有序数据结构，我们常用的数据结构就是二叉堆和平衡二叉搜索树了**
。二叉堆实现的优先级队列取最值的时间复杂度是 O(logN)，但是只能删除最大值。平衡二叉树也可以取最值，也可以修改、删除任意一个值，而且时间复杂度都是 O(logN)。

综上，二叉堆不能满足 ` leave ` 操作，应该使用平衡二叉树。所以这里我们会用到 Java 的一种数据结构 ` TreeSet`，这是一种有序数据结构，底层由红黑树维护有序性。

这里顺便提一下，一说到集合（Set）或者映射（Map），有的读者可能就想当然的认为是哈希集合（HashSet）或者哈希表（HashMap），这样理解是有点问题的。

因为哈希集合/映射底层是由哈希函数和数组实现的，特性是遍历无固定顺序，但是操作效率高，时间复杂度为 O(1)。

而集合/映射还可以依赖其他底层数据结构，常见的就是红黑树（一种平衡二叉搜索树），特性是自动维护其中元素的顺序，操作效率是 O(logN)。这种一般称为「有序集合/映射」。

我们使用的 ` TreeSet ` 就是一个有序集合，目的就是为了保持线段长度的有序性，快速查找最大线段，快速删除和插入。

### 二、简化问题

首先，如果有多个可选座位，需要选择索引最小的座位对吧？ **我们先简化一下问题，暂时不管这个要求** ，实现上述思路。

这个问题还用到一个常用的编程技巧，就是使用一个「虚拟线段」让算法正确启动，这就和链表相关的算法需要「虚拟头结点」一个道理。

```java
   // 将端点 p 映射到以 p 为左端点的线段
    private Map<Integer, int[]> startMap;
   // 将端点 p 映射到以 p 为右端点的线段
    private Map<Integer, int[]> endMap;
   // 根据线段长度从小到大存放所有线段
    private TreeSet<int[]> pq;
    private int N;
    
    public ExamRoom(int N) {
        this.N = N;
        startMap = new HashMap<>();
        endMap = new HashMap<>();
        pq = new TreeSet<>((a, b) -> {
           // 算出两个线段的长度
            int distA = distance(a);
            int distB = distance(b);
           // 长度更长的更大，排后面
            return distA - distB;
        });
       // 在有序集合中先放一个虚拟线段
        addInterval(new int[] {-1, N});
    }
    
   /* 去除一个线段 */
    private void removeInterval(int[] intv) {
        pq.remove(intv);
        startMap.remove(intv[0]);
        endMap.remove(intv[1]);
    }
    
   /* 增加一个线段 */
    private void addInterval(int[] intv) {
        pq.add(intv);
        startMap.put(intv[0], intv);
        endMap.put(intv[1], intv);
    }
    
   /* 计算一个线段的长度 */
    private int distance(int[] intv) {
        return intv[1] - intv[0] - 1;
    }

```

「虚拟线段」其实就是为了将所有座位表示为一个线段：

![](https://labuladong.gitee.io/algo/images/%e5%ba%a7%e4%bd%8d%e8%b0%83%e5%ba%a6/1.jpg)

有了上述铺垫，主要 API ` seat ` 和 ` leave ` 就可以写了：

```java
    public int seat() {
       // 从有序集合拿出最长的线段
        int[] longest = pq.last();
        int x = longest[0];
        int y = longest[1];
        int seat;
        if (x == -1) {// 情况一
            seat = 0;
        } else if (y == N) {// 情况二
            seat = N - 1;
        } else {// 情况三
            seat = (y - x)/ 2 + x;
        }
       // 将最长的线段分成两段
        int[] left = new int[] {x, seat};
        int[] right = new int[] {seat, y};
        removeInterval(longest);
        addInterval(left);
        addInterval(right);
        return seat;
    }
    
    public void leave(int p) {
       // 将 p 左右的线段找出来
        int[] right = startMap.get(p);
        int[] left = endMap.get(p);
       // 合并两个线段成为一个线段
        int[] merged = new int[] {left[0], right[1]};
        removeInterval(left);
        removeInterval(right);
        addInterval(merged);
    }

```

![](https://labuladong.gitee.io/algo/images/%e5%ba%a7%e4%bd%8d%e8%b0%83%e5%ba%a6/2.jpg)

至此，算法就基本实现了，代码虽多，但思路很简单：找最长的线段，从中间分隔成两段，中点就是 ` seat() ` 的返回值；找 ` p`的左右线段，合并成一个线段，这就是 ` leave(p) ` 的逻辑。

### 三、进阶问题

但是，题目要求多个选择时选择索引最小的那个座位，我们刚才忽略了这个问题。比如下面这种情况会出错：

![](https://labuladong.gitee.io/algo/images/%e5%ba%a7%e4%bd%8d%e8%b0%83%e5%ba%a6/3.jpg)

现在有序集合里有线段 ` [0,4] ` 和 ` [4,9] ` ，那么最长线段 ` longest ` 就是后者，按照 ` seat ` 的逻辑，就会分割
` [4,9] ` ，也就是返回座位 6。但正确答案应该是座位 2，因为 2 和 6 都满足最大化相邻考生距离的条件，二者应该取较小的。

![](https://labuladong.gitee.io/algo/images/%e5%ba%a7%e4%bd%8d%e8%b0%83%e5%ba%a6/4.jpg)

**遇到题目的这种要求，解决方式就是修改有序数据结构的排序方式** 。具体到这个问题，就是修改 ` TreeMap ` 的比较函数逻辑：

```java
    pq = new TreeSet<>((a, b) -> {
        int distA = distance(a);
        int distB = distance(b);
       // 如果长度相同，就比较索引
        if (distA == distB)
            return b[0] - a[0];
        return distA - distB;
    });

```

除此之外，还要改变 ` distance ` 函数， **不能简单地让它计算一个线段两个端点间的长度，而是让它计算该线段中点和端点之间的长度** 。

```java
    private int distance(int[] intv) {
        int x = intv[0];
        int y = intv[1];
        if (x == -1) return y;
        if (y == N) return N - 1 - x;
       // 中点和端点之间的长度
        return (y - x)/ 2;
    }

```

![](https://labuladong.gitee.io/algo/images/%e5%ba%a7%e4%bd%8d%e8%b0%83%e5%ba%a6/5.jpg)

这样， ` [0,4] ` 和 ` [4,9] ` 的 ` distance`值就相等了，算法会比较二者的索引，取较小的线段进行分割。到这里，这道算法题目算是完全解决了。

### 四、最后总结

本文聊的这个问题其实并不算难，虽然看起来代码很多。核心问题就是考察有序数据结构的理解和使用，来梳理一下。

处理动态问题一般都会用到有序数据结构，比如平衡二叉搜索树和二叉堆，二者的时间复杂度差不多，但前者支持的操作更多。

既然平衡二叉搜索树这么好用，还用二叉堆干嘛呢？因为二叉堆底层就是数组，实现简单啊，详见旧文 [ 二叉堆详解 ](https://labuladong.gitee.io/algo/2/19/50/)
。你实现个红黑树试试？操作复杂，而且消耗的空间相对来说会多一些。具体问题，还是要选择恰当的数据结构来解决。

希望本文对大家有帮助。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**


 ## 二分查找高效判定子序列
 读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 392. 判断子序列（简单） ](https://leetcode-cn.com/problems/is-subsequence)

**———–**

二分查找本身不难理解，难在巧妙地运用二分查找技巧。

对于一个问题，你可能都很难想到它跟二分查找有关，比如前文 [ 最长递增子序列 ](https://labuladong.gitee.io/algo/3/23/74/)
就借助一个纸牌游戏衍生出二分查找解法。

今天再讲一道巧用二分查找的算法问题：如何判定字符串 ` s ` 是否是字符串 ` t ` 的子序列（可以假定 ` s ` 长度比较小，且 ` t`的长度非常大）。举两个例子：

s = “abc”, t = “ **a** h **b** gd **c** ”, return true.

s = “axc”, t = “ahbgdc”, return false.

题目很容易理解，而且看起来很简单，但很难想到这个问题跟二分查找有关吧？

### 一、问题分析

首先，一个很简单的解法是这样的：

```java
    boolean isSubsequence(String s, String t) {
        int i = 0, j = 0;
        while (i < s.length() && j < t.length()) {
            if (s.charAt(i) == t.charAt(j)) {
                i++;
            }
            j++;
        }
        return i == s.length();
    }

```

其思路也非常简单，利用双指针 ` i, j ` 分别指向 ` s, t ` ，一边前进一边匹配子序列：

![](https://labuladong.gitee.io/algo/images/%E5%AD%90%E5%BA%8F%E5%88%97/1.gif)

读者也许会问，这不就是最优解法了吗，时间复杂度只需 O(N)，N 为 ` t ` 的长度。

是的，如果仅仅是这个问题，这个解法就够好了， **不过这个问题还有 follow up** ：

如果给你一系列字符串 ` s1,s2,... ` 和字符串 ` t ` ，你需要判定每个串 ` s ` 是否是 ` t ` 的子序列（可以假定 ` s`较短， ` t ` 很长）。

```java
    boolean[] isSubsequence(String[] sn, String t);

```

你也许会问，这不是很简单吗，还是刚才的逻辑，加个 for 循环不就行了？

可以，但是此解法处理每个 ` s ` 时间复杂度仍然是 O(N)，而如果巧妙运用二分查找，可以将时间复杂度降低，大约是 O(MlogN)。由于 N 相对 M 大很多，所以后者效率会更高。

### 二、二分思路

二分思路主要是对 ` t ` 进行预处理，用一个字典 ` index ` 将每个字符出现的索引位置按顺序存储下来：

```java
    int m = s.length(), n = t.length();
    ArrayList<Integer>[] index = new ArrayList[256];
   // 先记下 t 中每个字符出现的位置
    for (int i = 0; i < n; i++) {
        char c = t.charAt(i);
        if (index[c] == null) 
            index[c] = new ArrayList<>();
        index[c].add(i);
    }

```

![](https://labuladong.gitee.io/algo/images/%E5%AD%90%E5%BA%8F%E5%88%97/2.jpg)

比如对于这个情况，匹配了 “ab”，应该匹配 “c” 了：

![](https://labuladong.gitee.io/algo/images/%E5%AD%90%E5%BA%8F%E5%88%97/1.jpg)

按照之前的解法，我们需要 ` j ` 线性前进扫描字符 “c”，但借助 ` index ` 中记录的信息， **可以二分搜索` index[c] ` 中比 j 大的那个索引 ** ，在上图的例子中，就是在 ` [0,2,6] ` 中搜索比
4 大的那个索引：

![](https://labuladong.gitee.io/algo/images/%E5%AD%90%E5%BA%8F%E5%88%97/3.jpg)

这样就可以直接得到下一个 “c” 的索引。现在的问题就是，如何用二分查找计算那个恰好比 4 大的索引呢？答案是，寻找左侧边界的二分搜索就可以做到。

### 三、再谈二分查找

在前文 [ 二分查找详解 ](https://labuladong.gitee.io/algo/2/20/57/) 中，详解了如何正确写出三种二分查找算法的细节。二分查找返回目标值 ` val`的索引，对于搜索 **左侧边界** 的二分查找，有一个特殊性质：

**当` val ` 不存在时，得到的索引恰好是比 ` val ` 大的最小元素索引 ** 。

什么意思呢，就是说如果在数组 ` [0,1,3,4] ` 中搜索元素 2，算法会返回索引 2，也就是元素 3 的位置，元素 3 是数组中大于 2 的最小元素。所以我们可以利用二分搜索避免线性扫描。

```java
   // 查找左侧边界的二分查找
    int left_bound(ArrayList<Integer> arr, int tar) {
        int lo = 0, hi = arr.size();
        while (lo < hi) {
            int mid = lo + (hi - lo)/ 2;
            if (tar > arr.get(mid)) {
                lo = mid + 1;
            } else {
                hi = mid;
            } 
        }
        return lo;
    }

```

以上就是搜索左侧边界的二分查找，等会儿会用到，其中的细节可以参见前文《二分查找详解》，这里不再赘述。

### 四、代码实现

这里以单个字符串 ` s ` 为例，对于多个字符串 ` s ` ，可以把预处理部分抽出来。

```java
    boolean isSubsequence(String s, String t) {
        int m = s.length(), n = t.length();
       // 对 t 进行预处理
        ArrayList<Integer>[] index = new ArrayList[256];
        for (int i = 0; i < n; i++) {
            char c = t.charAt(i);
            if (index[c] == null) 
                index[c] = new ArrayList<>();
            index[c].add(i);
        }
        
       // 串 t 上的指针
        int j = 0;
       // 借助 index 查找 s[i]
        for (int i = 0; i < m; i++) {
            char c = s.charAt(i);
           // 整个 t 压根儿没有字符 c
            if (index[c] == null) return false;
            int pos = left_bound(index[c], j);
           // 二分搜索区间中没有找到字符 c
            if (pos == index[c].size()) return false;
           // 向前移动指针 j
            j = index[c].get(pos) + 1;
        }
        return true;
    }

```

算法执行的过程是这样的：

![](https://labuladong.gitee.io/algo/images/%E5%AD%90%E5%BA%8F%E5%88%97/2.gif)

可见借助二分查找，算法的效率是可以大幅提升的。