# 第二章、手把手刷动态规划

1、《算法秘籍》和《刷题笔记》两本 PDF 下载 [ 点这里](https://mp.weixin.qq.com/s/X-fE9sR4BLi6T9pn7xP4pg) 。

2、刷题插件下载及使用手册 [ 点这里 ](https://mp.weixin.qq.com/s/wIxflO1dvXzDlibhEcENcQ) 。

3、公众号菜单栏参与 [ 21 天算法挑战活动 ](https://mp.weixin.qq.com/s/eUG2OOzY3k_ZTz-CFvtv5Q) 。

# 动态规划基本技巧



## 动态规划解题核心框架

读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 509. 斐波那契数（简单） ](https://leetcode-cn.com/problems/fibonacci-number)

[ 322. 零钱兑换（中等） ](https://leetcode-cn.com/problems/coin-change)

**———–**

本文有视频版： [ 动态规划框架套路详解 ](https://www.bilibili.com/video/BV1XV411Y7oE)

这篇文章是我们公众号半年前一篇 200 多赞赏的成名之作 [ 动态规划详解](https://mp.weixin.qq.com/s/1V3aHVonWBEXlNUvK3S28w)
的进阶版。由于账号迁移的原因，旧文无法被搜索到，所以我润色了本文，并添加了更多干货内容，希望本文成为解决动态规划的一部「指导方针」。

动态规划问题（Dynamic Programming）应该是很多读者头疼的，不过这类问题也是最具有技巧性，最有意思的。本书使用了整整一个章节专门来写这个算法，动态规划的重要性也可见一斑。

本文解决几个问题：

动态规划是什么？解决动态规划问题有什么技巧？如何学习动态规划？

刷题刷多了就会发现，算法技巧就那几个套路， **我们后续的动态规划系列章节，都在使用本文的解题框架思维**
，如果你心里有数，就会轻松很多。所以本文放在第一章，来扒一扒动态规划的裤子，形成一套解决这类问题的思维框架，希望能够成为解决动态规划问题的一部指导方针。本文就来讲解该算法的基本套路框架，下面上干货。

**首先，动态规划问题的一般形式就是求最值** 。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求 **最长**
递增子序列呀， **最小** 编辑距离呀等等。

既然是要求最值，核心问题是什么呢？ **求解动态规划的核心问题是穷举** 。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值呗。

动态规划这么简单，就是穷举就完事了？我看到的动态规划问题都很难啊！

首先，动态规划的穷举有点特别，因为这类问题 **存在「重叠子问题」** ，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。

而且，动态规划问题一定会 **具备「最优子结构」** ，才能通过子问题的最值得到原问题的最值。

另外，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出 **正确的「状态转移方程」**，才能正确地穷举。

以上提到的重叠子问题、最优子结构、状态转移方程就是动态规划三要素。具体什么意思等会会举例详解，但是在实际的算法问题中， **写出状态转移方程是最困难的**，这也就是为什么很多朋友觉得动态规划问题困难的原因，我来提供我研究出来的一个思维框架，辅助你思考状态转移方程：

**明确 base case - > 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义 ** 。

按上面的套路走，最后的结果就可以套这个框架：

```java
    ## 初始化 base case
    dp[0][0][...] = base
    ## 进行状态转移
    for 状态1 in 状态1的所有取值：
        for 状态2 in 状态2的所有取值：
            for ...
                dp[状态1][状态2][...] = 求最值(选择1，选择2...)

```

下面通过斐波那契数列问题和凑零钱问题来详解动态规划的基本原理。前者主要是让你明白什么是重叠子问题（斐波那契数列没有求最值，所以严格来说不是动态规划问题），后者主要举集中于如何列出状态转移方程。

### 一、斐波那契数列

请读者不要嫌弃这个例子简单， **只有简单的例子才能让你把精力充分集中在算法背后的通用思想和技巧上，而不会被那些隐晦的细节问题搞的莫名其妙**。想要困难的例子，历史文章里有的是。

**1、暴力递归**

斐波那契数列的数学形式就是递归的，写成代码就是这样：

```java
    int fib(int N) {
        if (N == 1 || N == 2) return 1;
        return fib(N - 1) + fib(N - 2);
    }

```

这个不用多说了，学校老师讲递归的时候似乎都是拿这个举例。我们也知道这样写代码虽然简洁易懂，但是十分低效，低效在哪里？假设 n = 20，请画出递归树：

![](https://labuladong.gitee.io/algo/images/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%e8%af%a6%e8%a7%a3%e8%bf%9b%e9%98%b6/1.jpg)

> PS：但凡遇到需要递归的问题，最好都画出递归树，这对你分析算法的复杂度，寻找算法低效的原因都有巨大帮助。

这个递归树怎么理解？就是说想要计算原问题 ` f(20) ` ，我就得先计算出子问题 ` f(19) ` 和 ` f(18) ` ，然后要计算 ` f(19) ` ，我就要先算出子问题 ` f(18) ` 和 ` f(17) ` ，以此类推。最后遇到 ` f(1) ` 或者 ` f(2) `的时候，结果已知，就能直接返回结果，递归树不再向下生长了。

**递归算法的时间复杂度怎么计算？就是用子问题个数乘以解决一个子问题需要的时间** 。

首先计算子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 O(2^n)。

然后计算解决一个子问题的时间，在本算法中，没有循环，只有 ` f(n - 1) + f(n - 2) ` 一个加法操作，时间为 O(1)。

所以，这个算法的时间复杂度为二者相乘，即 O(2^n)，指数级别，爆炸。

观察递归树，很明显发现了算法低效的原因：存在大量重复计算，比如 ` f(18) ` 被计算了两次，而且你可以看到，以 ` f(18) `为根的这个递归树体量巨大，多算一遍，会耗费巨大的时间。更何况，还不止 ` f(18) ` 这一个节点被重复计算，所以这个算法及其低效。

这就是动态规划问题的第一个性质： **重叠子问题** 。下面，我们想办法解决这个问题。

**2、带备忘录的递归解法**

明确了问题，其实就已经把问题解决了一半。即然耗时的原因是重复计算，那么我们可以造一个「备忘录」，每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。

一般使用一个数组充当这个「备忘录」，当然你也可以使用哈希表（字典），思想都是一样的。

```java
    int fib(int N) {
        // 备忘录全初始化为 0
        int[] memo = new int[N + 1];
        // 进行带备忘录的递归
        return helper(memo, N);
    }
    
    int helper(int[] memo, int n) {
        // base case
        if (n == 0 || n == 1) return n;
        // 已经计算过，不用再计算了
        if (memo[n] != 0) return memo[n];
        memo[n] = helper(memo, n - 1) + helper(memo, n - 2);
        return memo[n];
    }

```

现在，画出递归树，你就知道「备忘录」到底做了什么。

![](https://labuladong.gitee.io/algo/images/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%e8%af%a6%e8%a7%a3%e8%bf%9b%e9%98%b6/2.jpg)

实际上，带「备忘录」的递归算法，把一棵存在巨量冗余的递归树通过「剪枝」，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数。

![](https://labuladong.gitee.io/algo/images/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%e8%af%a6%e8%a7%a3%e8%bf%9b%e9%98%b6/3.jpg)

**递归算法的时间复杂度怎么计算？就是用子问题个数乘以解决一个子问题需要的时间** 。

子问题个数，即图中节点的总数，由于本算法不存在冗余计算，子问题就是 ` f(1) ` , ` f(2) ` , ` f(3) ` … ` f(20) `，数量和输入规模 n = 20 成正比，所以子问题个数为 O(n)。

解决一个子问题的时间，同上，没有什么循环，时间为 O(1)。

所以，本算法的时间复杂度是 O(n)。比起暴力算法，是降维打击。

至此，带备忘录的递归解法的效率已经和迭代的动态规划解法一样了。实际上，这种解法和迭代的动态规划已经差不多了，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」。

啥叫「自顶向下」？注意我们刚才画的递归树（或者说图），是从上向下延伸，都是从一个规模较大的原问题比如说 ` f(20) ` ，向下逐渐分解规模，直到 `f(1) ` 和 ` f(2) ` 这两个 base case，然后逐层返回答案，这就叫「自顶向下」。

啥叫「自底向上」？反过来，我们直接从最底下，最简单，问题规模最小的 ` f(1) ` 和 ` f(2) ` 开始往上推，直到推到我们想要的答案 `f(20) ` ，这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。

**3、dp 数组的迭代解法**

有了上一步「备忘录」的启发，我们可以把这个「备忘录」独立出来成为一张表，就叫做 DP table 吧，在这张表上完成「自底向上」的推算岂不美哉！

```java
    int fib(int N) {
        if (N == 0) return 0;
        int[] dp = new int[N + 1];
        // base case
        dp[0] = 0; dp[1] = 1;
        // 状态转移
        for (int i = 2; i <= N; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
    
        return dp[N];
    }

```

![](https://labuladong.gitee.io/algo/images/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%e8%af%a6%e8%a7%a3%e8%bf%9b%e9%98%b6/4.jpg)

画个图就很好理解了，而且你发现这个 DP table 特别像之前那个「剪枝」后的结果，只是反过来算而已。实际上，带备忘录的递归解法中的「备忘录」，最终完成后就是这个 DP
table，所以说这两种解法其实是差不多的，大部分情况下，效率也基本相同。

这里，引出「状态转移方程」这个名词，实际上就是描述问题结构的数学形式：

![](https://labuladong.gitee.io/algo/images/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%e8%af%a6%e8%a7%a3%e8%bf%9b%e9%98%b6/fib.png)

为啥叫「状态转移方程」？其实就是为了听起来高端。你把 ` f(n) ` 想做一个状态 ` n ` ，这个状态 ` n ` 是由状态 ` n - 1 `和状态 ` n - 2 ` 相加转移而来，这就叫状态转移，仅此而已。

你会发现，上面的几种解法中的所有操作，例如 ` return f(n - 1) + f(n - 2) ` ， ` dp[i] = dp[i - 1] + dp[i - 2] ` ，以及对备忘录或 DP table
的初始化操作，都是围绕这个方程式的不同表现形式。可见列出「状态转移方程」的重要性，它是解决问题的核心。而且很容易发现，其实状态转移方程直接代表着暴力解法。

**千万不要看不起暴力解，动态规划问题最困难的就是写出这个暴力解，即状态转移方程** 。只要写出暴力解，优化方法无非是用备忘录或者 DP table，再无奥妙可言。

这个例子的最后，讲一个细节优化。细心的读者会发现，根据斐波那契数列的状态转移方程，当前状态只和之前的两个状态有关，其实并不需要那么长的一个 DP table
来存储所有的状态，只要想办法存储之前的两个状态就行了。所以，可以进一步优化，把空间复杂度降为 O(1)：

```java
    int fib(int n) {
        if (n < 1) return 0;
        if (n == 2 || n == 1) 
            return 1;
        int prev = 1, curr = 1;
        for (int i = 3; i <= n; i++) {
            int sum = prev + curr;
            prev = curr;
            curr = sum;
        }
        return curr;
    }

```

这个技巧就是所谓的「 **状态压缩** 」，如果我们发现每次状态转移只需要 DP table 中的一部分，那么可以尝试用状态压缩来缩小 DP table 的大小，只记录必要的数据，上述例子就相当于把DP table 的大小从 ` n `缩小到 2。后续的动态规划章节中我们还会看到这样的例子，一般来说是把一个二维的 DP table 压缩成一维，即把空间复杂度从 O(n^2) 压缩到 O(n)。

有人会问，动态规划的另一个重要特性「最优子结构」，怎么没有涉及？下面会涉及。斐波那契数列的例子严格来说不算动态规划，因为没有涉及求最值，以上旨在说明重叠子问题的消除方法，演示得到最优解法逐步求精的过程。下面，看第二个例子，凑零钱问题。

### 二、凑零钱问题

先看下题目：给你 ` k ` 种面值的硬币，面值分别为 ` c1, c2 ... ck ` ，每种硬币的数量无限，再给一个总金额 ` amount `，问你 **最少** 需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。算法的函数签名如下：

```java
    // coins 中是可选硬币面值，amount 是目标金额
    int coinChange(int[] coins, int amount);

```

比如说 ` k = 3 ` ，面值分别为 1，2，5，总金额 ` amount = 11 ` 。那么最少需要 3 枚硬币凑出，即 11 = 5 + 5 + 1。

你认为计算机应该如何解决这个问题？显然，就是把所有可能的凑硬币方法都穷举出来，然后找找看最少需要多少枚硬币。

**1、暴力递归**

首先，这个问题是动态规划问题，因为它具有「最优子结构」的。 **要符合「最优子结构」，子问题间必须互相独立**
。啥叫相互独立？你肯定不想看数学证明，我用一个直观的例子来讲解。

比如说，假设你考试，每门科目的成绩都是互相独立的。你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高…… 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高……
当然，最终就是你每门课都是满分，这就是最高的总成绩。

得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，“每门科目考到最高”这些子问题是互相独立，互不干扰的。

但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，数学分数高，语文分数就会降低，反之亦然。这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为子问题并不独立，语文数学成绩无法同时最优，所以最优子结构被破坏。

回到凑零钱问题，为什么说它符合最优子结构呢？比如你想求 ` amount = 11 ` 时的最少硬币数（原问题），如果你知道凑出 ` amount = 10
` 的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 1 的硬币）就是原问题的答案。因为硬币的数量是没有限制的，所以子问题之间没有相互制，是互相独立的。

> PS：关于最优子结构的问题，后文 [ 动态规划答疑篇 ](https://labuladong.gitee.io/algo/3/22/68/) 还会再举例探讨。

那么，既然知道了这是个动态规划问题，就要思考 **如何列出正确的状态转移方程** ？

1、 **确定 base case** ，这个很简单，显然目标金额 ` amount ` 为 0 时算法返回 0，因为不需要任何硬币就已经凑出目标金额了。

2、 **确定「状态」，也就是原问题和子问题中会变化的变量** 。由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的「状态」就是目标金额 ` amount ` 。

3、 **确定「选择」，也就是导致「状态」产生变化的行为**
。目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的「选择」。

4、 **明确` dp ` 函数/数组的定义 ** 。我们这里讲的是自顶向下的解法，所以会有一个递归的 ` dp `函数，一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是题目要求我们计算的量。就本题来说，状态只有一个，即「目标金额」，题目要求我们计算凑出目标金额所需的最少硬币数量。所以我们可以这样定义
` dp ` 函数：

` dp(n) ` 的定义：输入一个目标金额 ` n ` ，返回凑出目标金额 ` n ` 的最少硬币数量。

搞清楚上面这几个关键点，解法的伪码就可以写出来了：

```java
    // 伪码框架
    int coinChange(int[] coins, int amount) {
        // 题目要求的最终结果是 dp(amount)
        return dp(coins, amount)
    }
    
    // 定义：要凑出金额 n，至少要 dp(coins, n) 个硬币
    int dp(int[] coins, int n) {
        // 做选择，选择需要硬币最少的那个结果
        for (int coin : coins) {
            res = min(res, 1 + dp(n - coin))
        }
        return res
    }

```

根据伪码，我们加上 base case 即可得到最终的答案。显然目标金额为 0 时，所需硬币数量为 0；当目标金额小于 0 时，无解，返回 -1：

```java
    int coinChange(int[] coins, int amount) {
        // 题目要求的最终结果是 dp(amount)
        return dp(coins, amount)
    }
    
    int dp(int[] coins, int amount) {
        // base case
        if (amount == 0) return 0;
        if (amount < 0) return -1;
    
        int res = Integer.MAX_VALUE;
        for (int coin : coins) {
            // 计算子问题的结果
            int subProblem = dp(coins, amount - coin);
            // 子问题无解则跳过
            if (subProblem == -1) continue;
            // 在子问题中选择最优解，然后加一
            res = Math.min(res, subProblem + 1);
        }
    
        return res == Integer.MAX_VALUE ? -1 : res;
    }

```

> PS：这里 ` coinChange ` 和 ` dp ` 函数的签名完全一样，所以理论上不需要额外写一个 ` dp `> 函数。但为了后文讲解方便，这里还是另写一个 ` dp ` 函数来实现主要逻辑。

至此，状态转移方程其实已经完成了，以上算法已经是暴力解法了，以上代码的数学形式就是状态转移方程：

![](https://labuladong.gitee.io/algo/images/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%e8%af%a6%e8%a7%a3%e8%bf%9b%e9%98%b6/coin.png)

至此，这个问题其实就解决了，只不过需要消除一下重叠子问题，比如 ` amount = 11, coins = {1,2,5} ` 时画出递归树看看：

![](https://labuladong.gitee.io/algo/images/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%e8%af%a6%e8%a7%a3%e8%bf%9b%e9%98%b6/5.jpg)

**递归算法的时间复杂度分析：子问题总数 x 每个子问题的时间** 。

子问题总数为递归树节点个数，这个比较难看出来，是 O(n^k)，总之是指数级别的。每个子问题中含有一个 for 循环，复杂度为 O(k)。所以总时间复杂度为 O(k * n^k)，指数级别。

**2、带备忘录的递归**

类似之前斐波那契数列的例子，只需要稍加修改，就可以通过备忘录消除子问题：

```java
    int[] memo;
    
    int coinChange(int[] coins, int amount) {
        memo = new int[amount + 1];
        // dp 数组全都初始化为特殊值
        Arrays.fill(memo, -666);
    
        return dp(coins, amount);
    }
    
    int dp(int[] coins, int amount) {
        if (amount == 0) return 0;
        if (amount < 0) return -1;
        // 查备忘录，防止重复计算
        if (memo[amount] != -666)
            return memo[amount];
    
        int res = Integer.MAX_VALUE;
        for (int coin : coins) {
            // 计算子问题的结果
            int subProblem = dp(coins, amount - coin);
            // 子问题无解则跳过
            if (subProblem == -1) continue;
            // 在子问题中选择最优解，然后加一
            res = Math.min(res, subProblem + 1);
        }
        // 把计算结果存入备忘录
        memo[amount] = (res == Integer.MAX_VALUE) ? -1 : res;
        return memo[amount];
    }

```

不画图了，很显然「备忘录」大大减小了子问题数目，完全消除了子问题的冗余，所以子问题总数不会超过金额数 ` n ` ，即子问题数目为 O(n)。处理一个子问题的时间不变，仍是 O(k)，所以总的时间复杂度是 O(kn)。

**3、dp 数组的迭代解法**

当然，我们也可以自底向上使用 dp table 来消除重叠子问题，关于「状态」「选择」和 base case 与之前没有区别， ` dp `数组的定义和刚才 ` dp ` 函数类似，也是把「状态」，也就是目标金额作为变量。不过 ` dp ` 函数体现在函数参数，而 ` dp `数组体现在数组索引：

**` dp ` 数组的定义：当目标金额为 ` i ` 时，至少需要 ` dp[i] ` 枚硬币凑出 ** 。

根据我们文章开头给出的动态规划代码框架可以写出如下解法：

```java
    int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        // 数组大小为 amount + 1，初始值也为 amount + 1
        Arrays.fill(dp, amount + 1);
    
        // base case
        dp[0] = 0;
        // 外层 for 循环在遍历所有状态的所有取值
        for (int i = 0; i < dp.length; i++) {
            // 内层 for 循环在求所有选择的最小值
            for (int coin : coins) {
                // 子问题无解，跳过
                if (i - coin < 0) {
                    continue;
                }
                dp[i] = Math.min(dp[i], 1 + dp[i - coin]);
            }
        }
        return (dp[amount] == amount + 1) ? -1 : dp[amount];
    }

```

![](https://labuladong.gitee.io/algo/images/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%e8%af%a6%e8%a7%a3%e8%bf%9b%e9%98%b6/6.jpg)

> PS：为啥 ` dp ` 数组初始化为 ` amount + 1 ` 呢，因为凑成 ` amount ` 金额的硬币数最多只可能等于 ` amount
> ` （全用 1 元面值的硬币），所以初始化为 ` amount + 1 ` 就相当于初始化为正无穷，便于后续取最小值。为啥不直接初始化为 int
> 型的最大值 ` Integer.MAX_VALUE ` 呢？因为后面有 ` dp[i - coin] + 1 ` ，这就会导致整型溢出。

### 三、最后总结

第一个斐波那契数列的问题，解释了如何通过「备忘录」或者「dp table」的方法来优化递归树，并且明确了这两种方法本质上是一样的，只是自顶向下和自底向上的不同而已。

第二个凑零钱的问题，展示了如何流程化确定「状态转移方程」，只要通过状态转移方程写出暴力递归解，剩下的也就是优化递归树，消除重叠子问题而已。

如果你不太了解动态规划，还能看到这里，真得给你鼓掌，相信你已经掌握了这个算法的设计技巧。

**计算机解决问题其实没有任何奇技淫巧，它唯一的解决办法就是穷举** ，穷举所有可能性。算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。

列出状态转移方程，就是在解决“如何穷举”的问题。之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。

备忘录、DP table 就是在追求“如何聪明地穷举”。用空间换时间的思路，是降低时间复杂度的不二法门，除此之外，试问，还能玩出啥花活？

之后我们会有一章专门讲解动态规划问题，如果有任何问题都可以随时回来重读本文，希望读者在阅读每个题目和解法时，多往「状态」和「选择」上靠，才能对这套框架产生自己的理解，运用自如。

接下来可阅读：

* [ 动态规划设计：最长递增子序列 ](https://labuladong.gitee.io/algo/3/23/74/)

**＿＿＿＿＿＿＿＿＿＿＿＿＿**

## 动态规划设计：最长递增子序列
读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 300. 最长递增子序列（中等） ](https://leetcode-cn.com/problems/longest-increasing-
subsequence)

**———–**

也许有读者看了前文 [ 动态规划详解 ](https://labuladong.gitee.io/algo/3/22/66/) ，学会了动态规划的套路：找到了问题的「状态」，明确了 ` dp `数组/函数的含义，定义了 base case；但是不知道如何确定「选择」，也就是不到状态转移的关系，依然写不出动态规划解法，怎么办？

不要担心，动态规划的难点本来就在于寻找正确的状态转移方程，本文就借助经典的「最长递增子序列问题」来讲一讲设计动态规划的通用技巧： **数学归纳思想** 。

最长递增子序列（Longest Increasing Subsequence，简写 LIS）是非常经典的一个算法问题，比较容易想到的是动态规划解法，时间复杂度 O(N^2)
，我们借这个问题来由浅入深讲解如何找状态转移方程，如何写出动态规划解法。比较难想到的是利用二分查找，时间复杂度是 O(NlogN)，我们通过一种简单的纸牌游戏来辅助理解这种巧妙的解法。

先看一下题目，很容易理解：

![](https://labuladong.gitee.io/algo/images/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/title.png)

注意「子序列」和「子串」这两个名词的区别，子串一定是连续的，而子序列不一定是连续的。下面先来设计动态规划算法解决这个问题。

### 一、动态规划解法

动态规划的核心设计思想是数学归纳法。

相信大家对数学归纳法都不陌生，高中就学过，而且思路很简单。比如我们想证明一个数学结论，那么 **我们先假设这个结论在` k<n `时成立，然后根据这个假设，想办法推导证明出 ` k=n ` 的时候此结论也成立 ** 。如果能够证明出来，那么就说明这个结论对于 ` k `等于任何数都成立。

类似的，我们设计动态规划算法，不是需要一个 dp 数组吗？我们可以假设 ` dp[0...i-1] ` 都已经被算出来了，然后问自己：怎么通过这些结果算出
` dp[i] ` ？

直接拿最长递增子序列这个问题举例你就明白了。不过，首先要定义清楚 dp 数组的含义，即 ` dp[i] ` 的值到底代表着什么？

**我们的定义是这样的：` dp[i] ` 表示以 ` nums[i] ` 这个数结尾的最长递增子序列的长度 ** 。

> PS：为什么这样定义呢？这是解决子序列问题的一个套路，后文 [ 动态规划之子序列问题解题模板 ](https://labuladong.gitee.io/algo/3/23/78/)
> 总结了几种常见套路。你读完本章所有的动态规划问题，就会发现 ` dp ` 数组的定义方法也就那几种。

根据这个定义，我们就可以推出 base case： ` dp[i] ` 初始值为 1，因为以 ` nums[i] ` 结尾的最长递增子序列起码要包含它自己。

举两个例子：

![](https://labuladong.gitee.io/algo/images/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/1.jpeg)
![](https://labuladong.gitee.io/algo/images/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/2.jpeg)

算法演进的过程是这样的，：

![](https://labuladong.gitee.io/algo/images/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/gif1.gif)

根据这个定义，我们的最终结果（子序列的最大长度）应该是 dp 数组中的最大值。

```java
    int res = 0;
    for (int i = 0; i < dp.length; i++) {
        res = Math.max(res, dp[i]);
    }
    return res;

```

读者也许会问，刚才的算法演进过程中每个 ` dp[i] ` 的结果是我们肉眼看出来的，我们应该怎么设计算法逻辑来正确计算每个 ` dp[i] ` 呢？

这就是动态规划的重头戏了，要思考如何设计算法逻辑进行状态转移，才能正确运行呢？这里就可以使用数学归纳的思想：

**假设我们已经知道了` dp[0..4] ` 的所有结果，我们如何通过这些已知结果推出 ` dp[5] ` 呢 ** ？

![](https://labuladong.gitee.io/algo/images/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/3.jpeg)

根据刚才我们对 ` dp ` 数组的定义，现在想求 ` dp[5] ` 的值，也就是想求以 ` nums[5] ` 为结尾的最长递增子序列。

**` nums[5] = 3 ` ，既然是递增子序列，我们只要找到前面那些结尾比 3 小的子序列，然后把 3 接到最后，就可以形成一个新的递增子序列，而且这个新的子序列长度加一 ** 。

显然，可能形成很多种新的子序列，但是我们只选择最长的那一个，把最长子序列的长度作为 ` dp[5] ` 的值即可。

![](https://labuladong.gitee.io/algo/images/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/gif2.gif)

```java
    for (int j = 0; j < i; j++) {
        if (nums[i] > nums[j]) 
            dp[i] = Math.max(dp[i], dp[j] + 1);
    }

```

当 ` i = 5 ` 时，这段代码的逻辑就可以算出 ` dp[5] ` 。其实到这里，这道算法题我们就基本做完了。

读者也许会问，我们刚才只是算了 ` dp[5] ` 呀， ` dp[4] ` , ` dp[3] ` 这些怎么算呢？类似数学归纳法，你已经可以算出 `dp[5] ` 了，其他的就都可以算出来：

```java
    for (int i = 0; i < nums.length; i++) {
        for (int j = 0; j < i; j++) {
            if (nums[i] > nums[j]) 
                dp[i] = Math.max(dp[i], dp[j] + 1);
        }
    }

```

结合我们刚才说的 base case，下面我们看一下完整代码：

```java
    int lengthOfLIS(int[] nums) {
        int[] dp = new int[nums.length];
        // base case：dp 数组全都初始化为 1
        Arrays.fill(dp, 1);
        for (int i = 0; i < nums.length; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) 
                    dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
        
        int res = 0;
        for (int i = 0; i < dp.length; i++) {
            res = Math.max(res, dp[i]);
        }
        return res;
    }

```

至此，这道题就解决了，时间复杂度 O(N^2)。总结一下如何找到动态规划的状态转移关系：

1、明确 ` dp ` 数组的定义。这一步对于任何动态规划问题都很重要，如果不得当或者不够清晰，会阻碍之后的步骤。

2、根据 ` dp ` 数组的定义，运用数学归纳法的思想，假设 ` dp[0...i-1] ` 都已知，想办法求出 ` dp[i] `，一旦这一步完成，整个题目基本就解决了。

但如果无法完成这一步，很可能就是 ` dp ` 数组的定义不够恰当，需要重新定义 ` dp ` 数组的含义；或者可能是 ` dp `数组存储的信息还不够，不足以推出下一步的答案，需要把 ` dp ` 数组扩大成二维数组甚至三维数组。

### 二、二分查找解法

这个解法的时间复杂度为 O(NlogN)，但是说实话，正常人基本想不到这种解法（也许玩过某些纸牌游戏的人可以想出来）。所以大家了解一下就好，正常情况下能够给出动态规划解法就已经很不错了。

根据题目的意思，我都很难想象这个问题竟然能和二分查找扯上关系。其实最长递增子序列和一种叫做 patience game 的纸牌游戏有关，甚至有一种排序方法就叫做 patience sorting（耐心排序）。

为了简单起见，后文跳过所有数学证明，通过一个简化的例子来理解一下算法思路。

首先，给你一排扑克牌，我们像遍历数组那样从左到右一张一张处理这些扑克牌，最终要把这些牌分成若干堆。

![](https://labuladong.gitee.io/algo/images/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/poker1.jpeg)

**处理这些扑克牌要遵循以下规则** ：

只能把点数小的牌压到点数比它大的牌上；如果当前牌点数较大没有可以放置的堆，则新建一个堆，把这张牌放进去；如果当前牌有多个堆可供选择，则选择最左边的那一堆放置。

比如说上述的扑克牌最终会被分成这样 5 堆（我们认为纸牌 A 的牌面是最大的，纸牌 2 的牌面是最小的）。

![](https://labuladong.gitee.io/algo/images/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/poker2.jpeg)

为什么遇到多个可选择堆的时候要放到最左边的堆上呢？因为这样可以保证牌堆顶的牌有序（2, 4, 7, 8, Q），证明略。

![](https://labuladong.gitee.io/algo/images/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/poker3.jpeg)

按照上述规则执行，可以算出最长递增子序列，牌的堆数就是最长递增子序列的长度，证明略。

![](https://labuladong.gitee.io/algo/images/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/poker4.jpeg)

我们只要把处理扑克牌的过程编程写出来即可。每次处理一张扑克牌不是要找一个合适的牌堆顶来放吗，牌堆顶的牌不是 **有序**
吗，这就能用到二分查找了：用二分查找来搜索当前牌应放置的位置。

> PS：旧文 [ 二分查找算法详解 ](https://labuladong.gitee.io/algo/2/20/57/) 详细介绍了二分查找的细节及变体，这里就完美应用上了，如果没读过强烈建议阅读。

```java
    public int lengthOfLIS(int[] nums) {
        int[] top = new int[nums.length];
        // 牌堆数初始化为 0
        int piles = 0;
        for (int i = 0; i < nums.length; i++) {
            // 要处理的扑克牌
            int poker = nums[i];
    
            /***** 搜索左侧边界的二分查找 *****/
            int left = 0, right = piles;
            while (left < right) {
                int mid = (left + right) / 2;
                if (top[mid] > poker) {
                    right = mid;
                } else if (top[mid] < poker) {
                    left = mid + 1;
                } else {
                    right = mid;
                }
            }
            /*********************************/
            
            // 没找到合适的牌堆，新建一堆
            if (left == piles) piles++;
            // 把这张牌放到牌堆顶
            top[left] = poker;
        }
        // 牌堆数就是 LIS 长度
        return piles;
    }

```

至此，二分查找的解法也讲解完毕。

这个解法确实很难想到。首先涉及数学证明，谁能想到按照这些规则执行，就能得到最长递增子序列呢？其次还有二分查找的运用，要是对二分查找的细节不清楚，给了思路也很难写对。

所以，这个方法作为思维拓展好了。但动态规划的设计方法应该完全理解：假设之前的答案已知，利用数学归纳的思想正确进行状态的推演转移，最终得到答案。

接下来可阅读：

* [ 动态规划之最大子数组 ](https://labuladong.gitee.io/algo/3/23/76/)



## 动态规划答疑篇



**———–**

本文有视频版： [ 动态规划详解进阶 ](https://www.bilibili.com/video/BV1uv411W73P/)

这篇文章就给你讲明白两个问题：

1、到底什么才叫「最优子结构」，和动态规划什么关系。

2、为什么动态规划遍历 ` dp ` 数组的方式五花八门，有的正着遍历，有的倒着遍历，有的斜着遍历。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**

应合作方要求，本文不便在此发布，请扫码关注回复关键词「答疑」查看：

![](https://labuladong.gitee.io/algo/images/qrcode.jpg)

## base case 和备忘录的初始值怎么定？



读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 931. 下降路径最小和（中等） ](https://leetcode-cn.com/problems/minimum-falling-path-
sum/)

**———–**

之前我抽空看了以前文章的留言，很多读者对动态规划问题的 base case、备忘录初始值等问题存在疑问。

本文就专门讲一讲这类问题，顺便聊一聊怎么通过题目的蛛丝马迹揣测出题人的小心思，辅助我们解题。

看下力扣第 931 题「下降路径最小和」，输入为一个 ` n * n ` 的二维数组 ` matrix `，请你计算从第一行落到最后一行，经过的路径和最小为多少。

函数签名如下：

```java
    int minFallingPathSum(int[][] matrix);

```

就是说你可以站在 ` matrix ` 的第一行的任意一个元素，需要下降到最后一行。

每次下降，可以向下、向左下、向右下三个方向移动一格。也就是说，可以从 ` matrix[i][j] ` 降到 ` matrix[i+1][j] ` 或 `matrix[i+1][j-1] ` 或 ` matrix[i+1][j+1] ` 三个位置。

请你计算下降的「最小路径和」，比如说题目给了一个例子：

![](https://labuladong.gitee.io/algo/images/%e5%a4%87%e5%bf%98%e5%bd%95%e5%9f%ba%e7%a1%80/title.jpg)

我们前文写过两道「路径和」相关的文章： [ 动态规划之最小路径和 ](https://labuladong.gitee.io/algo/3/25/84/) 和 [ 用动态规划算法通关魔塔

](https://labuladong.gitee.io/algo/3/25/85/) 。

今天这道题也是类似的，不算是困难的题目，所以 **我们借这道题来讲讲 base case 的返回值、备忘录的初始值、索引越界情况的返回值如何确定** 。

不过还是要通过 [ 动态规划的标准套路 ](https://labuladong.gitee.io/algo/3/22/66/) 介绍一下这道题的解题思路，首先我们可以定义一个 ` dp ` 数组：

```java
    int dp(int[][] matrix, int i, int j);

```

这个 ` dp ` 函数的含义如下：

**从第一行（` matrix[0][..] ` ）向下落，落到位置 ` matrix[i][j] ` 的最小路径和为 ` dp(matrix, i, j)
` ** 。

根据这个定义，我们可以把主函数的逻辑写出来：

```java
    int minFallingPathSum(int[][] matrix) {
        int n = matrix.length;
        int res = Integer.MAX_VALUE;
    
        // 终点可能在最后一行的任意一列
        for (int j = 0; j < n; j++) {
            res = Math.min(res, dp(matrix, n - 1, j));
        }
    
        return res;
    }

```

因为我们可能落到最后一行的任意一列，所以要穷举一下，看看落到哪一列才能得到最小的路径和。

接下来看看 ` dp ` 函数如何实现。

对于 ` matrix[i][j] ` ，只有可能从 ` matrix[i-1][j], matrix[i-1][j-1], matrix[i-1][j+1] ` 这三个位置转移过来。

![](https://labuladong.gitee.io/algo/images/%e5%a4%87%e5%bf%98%e5%bd%95%e5%9f%ba%e7%a1%80/1.jpeg)

**那么，只要知道到达` (i-1, j), (i-1, j-1), (i-1, j+1) ` 这三个位置的最小路径和，加上 ` matrix[i][j]
` 的值，就能够计算出来到达位置 ` (i, j) ` 的最小路径和 ** ：

```java
    int dp(int[][] matrix, int i, int j) {
        // 非法索引检查
        if (i < 0 || j < 0 ||
            i >= matrix.length ||
            j >= matrix[0].length) {
            // 返回一个特殊值
            return 99999;
        }
        // base case
        if (i == 0) {
            return matrix[i][j];
        }
        // 状态转移
        return matrix[i][j] + min(
                dp(matrix, i - 1, j), 
                dp(matrix, i - 1, j - 1),
                dp(matrix, i - 1, j + 1)
            );
    }
    
    int min(int a, int b, int c) {
        return Math.min(a, Math.min(b, c));
    }

```

当然，上述代码是暴力穷举解法，我们可以用备忘录的方法消除重叠子问题，完整代码如下：

```java
    int minFallingPathSum(int[][] matrix) {
        int n = matrix.length;
        int res = Integer.MAX_VALUE;
        // 备忘录里的值初始化为 66666
        memo = new int[n][n];
        for (int i = 0; i < n; i++) {
            Arrays.fill(memo[i], 66666);
        }
        // 终点可能在 matrix[n-1] 的任意一列
        for (int j = 0; j < n; j++) {
            res = Math.min(res, dp(matrix, n - 1, j));
        }
        return res;
    }
    
    // 备忘录
    int[][] memo;
    
    int dp(int[][] matrix, int i, int j) {
        // 1、索引合法性检查
        if (i < 0 || j < 0 ||
            i >= matrix.length ||
            j >= matrix[0].length) {
            
            return 99999;
        }
        // 2、base case
        if (i == 0) {
            return matrix[0][j];
        }
        // 3、查找备忘录，防止重复计算
        if (memo[i][j] != 66666) {
            return memo[i][j];
        }
        // 进行状态转移
        memo[i][j] = matrix[i][j] + min(
                dp(matrix, i - 1, j), 
                dp(matrix, i - 1, j - 1),
                dp(matrix, i - 1, j + 1)
            );
        
        return memo[i][j];
    }
    
    int min(int a, int b, int c) {
        return Math.min(a, Math.min(b, c));
    }

```

如果看过我们公众号之前的动态规划系列文章，这个解题思路应该是非常容易理解的。

**那么本文对于这个` dp ` 函数仔细探讨三个问题 ** ：

1、对于索引的合法性检测，返回值为什么是 99999？其他的值行不行？

2、base case 为什么是 ` i == 0 ` ？

3、备忘录 ` memo ` 的初始值为什么是 66666？其他值行不行？

**首先，说说 base case 为什么是` i == 0 ` ，返回值为什么是 ` matrix[0][j] ` ，这是根据 ` dp `函数的定义所决定的 ** 。

回顾我们的 ` dp ` 函数定义：

从第一行（ ` matrix[0][..] ` ）向下落，落到位置 ` matrix[i][j] ` 的最小路径和为 ` dp(matrix, i, j)
` 。

根据这个定义，我们就是从 ` matrix[0][j] ` 开始下落。那如果我们想落到的目的地就是 ` i == 0 ` ，所需的路径和当然就是 `matrix[0][j] ` 呗。

**再说说备忘录` memo ` 的初始值为什么是 66666，这是由题目给出的数据范围决定的 ** 。

备忘录 ` memo ` 数组的作用是什么？

就是防止重复计算，将 ` dp(matrix, i, j) ` 的计算结果存进 ` memo[i][j] ` ，遇到重复计算可以直接返回。

那么，我们必须要知道 ` memo[i][j] ` 到底存储计算结果没有，对吧？如果存结果了，就直接返回；没存，就去递归计算。

所以， ` memo ` 的初始值一定得是特殊值，和合法的答案有所区分。

我们回过头看看题目给出的数据范围：

> ` matrix ` 是 ` n x n ` 的二维数组，其中 ` 1 <= n <= 100 ` ；对于二维数组中的元素，有 ` -100 <=matrix[i][j] <= 100 ` 。

假设 ` matrix ` 的大小是 100 x 100，所有元素都是 100，那么从第一行往下落，得到的路径和就是 100 x 100 = 10000，也就是最大的合法答案。

类似的，依然假设 ` matrix ` 的大小是 100 x 100，所有元素是 -100，那么从第一行往下落，就得到了最小的合法答案 -100 x 100 = -10000。

也就是说，这个问题的合法结果会落在区间 ` [-10000, 10000] ` 中。

所以，我们 ` memo ` 的初始值就要避开区间 ` [-10000, 10000] ` ，换句话说， ` memo ` 的初始值只要在区间 `(-inf, -10001] U [10001, +inf) ` 中就可以。

**最后，说说对于不合法的索引，返回值应该如何确定，这需要根据我们状态转移方程的逻辑确定** 。

对于这道题，状态转移的基本逻辑如下：

```java
    int dp(int[][] matrix, int i, int j) {
    
        return matrix[i][j] + min(
                dp(matrix, i - 1, j), 
                dp(matrix, i - 1, j - 1),
                dp(matrix, i - 1, j + 1)
            );
    }

```

显然， ` i - 1, j - 1, j + 1 ` 这几个运算可能会造成索引越界，对于索引越界的 ` dp ` 函数，应该返回一个不可能被取到的值。

因为我们调用的是 ` min ` 函数，最终返回的值是最小值，所以对于不合法的索引，只要 ` dp ` 函数返回一个永远不会被取到的最大值即可。

刚才说了，合法答案的区间是 ` [-10000, 10000] ` ，所以我们的返回值只要大于 10000 就相当于一个永不会取到的最大值。

换句话说，只要返回区间 ` [10001, +inf) ` 中的一个值，就能保证不会被取到。

至此，我们就把动态规划相关的三个细节问题举例说明了。

**拓展延伸一下，建议大家做题时，除了题意本身，一定不要忽视题目给定的其他信息** 。

本文举的例子，测试用例数据范围可以确定「什么是特殊值」，从而帮助我们将思路转化成代码。

除此之外，数据范围还可以帮我们估算算法的时间/空间复杂度。

比如说，有的算法题，你只想到一个暴力求解思路，时间复杂度比较高。如果发现题目给定的数据量比较大，那么肯定可以说明这个求解思路有问题或者存在优化的空间。

除了数据范围，有时候题目还会限制我们算法的时间复杂度，这种信息其实也暗示着一些东西。

比如要求我们的算法复杂度是 ` O(NlogN) ` ，你想想怎么才能搞出一个对数级别的复杂度呢？

肯定得用到 [ 二分搜索 ](https://labuladong.gitee.io/algo/2/20/57/) 或者二叉树相关的数据结构，比如 ` TreeMap ` ， `PriorityQueue ` 之类的对吧。

再比如，有时候题目要求你的算法时间复杂度是 ` O(MN) ` ，这可以联想到什么？

可以大胆猜测，常规解法是用 [ 回溯算法 ](https://labuladong.gitee.io/algo/4/28/105/) 暴力穷举，但是更好的解法是动态规划，而且是一个二维动态规划，需要一个
` M * N ` 的二维 ` dp ` 数组，所以产生了这样一个时间复杂度。

如果你早就胸有成竹了，那就当我没说，毕竟猜测也不一定准确；但如果你本来就没啥解题思路，那有了这些推测之后，最起码可以给你的思路一些方向吧？

总之，多动脑筋，不放过任何蛛丝马迹，你不成为刷题小能手才怪。



## 对动态规划进行降维打击



**———–**

我们号之前写过十几篇动态规划文章，可以说动态规划技巧对于算法效率的提升非常可观，一般来说都能把指数级和阶乘级时间复杂度的算法优化成 O(N^2)，堪称算法界的二向箔，把各路魑魅魍魉统统打成二次元。

但是，动态规划本身也是可以进行阶段性优化的，比如说我们常听说的「状态压缩」技巧，就能够把很多动态规划解法的空间复杂度进一步降低，由 O(N^2) 降低到 O(N)，

能够使用状态压缩技巧的动态规划都是二维 ` dp ` 问题， **你看它的状态转移方程，如果计算状态` dp[i][j] ` 需要的都是 `dp[i][j] ` 相邻的状态，那么就可以使用状态压缩技巧 ** ，将二维的 ` dp ` 数组转化成一维，将空间复杂度从 O(N^2) 降低到 O(N)。

什么叫「和 ` dp[i][j] ` 相邻的状态」呢，比如前文 [ 最长回文子序列 ](https://labuladong.gitee.io/algo/3/23/78/) 中，最终的代码如下：

```java
    int longestPalindromeSubseq(string s) {
        int n = s.size();
        // dp 数组全部初始化为 0
        vector<vector<int>> dp(n, vector<int>(n, 0));
        // base case
        for (int i = 0; i < n; i++)
            dp[i][i] = 1;
        // 反着遍历保证正确的状态转移
        for (int i = n - 2; i >= 0; i--) {
            for (int j = i + 1; j < n; j++) {
                // 状态转移方程
                if (s[i] == s[j])
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                else
                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
            }
        }
        // 整个 s 的最长回文子串长度
        return dp[0][n - 1];
    }

```

> PS：我们本文不探讨如何推状态转移方程，只探讨对二维 DP
> 问题进行状态压缩的技巧。技巧都是通用的，所以如果你没看过前文，不明白这段代码的逻辑也无妨，完全不会阻碍你学会状态压缩。

你看我们对 ` dp[i][j] ` 的更新，其实只依赖于 ` dp[i+1][j-1], dp[i][j-1], dp[i+1][j] ` 这三个状态：

![](https://labuladong.gitee.io/algo/images/%e7%8a%b6%e6%80%81%e5%8e%8b%e7%bc%a9/1.jpeg)

这就叫和 ` dp[i][j] ` 相邻，反正你计算 ` dp[i][j] ` 只需要这三个相邻状态，其实根本不需要那么大一个二维的 dp table 对不对？ **状态压缩的核心思路就是，将二维数组「投影」到一维数组** ：

![](https://labuladong.gitee.io/algo/images/%e7%8a%b6%e6%80%81%e5%8e%8b%e7%bc%a9/2.jpeg)

思路很直观，但是也有一个明显的问题，图中 ` dp[i][j-1] ` 和 ` dp[i+1][j-1] `这两个状态处在同一列，而一维数组中只能容下一个，那么当我计算 ` dp[i][j] ` 时，他俩必然有一个会被另一个覆盖掉，怎么办？

这就是状态压缩的难点，下面就来分析解决这个问题，还是拿「最长回文子序列」问题距离，它的状态转移方程主要逻辑就是如下这段代码：

```java
    for (int i = n - 2; i >= 0; i--) {
        for (int j = i + 1; j < n; j++) {
            // 状态转移方程
            if (s[i] == s[j])
                dp[i][j] = dp[i + 1][j - 1] + 2;
            else
                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
        }
    }

```

想把二维 ` dp ` 数组压缩成一维，一般来说是把第一个维度，也就是 ` i ` 这个维度去掉，只剩下 ` j ` 这个维度。 **压缩后的一维` dp
` 数组就是之前二维 ` dp ` 数组的 ` dp[i][..] ` 那一行 ** 。

我们先将上述代码进行改造，直接无脑去掉 ` i ` 这个维度，把 ` dp ` 数组变成一维：

```java
    for (int i = n - 2; i >= 0; i--) {
        for (int j = i + 1; j < n; j++) {
            // 在这里，一维 dp 数组中的数是什么？
            if (s[i] == s[j])
                dp[j] = dp[j - 1] + 2;
            else
                dp[j] = max(dp[j], dp[j - 1]);
        }
    }

```

上述代码的一维 ` dp ` 数组只能表示二维 ` dp ` 数组的一行 ` dp[i][..] ` ，那我怎么才能得到 ` dp[i+1][j-1], dp[i][j-1], dp[i+1][j] ` 这几个必要的的值，进行状态转移呢？

在代码中注释的位置，将要进行状态转移，更新 ` dp[j] ` ，那么我们要来思考两个问题：

1、在对 ` dp[j] ` 赋新值之前， ` dp[j] ` 对应着二维 ` dp ` 数组中的什么位置？

2、 ` dp[j-1] ` 对应着二维 ` dp ` 数组中的什么位置？

**对于问题 1，在对` dp[j] ` 赋新值之前， ` dp[j] ` 的值就是外层 for 循环上一次迭代算出来的值，也就是对应二维 ` dp `数组中 ` dp[i+1][j] ` 的位置 ** 。

**对于问题 2，` dp[j-1] ` 的值就是内层 for 循环上一次迭代算出来的值，也就是对应二维 ` dp ` 数组中 ` dp[i][j-1] `的位置 ** 。

那么问题已经解决了一大半了，只剩下二维 ` dp ` 数组中的 ` dp[i+1][j-1] ` 这个状态我们不能直接从一维 ` dp ` 数组中得到：

```java
    for (int i = n - 2; i >= 0; i--) {
        for (int j = i + 1; j < n; j++) {
            if (s[i] == s[j])
                // dp[i][j] = dp[i+1][j-1] + 2;
                dp[j] = ?? + 2;
            else
                // dp[i][j] = max(dp[i+1][j], dp[i][j-1]);
                dp[j] = max(dp[j], dp[j - 1]);
        }
    }

```

因为 for 循环遍历 ` i ` 和 ` j ` 的顺序为从左向右，从下向上，所以可以发现，在更新一维 ` dp ` 数组的时候， `dp[i+1][j-1] ` 会被 ` dp[i][j-1] ` 覆盖掉，图中标出了这四个位置被遍历到的次序：

![](https://labuladong.gitee.io/algo/images/%e7%8a%b6%e6%80%81%e5%8e%8b%e7%bc%a9/3.jpeg)

**那么如果我们想得到` dp[i+1][j-1] ` ，就必须在它被覆盖之前用一个临时变量 ` temp ` 把它存起来，并把这个变量的值保留到计算 `dp[i][j] ` 的时候 ** 。为了达到这个目的，结合上图，我们可以这样写代码：

```java
    for (int i = n - 2; i >= 0; i--) {
        // 存储 dp[i+1][j-1] 的变量
        int pre = 0;
        for (int j = i + 1; j < n; j++) {
            int temp = dp[j];
            if (s[i] == s[j])
                // dp[i][j] = dp[i+1][j-1] + 2;
                dp[j] = pre + 2;
            else
                dp[j] = max(dp[j], dp[j - 1]);
            // 到下一轮循环，pre 就是 dp[i+1][j-1] 了
            pre = temp;
        }
    }

```

别小看这段代码，这是一维 ` dp ` 最精妙的地方，会者不难，难者不会。为了清晰起见，我用具体的数值来拆解这个逻辑：

假设现在 ` i = 5, j = 7 ` 且 ` s[5] == s[7] ` ，那么现在会进入下面这个逻辑对吧：

```java
    if (s[5] == s[7])
        // dp[5][7] = dp[i+1][j-1] + 2;
        dp[7] = pre + 2;

```

我问你这个 ` pre ` 变量是什么？是内层 for 循环上一次迭代的 ` temp ` 值。

那我再问你内层 for 循环上一次迭代的 ` temp ` 值是什么？是 ` dp[j-1] ` 也就是 ` dp[6] ` ，但这是外层 for 循环上一次迭代对应的 ` dp[6] ` ，也就是二维 ` dp `数组中的 ` dp[i+1][6] = dp[6][6] ` 。

也就是说， ` pre ` 变量就是 ` dp[i+1][j-1] = dp[6][6] ` ，也就是我们想要的结果。

那么现在我们成功对状态转移方程进行了降维打击，算是最硬的的骨头啃掉了，但注意到我们还有 base case 要处理呀：

```java
    // dp 数组全部初始化为 0
    vector<vector<int>> dp(n, vector<int>(n, 0));
    // base case
    for (int i = 0; i < n; i++)
        dp[i][i] = 1;

```

如何把 base case 也打成一维呢？很简单，记住状态压缩就是投影，我们把 base case 投影到一维看看：

![](https://labuladong.gitee.io/algo/images/%e7%8a%b6%e6%80%81%e5%8e%8b%e7%bc%a9/4.jpeg)

二维 ` dp ` 数组中的 base case 全都落入了一维 ` dp ` 数组，不存在冲突和覆盖，所以说我们直接这样写代码就行了：

```java
    // 一维 dp 数组全部初始化为 1
    vector<int> dp(n, 1);

```

至此，我们把 base case 和状态转移方程都进行了降维，实际上已经写出完整代码了：

```java
    int longestPalindromeSubseq(string s) {
        int n = s.size();
        // base case：一维 dp 数组全部初始化为 0
        vector<int> dp(n, 1);
    
        for (int i = n - 2; i >= 0; i--) {
            int pre = 0;
            for (int j = i + 1; j < n; j++) {
                int temp = dp[j];
                // 状态转移方程
                if (s[i] == s[j])
                    dp[j] = pre + 2;
                else
                    dp[j] = max(dp[j], dp[j - 1]);
                pre = temp;
            }
        }
        return dp[n - 1];
    }

```

本文就结束了，不过状态压缩技巧再牛逼，也是基于常规动态规划思路之上的。

你也看到了，使用状态压缩技巧对二维 ` dp `数组进行降维打击之后，解法代码的可读性变得非常差了，如果直接看这种解法，任何人都是一脸懵逼的。算法的优化就是这么一个过程，先写出可读性很好的暴力递归算法，然后尝试运用动态规划技巧优化重叠子问题，最后尝试用状态压缩技巧优化空间复杂度。

也就是说，你最起码能够熟练运用我们前文 [ 动态规划框架套路详解 ](https://labuladong.gitee.io/algo/3/22/66/)
的套路找出状态转移方程，写出一个正确的动态规划解法，然后才有可能观察状态转移的情况，分析是否可能使用状态压缩技巧来优化。

希望读者能够稳扎稳打，层层递进，对于这种比较极限的优化，不做也罢。毕竟套路存于心，走遍天下都不怕！



## 动态规划和回溯算法到底谁是谁爹？



读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 494. 目标和（中等） ](https://leetcode-cn.com/problems/target-sum)

**———–**

我们前文经常说回溯算法和递归算法有点类似，有的问题如果实在想不出状态转移方程，尝试用回溯算法暴力解决也是一个聪明的策略，总比写不出来解法强。

那么，回溯算法和动态规划到底是啥关系？它俩都涉及递归，算法模板看起来还挺像的，都涉及做「选择」，真的酷似父与子。

![](https://labuladong.gitee.io/algo/images/targetSum/1.jpg)

那么，它俩具体有啥区别呢？回溯算法和动态规划之间，是否可能互相转化呢？

今天就用力扣第 494 题「目标和」来详细对比一下回溯算法和动态规划，真可谓群魔乱舞：

![](https://labuladong.gitee.io/algo/images/targetSum/title.jpg)

注意，给出的例子 ` nums ` 全是 1，但实际上可以是任意正整数哦。

### 一、回溯思路

其实我第一眼看到这个题目，花了两分钟就写出了一个回溯解法。

任何算法的核心都是穷举，回溯算法就是一个暴力穷举算法，前文 [ 回溯算法解题框架 ](https://labuladong.gitee.io/algo/4/28/105/) 就写了回溯算法框架：

```java
    def backtrack(路径, 选择列表):
        if 满足结束条件:
            result.add(路径)
            return
        
        for 选择 in 选择列表:
            做选择
            backtrack(路径, 选择列表)
            撤销选择

```

关键就是搞清楚什么是「选择」，而对于这道题，「选择」不是明摆着的吗？ **对于每个数字` nums[i] ` ，我们可以选择给一个正号 ` \+ `或者一个负号 ` \- ` ** ，然后利用回溯模板穷举出来所有可能的结果，数一数到底有几种组合能够凑出 ` target ` 不就行了嘛？

伪码思路如下：

```java
    def backtrack(nums, i):
        if i == len(nums):
            if 达到 target:
                result += 1
            return
        
        for op in { +1, -1 }:
            选择 op * nums[i]
            ## 穷举 nums[i + 1] 的选择
            backtrack(nums, i + 1)
            撤销选择

```

如果看过我们之前的几篇回溯算法文章，这个代码可以说是比较简单的了：

```java
    int result = 0;
    
    /* 主函数 */
    int findTargetSumWays(int[] nums, int target) {
        if (nums.length == 0) return 0;
        backtrack(nums, 0, target);
        return result;
    }
    
    /* 回溯算法模板 */
    void backtrack(int[] nums, int i, int rest) {
        // base case
        if (i == nums.length) {
            if (rest == 0) {
                // 说明恰好凑出 target
                result++;
            }
            return;
        }
        // 给 nums[i] 选择 - 号
        rest += nums[i];
        // 穷举 nums[i + 1]
        backtrack(nums, i + 1, rest);
        // 撤销选择
        rest -= nums[i]; 
        
        // 给 nums[i] 选择 + 号
        rest -= nums[i];
        // 穷举 nums[i + 1]
        backtrack(nums, i + 1, rest);
        // 撤销选择
        rest += nums[i];
    }

```

有的读者可能问，选择 ` \- ` 的时候，为什么是 ` rest += nums[i] ` ，选择 ` \+ ` 的时候，为什么是 ` rest -= nums[i] ` 呢，是不是写反了？

不是的，「如何凑出 ` target ` 」和「如何把 ` target ` 减到 0」其实是一样的。我们这里选择后者，因为前者必须给 `backtrack ` 函数多加一个参数，我觉得不美观：

```java
    void backtrack(int[] nums, int i, int sum, int target) {
        // base case
        if (i == nums.length) {
            if (sum == target) {
                result++;
            }
            return;
        }
        // ...
    }

```

因此，如果我们给 ` nums[i] ` 选择 ` \+ ` 号，就要让 ` rest - nums[i] ` ，反之亦然。

以上回溯算法可以解决这个问题，时间复杂度为 ` O(2^N) ` ， ` N ` 为 ` nums ` 的大小。这个复杂度怎么算的？回忆前文 [
学习数据结构和算法的框架思维 ](https://labuladong.gitee.io/algo/1/2/) ，发现这个回溯算法就是个二叉树的遍历问题：

```java
    void backtrack(int[] nums, int i, int rest) {
        if (i == nums.length) {
            return;
        }
        backtrack(nums, i + 1, rest - nums[i]);
        backtrack(nums, i + 1, rest + nums[i]);
    }

```

树的高度就是 ` nums ` 的长度嘛，所以说时间复杂度就是这棵二叉树的节点数，为 ` O(2^N) ` ，其实是非常低效的。

那么，这个问题如何用动态规划思想进行优化呢？

### 二、消除重叠子问题

动态规划之所以比暴力算法快，是因为动态规划技巧消除了重叠子问题。

如何发现重叠子问题？看是否可能出现重复的「状态」。对于递归函数来说，函数参数中会变的参数就是「状态」，对于 ` backtrack `函数来说，会变的参数为 ` i ` 和 ` rest ` 。

前文 [ 动态规划之编辑距离 ](https://labuladong.gitee.io/algo/3/23/73/) 说了一种一眼看出重叠子问题的方法，先抽象出递归框架：

```java
    void backtrack(int i, int rest) {
        backtrack(i + 1, rest - nums[i]);
        backtrack(i + 1, rest + nums[i]);
    }

```

举个简单的例子，如果 ` nums[i] = 0 ` ，会发生什么？

```java
    void backtrack(int i, int rest) {
        backtrack(i + 1, rest);
        backtrack(i + 1, rest);
    }

```

你看，这样就出现了两个「状态」完全相同的递归函数，无疑这样的递归计算就是重复的。
**这就是重叠子问题，而且只要我们能够找到一个重叠子问题，那一定还存在很多的重叠子问题** 。

因此，状态 ` (i, rest) ` 是可以用备忘录技巧进行优化的：

```java
    int findTargetSumWays(int[] nums, int target) {
        if (nums.length == 0) return 0;
        return dp(nums, 0, target);
    }
    
    // 备忘录
    HashMap<String, Integer> memo = new HashMap<>();
    int dp(int[] nums, int i, int rest) {
        // base case
        if (i == nums.length) {
            if (rest == 0) return 1;
            return 0;
        }
        // 把它俩转成字符串才能作为哈希表的键
        String key = i + "," + rest;
        // 避免重复计算
        if (memo.containsKey(key)) {
            return memo.get(key);
        }
        // 还是穷举
        int result = dp(nums, i + 1, rest - nums[i]) + dp(nums, i + 1, rest + nums[i]);
        // 记入备忘录
        memo.put(key, result);
        return result;
    }

```

以前我们都是用 Python 的元组配合哈希表 ` dict `来做备忘录的，其他语言没有元组，可以用把「状态」转化为字符串作为哈希表的键，这是一个常用的小技巧。

这个解法通过备忘录消除了很多重叠子问题，效率有一定的提升，但是这就结束了吗？

### 三、动态规划

其实，这个问题可以转化为一个子集划分问题，而子集划分问题又是一个典型的背包问题。动态规划总是这么玄学，让人摸不着头脑……

首先，如果我们把 ` nums ` 划分成两个子集 ` A ` 和 ` B ` ，分别代表分配 ` \+ ` 的数和分配 ` \- ` 的数，那么他们和 `target ` 存在如下关系：

```java
    sum(A) - sum(B) = target
    sum(A) = target + sum(B)
    sum(A) + sum(A) = target + sum(B) + sum(A)
    2 * sum(A) = target + sum(nums)

```

综上，可以推出 ` sum(A) = (target + sum(nums)) / 2 ` ，也就是把原问题转化成： **` nums ` 中存在几个子集
` A ` ，使得 ` A ` 中元素的和为 ` (target + sum(nums)) / 2 ` ** ？

类似的子集划分问题我们前文 [ 经典背包问题：子集划分 ](https://labuladong.gitee.io/algo/3/24/81/) 讲过，现在实现这么一个函数：

```java
    /* 计算 nums 中有几个子集的和为 sum */
    int subsets(int[] nums, int sum) {}

```

然后，可以这样调用这个函数：

```java
    int findTargetSumWays(int[] nums, int target) {
        int sum = 0;
        for (int n : nums) sum += n;
        // 这两种情况，不可能存在合法的子集划分
        if (sum < target || (sum + target) % 2 == 1) {
            return 0;
        }
        return subsets(nums, (sum + target) / 2);
    }

```

好的，变成背包问题的标准形式：

**有一个背包，容量为` sum ` ，现在给你 ` N ` 个物品，第 ` i ` 个物品的重量为 ` nums[i - 1] ` （注意 ` 1 <= i <= N `），每个物品只有一个，请问你有几种不同的方法能够恰好装满这个背包 ** ？

现在，这就是一个正宗的动态规划问题了，下面按照我们一直强调的动态规划套路走流程：

**第一步要明确两点，「状态」和「选择」** 。

对于背包问题，这个都是一样的，状态就是「背包的容量」和「可选择的物品」，选择就是「装进背包」或者「不装进背包」。

**第二步要明确` dp ` 数组的定义 ** 。

按照背包问题的套路，可以给出如下定义：

` dp[i][j] = x ` 表示，若只在前 ` i ` 个物品中选择，若当前背包的容量为 ` j ` ，则最多有 ` x ` 种方法可以恰好装满背包。

翻译成我们探讨的子集问题就是，若只在 ` nums ` 的前 ` i ` 个元素中选择，若目标和为 ` j ` ，则最多有 ` x ` 种方法划分子集。

根据这个定义，显然 ` dp[0][..] = 0 ` ，因为没有物品的话，根本没办法装背包； ` dp[..][0] = 1 `，因为如果背包的最大载重为 0，「什么都不装」就是唯一的一种装法。

我们所求的答案就是 ` dp[N][sum] ` ，即使用所有 ` N ` 个物品，有几种方法可以装满容量为 ` sum ` 的背包。

**第三步，根据「选择」，思考状态转移的逻辑** 。

回想刚才的 ` dp ` 数组含义，可以根据「选择」对 ` dp[i][j] ` 得到以下状态转移：

如果不把 ` nums[i] ` 算入子集， **或者说你不把这第` i ` 个物品装入背包 ** ，那么恰好装满背包的方法数就取决于上一个状态 `dp[i-1][j] ` ，继承之前的结果。

如果把 ` nums[i] ` 算入子集， **或者说你把这第` i ` 个物品装入了背包 ** ，那么只要看前 ` i - 1 `个物品有几种方法可以装满 ` j - nums[i-1] ` 的重量就行了，所以取决于状态 ` dp[i-1][j-nums[i-1]] ` 。

> PS：注意我们说的 ` i ` 是从 1 开始算的，而数组 ` nums ` 的索引时从 0 开始算的，所以 ` nums[i-1] ` 代表的是第 `> i ` 个物品的重量， ` j - nums[i-1] ` 就是背包装入物品 ` i ` 之后还剩下的容量。

**由于` dp[i][j] ` 为装满背包的总方法数，所以应该以上两种选择的结果求和，得到状态转移方程 ** ：

```java
    dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i-1]];

```

然后，根据状态转移方程写出动态规划算法：

```java
    /* 计算 nums 中有几个子集的和为 sum */
    int subsets(int[] nums, int sum) {
        int n = nums.length;
        int[][] dp = new int[n + 1][sum + 1];
        // base case
        for (int i = 0; i <= n; i++) {
            dp[i][0] = 1;
        }
        
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j <= sum; j++) {
                if (j >= nums[i-1]) {
                    // 两种选择的结果之和
                    dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i-1]];
                } else {
                    // 背包的空间不足，只能选择不装物品 i
                    dp[i][j] = dp[i-1][j];
                }
            }
        }
        return dp[n][sum];
    }

```

然后，发现这个 ` dp[i][j] ` 只和前一行 ` dp[i-1][..] ` 有关，那么肯定可以优化成一维 ` dp ` ：

```java
    /* 计算 nums 中有几个子集的和为 sum */
    int subsets(int[] nums, int sum) {
        int n = nums.length;
        int[] dp = new int[sum + 1];
        // base case
        dp[0] = 1;
        
        for (int i = 1; i <= n; i++) {
            // j 要从后往前遍历
            for (int j = sum; j >= 0; j--) {
                // 状态转移方程
                if (j >= nums[i-1]) {
                    dp[j] = dp[j] + dp[j-nums[i-1]];
                } else {
                    dp[j] = dp[j];
                }
            }
        }
        return dp[sum];
    }

```

**对照二维` dp ` ，只要把 ` dp ` 数组的第一个维度全都去掉就行了，唯一的区别就是这里的 ` j ` 要从后往前遍历，原因如下 ** ：

因为二维压缩到一维的根本原理是， ` dp[j] ` 和 ` dp[j-nums[i-1]] ` 还没被新结果覆盖的时候，相当于二维 ` dp ` 中的 `dp[i-1][j] ` 和 ` dp[i-1][j-nums[i-1]] ` 。

那么，我们就要做到： **在计算新的` dp[j] ` 的时候， ` dp[j] ` 和 ` dp[j-nums[i-1]] ` 还是上一轮外层 for 循环的结果 ** 。

如果你从前往后遍历一维 ` dp ` 数组， ` dp[j] ` 显然是没问题的，但是 ` dp[j-nums[i-1]] ` 已经不是上一轮外层 for 循环的结果了，这里就会使用错误的状态，当然得不到正确的答案。

现在，这道题算是彻底解决了。

总结一下，回溯算法虽好，但是复杂度高，即便消除一些冗余计算，也只是「剪枝」，没有本质的改进。而动态规划就比较玄学了，经过各种改造，从一个加减法问题变成子集问题，又变成背包问题，经过各种套路写出解法，又搞出状态压缩，还得反向遍历。

现在我都搞不清楚自己是来干嘛的了。嗯，这也许就是动态规划的魅力吧。

接下来可阅读：

* [ 分治算法：运算优先级 ](https://labuladong.gitee.io/algo/4/30/125/)



# 子序列类型问题



## 经典动态规划：编辑距离



读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 72. 编辑距离（困难） ](https://leetcode-cn.com/problems/edit-distance)

**———–**

本文有视频版： [ 编辑距离详解动态规划 ](https://www.bilibili.com/video/BV1uv411W73P/)

前几天看了一份鹅场的面试题，算法部分大半是动态规划，最后一题就是写一个计算编辑距离的函数，今天就专门写一篇文章来探讨一下这个问题。

我个人很喜欢编辑距离这个问题，因为它看起来十分困难，解法却出奇得简单漂亮，而且它是少有的比较实用的算法（是的，我承认很多算法问题都不太实用）。下面先来看下题目：

![](https://labuladong.gitee.io/algo/images/editDistance/title.png)

为什么说这个问题难呢，因为显而易见，它就是难，让人手足无措，望而生畏。

为什么说它实用呢，因为前几天我就在日常生活中用到了这个算法。之前有一篇公众号文章由于疏忽，写错位了一段内容，我决定修改这部分内容让逻辑通顺。但是公众号文章最多只能修改 20
个字，且只支持增、删、替换操作（跟编辑距离问题一模一样），于是我就用算法求出了一个最优方案，只用了 16 步就完成了修改。

再比如高大上一点的应用，DNA 序列是由 A,G,C,T 组成的序列，可以类比成字符串。编辑距离可以衡量两个 DNA 序列的相似度，编辑距离越小，说明这两段 DNA 越相似，说不定这俩 DNA 的主人是远古近亲啥的。

下面言归正传，详细讲解一下编辑距离该怎么算，相信本文会让你有收获。

### 一、思路

编辑距离问题就是给我们两个字符串 ` s1 ` 和 ` s2 ` ，只能用三种操作，让我们把 ` s1 ` 变成 ` s2 `，求最少的操作数。需要明确的是，不管是把 ` s1 ` 变成 ` s2 ` 还是反过来，结果都是一样的，所以后文就以 ` s1 ` 变成 ` s2 `举例。

前文 [ 最长公共子序列 ](https://labuladong.gitee.io/algo/3/23/77/) 说过， **解决两个字符串的动态规划问题，一般都是用两个指针` i,j `分别指向两个字符串的最后，然后一步步往前走，缩小问题的规模 ** 。

设两个字符串分别为 ` "rad" ` 和 ` "apple" ` ，为了把 ` s1 ` 变成 ` s2 ` ，算法会这样进行：

![](https://labuladong.gitee.io/algo/images/editDistance/edit.gif)
![](https://labuladong.gitee.io/algo/images/editDistance/1.jpg)

请记住这个 GIF 过程，这样就能算出编辑距离。关键在于如何做出正确的操作，稍后会讲。

根据上面的 GIF，可以发现操作不只有三个，其实还有第四个操作，就是什么都不要做（skip）。比如这个情况：

![](https://labuladong.gitee.io/algo/images/editDistance/2.jpg)

因为这两个字符本来就相同，为了使编辑距离最小，显然不应该对它们有任何操作，直接往前移动 ` i,j ` 即可。

还有一个很容易处理的情况，就是 ` j ` 走完 ` s2 ` 时，如果 ` i ` 还没走完 ` s1 ` ，那么只能用删除操作把 ` s1 ` 缩短为
` s2 ` 。比如这个情况：

![](https://labuladong.gitee.io/algo/images/editDistance/3.jpg)

类似的，如果 ` i ` 走完 ` s1 ` 时 ` j ` 还没走完了 ` s2 ` ，那就只能用插入操作把 ` s2 ` 剩下的字符全部插入 ` s1
` 。等会会看到，这两种情况就是算法的 **base case** 。

下面详解一下如何将思路转换成代码，坐稳，要发车了。

### 二、代码详解

先梳理一下之前的思路：

base case 是 ` i ` 走完 ` s1 ` 或 ` j ` 走完 ` s2 ` ，可以直接返回另一个字符串剩下的长度。

对于每对儿字符 ` s1[i] ` 和 ` s2[j] ` ，可以有四种操作：

```java
    if s1[i] == s2[j]:
        啥都别做（skip）
        i, j 同时向前移动
    else:
        三选一：
            插入（insert）
            删除（delete）
            替换（replace）

```

有这个框架，问题就已经解决了。读者也许会问，这个「三选一」到底该怎么选择呢？很简单，全试一遍，哪个操作最后得到的编辑距离最小，就选谁。这里需要递归技巧，理解需要点技巧，先看下代码：

```java
    def minDistance(s1, s2) -> int:
        ## 定义：dp(i, j) 返回 s1[0..i] 和 s2[0..j] 的最小编辑距离
        def dp(i, j):
            ## base case
            if i == -1: return j + 1
            if j == -1: return i + 1
            
            if s1[i] == s2[j]:
                return dp(i - 1, j - 1)  ## 啥都不做
            else:
                return min(
                    dp(i, j - 1) + 1,    ## 插入
                    dp(i - 1, j) + 1,    ## 删除
                    dp(i - 1, j - 1) + 1 ## 替换
                )
        
        ## i，j 初始化指向最后一个索引
        return dp(len(s1) - 1, len(s2) - 1)

```

下面来详细解释一下这段递归代码，base case 应该不用解释了，主要解释一下递归部分。

都说递归代码的可解释性很好，这是有道理的，只要理解函数的定义，就能很清楚地理解算法的逻辑。我们这里 ` dp(i, j) ` 函数的定义是这样的：

```java
    def dp(i, j) -> int
    ## 返回 s1[0..i] 和 s2[0..j] 的最小编辑距离

```

**记住这个定义** 之后，先来看这段代码：

```java
    if s1[i] == s2[j]:
        return dp(i - 1, j - 1)  ## 啥都不做
    ## 解释：
    ## 本来就相等，不需要任何操作
    ## s1[0..i] 和 s2[0..j] 的最小编辑距离等于
    ## s1[0..i-1] 和 s2[0..j-1] 的最小编辑距离
    ## 也就是说 dp(i, j) 等于 dp(i-1, j-1)

```

如果 ` s1[i]！=s2[j] ` ，就要对三个操作递归了，稍微需要点思考：

```java
    dp(i, j - 1) + 1,    ## 插入
    ## 解释：
    ## 我直接在 s1[i] 插入一个和 s2[j] 一样的字符
    ## 那么 s2[j] 就被匹配了，前移 j，继续跟 i 对比
    ## 别忘了操作数加一

```

![](https://labuladong.gitee.io/algo/images/editDistance/insert.gif)

```java
    dp(i - 1, j) + 1,    ## 删除
    ## 解释：
    ## 我直接把 s[i] 这个字符删掉
    ## 前移 i，继续跟 j 对比
    ## 操作数加一

```

![](https://labuladong.gitee.io/algo/images/editDistance/delete.gif)

```java
    dp(i - 1, j - 1) + 1 ## 替换
    ## 解释：
    ## 我直接把 s1[i] 替换成 s2[j]，这样它俩就匹配了
    ## 同时前移 i，j 继续对比
    ## 操作数加一

```

![](https://labuladong.gitee.io/algo/images/editDistance/replace.gif)

现在，你应该完全理解这段短小精悍的代码了。还有点小问题就是，这个解法是暴力解法，存在重叠子问题，需要用动态规划技巧来优化。

**怎么能一眼看出存在重叠子问题呢** ？前文 [ 动态规划之正则表达式 ](https://labuladong.gitee.io/algo/3/25/88/)
有提过，这里再简单提一下，需要抽象出本文算法的递归框架：

```java
    def dp(i, j):
        dp(i - 1, j - 1) #1
        dp(i, j - 1)     #2
        dp(i - 1, j)     #3

```

对于子问题 ` dp(i-1, j-1) ` ，如何通过原问题 ` dp(i, j) ` 得到呢？有不止一条路径，比如 ` dp(i, j) -> #1 `和 ` dp(i, j) -> #2 -> #3 ` 。一旦发现一条重复路径，就说明存在巨量重复路径，也就是重叠子问题。

### 三、动态规划优化

对于重叠子问题呢，前文 [ 动态规划详解 ](https://labuladong.gitee.io/algo/3/22/66/) 详细介绍过，优化方法无非是备忘录或者 DP table。

备忘录很好加，原来的代码稍加修改即可：

```java
    def minDistance(s1, s2) -> int:
    
        memo = dict() ## 备忘录
        def dp(i, j):
            if (i, j) in memo: 
                return memo[(i, j)]
            ...
            
            if s1[i] == s2[j]:
                memo[(i, j)] = ...  
            else:
                memo[(i, j)] = ...
            return memo[(i, j)]
        
        return dp(len(s1) - 1, len(s2) - 1)

```

**主要说下 DP table 的解法** ：

首先明确 dp 数组的含义，dp 数组是一个二维数组，长这样：

![](https://labuladong.gitee.io/algo/images/editDistance/dp.jpg)

有了之前递归解法的铺垫，应该很容易理解。 ` dp[..][0] ` 和 ` dp[0][..] ` 对应 base case， ` dp[i][j] `的含义和之前的 dp 函数类似：

```java
    def dp(i, j) -> int
    ## 返回 s1[0..i] 和 s2[0..j] 的最小编辑距离
    
    dp[i-1][j-1]
    ## 存储 s1[0..i] 和 s2[0..j] 的最小编辑距离

```

dp 函数的 base case 是 ` i, j ` 等于 -1，而数组索引至少是 0，所以 dp 数组会偏移一位。

既然 dp 数组和递归 dp 函数含义一样，也就可以直接套用之前的思路写代码， **唯一不同的是，DP table 是自底向上求解，递归解法是自顶向下求解** ：

```java
    int minDistance(String s1, String s2) {
        int m = s1.length(), n = s2.length();
        int[][] dp = new int[m + 1][n + 1];
        // base case 
        for (int i = 1; i <= m; i++)
            dp[i][0] = i;
        for (int j = 1; j <= n; j++)
            dp[0][j] = j;
        // 自底向上求解
        for (int i = 1; i <= m; i++)
            for (int j = 1; j <= n; j++)
                if (s1.charAt(i-1) == s2.charAt(j-1))
                    dp[i][j] = dp[i - 1][j - 1];
                else               
                    dp[i][j] = min(
                        dp[i - 1][j] + 1,
                        dp[i][j - 1] + 1,
                        dp[i-1][j-1] + 1
                    );
        // 储存着整个 s1 和 s2 的最小编辑距离
        return dp[m][n];
    }
    
    int min(int a, int b, int c) {
        return Math.min(a, Math.min(b, c));
    }

```

### 三、扩展延伸

一般来说，处理两个字符串的动态规划问题，都是按本文的思路处理，建立 DP table。为什么呢，因为易于找出状态转移的关系，比如编辑距离的 DP table：

![](https://labuladong.gitee.io/algo/images/editDistance/4.jpg)

还有一个细节，既然每个 ` dp[i][j] ` 只和它附近的三个状态有关，空间复杂度是可以压缩成 ` O(min(M, N)) ` 的（M，N 是两个字符串的长度）。不难，但是可解释性大大降低，读者可以自己尝试优化一下。

你可能还会问， **这里只求出了最小的编辑距离，那具体的操作是什么**
？你之前举的修改公众号文章的例子，只有一个最小编辑距离肯定不够，还得知道具体怎么修改才行。

这个其实很简单，代码稍加修改，给 dp 数组增加额外的信息即可：

```java
    // int[][] dp;
    Node[][] dp;
    
    class Node {
        int val;
        int choice;
        // 0 代表啥都不做
        // 1 代表插入
        // 2 代表删除
        // 3 代表替换
    }

```

` val ` 属性就是之前的 dp 数组的数值， ` choice ` 属性代表操作。在做最优选择时，顺便把操作记录下来，然后就从结果反推具体操作。

我们的最终结果不是 ` dp[m][n] ` 吗，这里的 ` val ` 存着最小编辑距离， ` choice `存着最后一个操作，比如说是插入操作，那么就可以左移一格：

![](https://labuladong.gitee.io/algo/images/editDistance/5.jpg)

重复此过程，可以一步步回到起点 ` dp[0][0] ` ，形成一条路径，按这条路径上的操作进行编辑，就是最佳方案。

![](https://labuladong.gitee.io/algo/images/editDistance/6.jpg)



## 动态规划设计：最长递增子序列



读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 300. 最长递增子序列（中等） ](https://leetcode-cn.com/problems/longest-increasing-
subsequence)

**———–**

也许有读者看了前文 [ 动态规划详解 ](https://labuladong.gitee.io/algo/3/22/66/) ，学会了动态规划的套路：找到了问题的「状态」，明确了 ` dp `数组/函数的含义，定义了 base case；但是不知道如何确定「选择」，也就是不到状态转移的关系，依然写不出动态规划解法，怎么办？

不要担心，动态规划的难点本来就在于寻找正确的状态转移方程，本文就借助经典的「最长递增子序列问题」来讲一讲设计动态规划的通用技巧： **数学归纳思想** 。

最长递增子序列（Longest Increasing Subsequence，简写 LIS）是非常经典的一个算法问题，比较容易想到的是动态规划解法，时间复杂度 O(N^2)
，我们借这个问题来由浅入深讲解如何找状态转移方程，如何写出动态规划解法。比较难想到的是利用二分查找，时间复杂度是 O(NlogN)，我们通过一种简单的纸牌游戏来辅助理解这种巧妙的解法。

先看一下题目，很容易理解：

![](https://labuladong.gitee.io/algo/images/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/title.png)

注意「子序列」和「子串」这两个名词的区别，子串一定是连续的，而子序列不一定是连续的。下面先来设计动态规划算法解决这个问题。

### 一、动态规划解法

动态规划的核心设计思想是数学归纳法。

相信大家对数学归纳法都不陌生，高中就学过，而且思路很简单。比如我们想证明一个数学结论，那么 **我们先假设这个结论在` k<n `时成立，然后根据这个假设，想办法推导证明出 ` k=n ` 的时候此结论也成立 ** 。如果能够证明出来，那么就说明这个结论对于 ` k `等于任何数都成立。

类似的，我们设计动态规划算法，不是需要一个 dp 数组吗？我们可以假设 ` dp[0...i-1] ` 都已经被算出来了，然后问自己：怎么通过这些结果算出
` dp[i] ` ？

直接拿最长递增子序列这个问题举例你就明白了。不过，首先要定义清楚 dp 数组的含义，即 ` dp[i] ` 的值到底代表着什么？

**我们的定义是这样的：` dp[i] ` 表示以 ` nums[i] ` 这个数结尾的最长递增子序列的长度 ** 。

> PS：为什么这样定义呢？这是解决子序列问题的一个套路，后文 [ 动态规划之子序列问题解题模板 ](https://labuladong.gitee.io/algo/3/23/78/)
> 总结了几种常见套路。你读完本章所有的动态规划问题，就会发现 ` dp ` 数组的定义方法也就那几种。

根据这个定义，我们就可以推出 base case： ` dp[i] ` 初始值为 1，因为以 ` nums[i] ` 结尾的最长递增子序列起码要包含它自己。

举两个例子：

![](https://labuladong.gitee.io/algo/images/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/1.jpeg)
![](https://labuladong.gitee.io/algo/images/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/2.jpeg)

算法演进的过程是这样的，：

![](https://labuladong.gitee.io/algo/images/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/gif1.gif)

根据这个定义，我们的最终结果（子序列的最大长度）应该是 dp 数组中的最大值。

```java
    int res = 0;
    for (int i = 0; i < dp.length; i++) {
        res = Math.max(res, dp[i]);
    }
    return res;

```

读者也许会问，刚才的算法演进过程中每个 ` dp[i] ` 的结果是我们肉眼看出来的，我们应该怎么设计算法逻辑来正确计算每个 ` dp[i] ` 呢？

这就是动态规划的重头戏了，要思考如何设计算法逻辑进行状态转移，才能正确运行呢？这里就可以使用数学归纳的思想：

**假设我们已经知道了` dp[0..4] ` 的所有结果，我们如何通过这些已知结果推出 ` dp[5] ` 呢 ** ？

![](https://labuladong.gitee.io/algo/images/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/3.jpeg)

根据刚才我们对 ` dp ` 数组的定义，现在想求 ` dp[5] ` 的值，也就是想求以 ` nums[5] ` 为结尾的最长递增子序列。

**` nums[5] = 3 ` ，既然是递增子序列，我们只要找到前面那些结尾比 3 小的子序列，然后把 3 接到最后，就可以形成一个新的递增子序列，而且这个新的子序列长度加一 ** 。

显然，可能形成很多种新的子序列，但是我们只选择最长的那一个，把最长子序列的长度作为 ` dp[5] ` 的值即可。

![](https://labuladong.gitee.io/algo/images/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/gif2.gif)

```java
    for (int j = 0; j < i; j++) {
        if (nums[i] > nums[j]) 
            dp[i] = Math.max(dp[i], dp[j] + 1);
    }

```

当 ` i = 5 ` 时，这段代码的逻辑就可以算出 ` dp[5] ` 。其实到这里，这道算法题我们就基本做完了。

读者也许会问，我们刚才只是算了 ` dp[5] ` 呀， ` dp[4] ` , ` dp[3] ` 这些怎么算呢？类似数学归纳法，你已经可以算出 `dp[5] ` 了，其他的就都可以算出来：

```java
    for (int i = 0; i < nums.length; i++) {
        for (int j = 0; j < i; j++) {
            if (nums[i] > nums[j]) 
                dp[i] = Math.max(dp[i], dp[j] + 1);
        }
    }

```

结合我们刚才说的 base case，下面我们看一下完整代码：

```java
    int lengthOfLIS(int[] nums) {
        int[] dp = new int[nums.length];
        // base case：dp 数组全都初始化为 1
        Arrays.fill(dp, 1);
        for (int i = 0; i < nums.length; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) 
                    dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
        
        int res = 0;
        for (int i = 0; i < dp.length; i++) {
            res = Math.max(res, dp[i]);
        }
        return res;
    }

```

至此，这道题就解决了，时间复杂度 O(N^2)。总结一下如何找到动态规划的状态转移关系：

1、明确 ` dp ` 数组的定义。这一步对于任何动态规划问题都很重要，如果不得当或者不够清晰，会阻碍之后的步骤。

2、根据 ` dp ` 数组的定义，运用数学归纳法的思想，假设 ` dp[0...i-1] ` 都已知，想办法求出 ` dp[i] `，一旦这一步完成，整个题目基本就解决了。

但如果无法完成这一步，很可能就是 ` dp ` 数组的定义不够恰当，需要重新定义 ` dp ` 数组的含义；或者可能是 ` dp `数组存储的信息还不够，不足以推出下一步的答案，需要把 ` dp ` 数组扩大成二维数组甚至三维数组。

### 二、二分查找解法

这个解法的时间复杂度为 O(NlogN)，但是说实话，正常人基本想不到这种解法（也许玩过某些纸牌游戏的人可以想出来）。所以大家了解一下就好，正常情况下能够给出动态规划解法就已经很不错了。

根据题目的意思，我都很难想象这个问题竟然能和二分查找扯上关系。其实最长递增子序列和一种叫做 patience game 的纸牌游戏有关，甚至有一种排序方法就叫做 patience sorting（耐心排序）。

为了简单起见，后文跳过所有数学证明，通过一个简化的例子来理解一下算法思路。

首先，给你一排扑克牌，我们像遍历数组那样从左到右一张一张处理这些扑克牌，最终要把这些牌分成若干堆。

![](https://labuladong.gitee.io/algo/images/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/poker1.jpeg)

**处理这些扑克牌要遵循以下规则** ：

只能把点数小的牌压到点数比它大的牌上；如果当前牌点数较大没有可以放置的堆，则新建一个堆，把这张牌放进去；如果当前牌有多个堆可供选择，则选择最左边的那一堆放置。

比如说上述的扑克牌最终会被分成这样 5 堆（我们认为纸牌 A 的牌面是最大的，纸牌 2 的牌面是最小的）。

![](https://labuladong.gitee.io/algo/images/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/poker2.jpeg)

为什么遇到多个可选择堆的时候要放到最左边的堆上呢？因为这样可以保证牌堆顶的牌有序（2, 4, 7, 8, Q），证明略。

![](https://labuladong.gitee.io/algo/images/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/poker3.jpeg)

按照上述规则执行，可以算出最长递增子序列，牌的堆数就是最长递增子序列的长度，证明略。

![](https://labuladong.gitee.io/algo/images/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/poker4.jpeg)

我们只要把处理扑克牌的过程编程写出来即可。每次处理一张扑克牌不是要找一个合适的牌堆顶来放吗，牌堆顶的牌不是 **有序**
吗，这就能用到二分查找了：用二分查找来搜索当前牌应放置的位置。

> PS：旧文 [ 二分查找算法详解 ](https://labuladong.gitee.io/algo/2/20/57/) 详细介绍了二分查找的细节及变体，这里就完美应用上了，如果没读过强烈建议阅读。

```java
    public int lengthOfLIS(int[] nums) {
        int[] top = new int[nums.length];
        // 牌堆数初始化为 0
        int piles = 0;
        for (int i = 0; i < nums.length; i++) {
            // 要处理的扑克牌
            int poker = nums[i];
    
            /***** 搜索左侧边界的二分查找 *****/
            int left = 0, right = piles;
            while (left < right) {
                int mid = (left + right) / 2;
                if (top[mid] > poker) {
                    right = mid;
                } else if (top[mid] < poker) {
                    left = mid + 1;
                } else {
                    right = mid;
                }
            }
            /*********************************/
            
            // 没找到合适的牌堆，新建一堆
            if (left == piles) piles++;
            // 把这张牌放到牌堆顶
            top[left] = poker;
        }
        // 牌堆数就是 LIS 长度
        return piles;
    }

```

至此，二分查找的解法也讲解完毕。

这个解法确实很难想到。首先涉及数学证明，谁能想到按照这些规则执行，就能得到最长递增子序列呢？其次还有二分查找的运用，要是对二分查找的细节不清楚，给了思路也很难写对。

所以，这个方法作为思维拓展好了。但动态规划的设计方法应该完全理解：假设之前的答案已知，利用数学归纳的思想正确进行状态的推演转移，最终得到答案。

接下来可阅读：

* [ 动态规划之最大子数组 ](https://labuladong.gitee.io/algo/3/23/76/)



## 二维递增子序列：信封嵌套问题



读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 354. 俄罗斯套娃信封问题（困难） ](https://leetcode-cn.com/problems/russian-doll-
envelopes)

**———–**

很多算法问题都需要排序技巧，其难点不在于排序本身，而是需要巧妙地排序进行预处理，将算法问题进行转换，为之后的操作打下基础。

信封嵌套问题就需要先按特定的规则排序，之后就转换为一个 [ 最长递增子序列问题 ](https://labuladong.gitee.io/algo/3/23/74/) ，可以用前文 [ 二分查找详解

](https://labuladong.gitee.io/algo/2/20/57/) 的技巧来解决了。

### 一、题目概述

信封嵌套问题是个很有意思且经常出现在生活中的问题，先看下题目：

![](https://labuladong.gitee.io/algo/images/%E4%BF%A1%E5%B0%81%E5%B5%8C%E5%A5%97/title.png)

这道题目其实是最长递增子序列（Longes Increasing Subsequence，简写为 LIS）的一个变种，因为很显然，每次合法的嵌套是大的套小的，相当于找一个最长递增的子序列，其长度就是最多能嵌套的信封个数。

但是难点在于，标准的 LIS 算法只能在数组中寻找最长子序列，而我们的信封是由 ` (w, h) ` 这样的二维数对形式表示的，如何把 LIS 算法运用过来呢？

![](https://labuladong.gitee.io/algo/images/%E4%BF%A1%E5%B0%81%E5%B5%8C%E5%A5%97/0.jpg)

读者也许会想，通过 ` w × h ` 计算面积，然后对面积进行标准的 LIS 算法。但是稍加思考就会发现这样不行，比如 ` 1 × 10 ` 大于 ` 3 × 3 ` ，但是显然这样的两个信封是无法互相嵌套的。

### 二、解法

这道题的解法是比较巧妙的：

**先对宽度` w ` 进行升序排序，如果遇到 ` w ` 相同的情况，则按照高度 ` h ` 降序排序。之后把所有的 ` h `作为一个数组，在这个数组上计算 LIS 的长度就是答案 ** 。

画个图理解一下，先对这些数对进行排序：

![](https://labuladong.gitee.io/algo/images/%E4%BF%A1%E5%B0%81%E5%B5%8C%E5%A5%97/1.jpg)

然后在 ` h ` 上寻找最长递增子序列：

![](https://labuladong.gitee.io/algo/images/%E4%BF%A1%E5%B0%81%E5%B5%8C%E5%A5%97/2.jpg)

这个子序列就是最优的嵌套方案。

这个解法的关键在于，对于宽度 ` w ` 相同的数对，要对其高度 ` h ` 进行降序排序。因为两个宽度相同的信封不能相互包含的，逆序排序保证在 ` w `相同的数对中最多只选取一个。

下面看代码：

```java
    // envelopes = [[w, h], [w, h]...]
    public int maxEnvelopes(int[][] envelopes) {
        int n = envelopes.length;
        // 按宽度升序排列，如果宽度一样，则按高度降序排列
        Arrays.sort(envelopes, new Comparator<int[]>() 
        {
            public int compare(int[] a, int[] b) {
                return a[0] == b[0] ? 
                    b[1] - a[1] : a[0] - b[0];
            }
        });
        // 对高度数组寻找 LIS
        int[] height = new int[n];
        for (int i = 0; i < n; i++)
            height[i] = envelopes[i][1];
    
        return lengthOfLIS(height);
    }

```

关于最长递增子序列的寻找方法，在前文 [ 最长递增子序列问题 ](https://labuladong.gitee.io/algo/3/23/74/)
中详细介绍了动态规划解法，并用扑克牌游戏解释了二分查找解法，本文就不展开了，直接套用算法模板：

```java
    /* 返回 nums 中 LIS 的长度 */
    public int lengthOfLIS(int[] nums) {
        int piles = 0, n = nums.length;
        int[] top = new int[n];
        for (int i = 0; i < n; i++) {
            // 要处理的扑克牌
            int poker = nums[i];
            int left = 0, right = piles;
            // 二分查找插入位置
            while (left < right) {
                int mid = (left + right) / 2;
                if (top[mid] >= poker)
                    right = mid;
                else
                    left = mid + 1;
            }
            if (left == piles) piles++;
            // 把这张牌放到牌堆顶
            top[left] = poker;
        }
        // 牌堆数就是 LIS 长度
        return piles;
    }

```

为了清晰，我将代码分为了两个函数， 你也可以合并，这样可以节省下 ` height ` 数组的空间。

此算法的时间复杂度为 ` O(NlogN) ` ，因为排序和计算 LIS 各需要 ` O(NlogN) ` 的时间。

空间复杂度为 ` O(N) ` ，因为计算 LIS 的函数中需要一个 ` top ` 数组。

### 三、总结

这个问题是个 Hard 级别的题目，难就难在排序，正确地排序后此问题就被转化成了一个标准的 LIS 问题，容易解决一些。

其实这种问题还可以拓展到三维，比如说现在不是让你嵌套信封，而是嵌套箱子，每个箱子有长宽高三个维度，请你算算最多能嵌套几个箱子？

我们可能会这样想，先把前两个维度（长和宽）按信封嵌套的思路求一个嵌套序列，最后在这个序列的第三个维度（高度）找一下 LIS，应该能算出答案。

实际上，这个思路是错误的。这类问题叫做「偏序问题」，上升到三维会使难度巨幅提升，需要借助一种高级数据结构「树状数组」，有兴趣的读者可以自行搜索。

有很多算法问题都需要排序后进行处理，阿东正在进行整理总结。希望本文对你有帮助。



## 动态规划设计：最大子数组



读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 53. 最大子序和（简单） ](https://leetcode-cn.com/problems/maximum-subarray/)

**———–**

最大子数组问题和前文讲过的 [ 经典动态规划：最长递增子序列 ](https://labuladong.gitee.io/algo/3/23/74/)
的套路非常相似，代表着一类比较特殊的动态规划问题的思路：

![](https://labuladong.gitee.io/algo/images/%e6%9c%80%e5%a4%a7%e5%ad%90%e6%95%b0%e7%bb%84/title.jpg)

### 思路分析

其实第一次看到这道题，我首先想到的是 [ 滑动窗口算法 ](https://labuladong.gitee.io/algo/2/20/56/)
，因为我们前文说过嘛，滑动窗口算法就是专门处理子串/子数组问题的，这里不就是子数组问题么？

但是，稍加分析就发现， **这道题还不能用滑动窗口算法，因为数组中的数字可以是负数** 。

滑动窗口算法无非就是双指针形成的窗口扫描整个数组/子串，但关键是，你得清楚地知道什么时候应该移动右侧指针来扩大窗口，什么时候移动左侧指针来减小窗口。

而对于这道题目，你想想，当窗口扩大的时候可能遇到负数，窗口中的值也就可能增加也可能减少，这种情况下不知道什么时机去收缩左侧窗口，也就无法求出「最大子数组和」。

解决这个问题需要动态规划技巧，但是 ` dp ` 数组的定义比较特殊。按照我们常规的动态规划思路，一般是这样定义 ` dp ` 数组：

**` nums[0..i] ` 中的「最大的子数组和」为 ` dp[i] ` ** 。

如果这样定义的话，整个 ` nums ` 数组的「最大子数组和」就是 ` dp[n-1] ` 。如何找状态转移方程呢？按照数学归纳法，假设我们知道了 `dp[i-1] ` ，如何推导出 ` dp[i] ` 呢？

如下图，按照我们刚才对 ` dp ` 数组的定义， ` dp[i] = 5 ` ，也就是等于 ` nums[0..i] ` 中的最大子数组和：

![](https://labuladong.gitee.io/algo/images/%e6%9c%80%e5%a4%a7%e5%ad%90%e6%95%b0%e7%bb%84/1.jpeg)

那么在上图这种情况中，利用数学归纳法，你能用 ` dp[i] ` 推出 ` dp[i+1] ` 吗？

**实际上是不行的，因为子数组一定是连续的，按照我们当前` dp ` 数组定义，并不能保证 ` nums[0..i] ` 中的最大子数组与 `nums[i+1] ` 是相邻的 ** ，也就没办法从 ` dp[i] ` 推导出 ` dp[i+1] ` 。

所以说我们这样定义 ` dp ` 数组是不正确的，无法得到合适的状态转移方程。对于这类子数组问题，我们就要重新定义 ` dp ` 数组的含义：

**以` nums[i] ` 为结尾的「最大子数组和」为 ` dp[i] ` ** 。

这种定义之下，想得到整个 ` nums ` 数组的「最大子数组和」，不能直接返回 ` dp[n-1] ` ，而需要遍历整个 ` dp ` 数组：

```java
    int res = Integer.MIN_VALUE;
    for (int i = 0; i < n; i++) {
        res = Math.max(res, dp[i]);
    }
    return res;

```

依然使用数学归纳法来找状态转移关系：假设我们已经算出了 ` dp[i-1] ` ，如何推导出 ` dp[i] ` 呢？

可以做到， ` dp[i] ` 有两种「选择」，要么与前面的相邻子数组连接，形成一个和更大的子数组；要么不与前面的子数组连接，自成一派，自己作为一个子数组。

如何选择？既然要求「最大子数组和」，当然选择结果更大的那个啦：

```java
    // 要么自成一派，要么和前面的子数组合并
    dp[i] = Math.max(nums[i], nums[i] + dp[i - 1]);

```

综上，我们已经写出了状态转移方程，就可以直接写出解法了：

```java
    int maxSubArray(int[] nums) {
        int n = nums.length;
        if (n == 0) return 0;
        int[] dp = new int[n];
        // base case
        // 第一个元素前面没有子数组
        dp[0] = nums[0];
        // 状态转移方程
        for (int i = 1; i < n; i++) {
            dp[i] = Math.max(nums[i], nums[i] + dp[i - 1]);
        }
        // 得到 nums 的最大子数组
        int res = Integer.MIN_VALUE;
        for (int i = 0; i < n; i++) {
            res = Math.max(res, dp[i]);
        }
        return res;
    }

```

以上解法时间复杂度是 O(N)，空间复杂度也是 O(N)，较暴力解法已经很优秀了，不过 **注意到` dp[i] ` 仅仅和 ` dp[i-1] `的状态有关 ** ，那么我们可以进行「状态压缩」，将空间复杂度降低：

```java
    int maxSubArray(int[] nums) {
        int n = nums.length;
        if (n == 0) return 0;
        // base case
        int dp_0 = nums[0];
        int dp_1 = 0, res = dp_0;
    
        for (int i = 1; i < n; i++) {
            // dp[i] = max(nums[i], nums[i] + dp[i-1])
            dp_1 = Math.max(nums[i], nums[i] + dp_0);
            dp_0 = dp_1;
            // 顺便计算最大的结果
            res = Math.max(res, dp_1);
        }
        
        return res;
    }

```

### 最后总结

虽然说动态规划推状态转移方程确实比较玄学，但大部分还是有些规律可循的。

今天这道「最大子数组和」就和「最长递增子序列」非常类似， ` dp ` 数组的定义是「以 ` nums[i] ` 为结尾的最大子数组和/最长递增子序列为 `dp[i] ` 」。因为只有这样定义才能将 ` dp[i+1] ` 和 ` dp[i] ` 建立起联系，利用数学归纳法写出状态转移方程。



## 经典动态规划：最长公共子序列



读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 1143. 最长公共子序列（中等） ](https://leetcode-cn.com/problems/longest-common-
subsequence)

[ 583. 两个字符串的删除操作（中等） ](https://leetcode-cn.com/problems/delete-operation-for-
two-strings/)

[ 712. 两个字符串的最小ASCII删除和（中等） ](https://leetcode-cn.com/problems/minimum-ascii-
delete-sum-for-two-strings)

**———–**

好久没写动态规划算法相关的文章了，今天来搞一把。

不知道大家做算法题有什么感觉，
**我总结出来做算法题的技巧就是，把大的问题细化到一个点，先研究在这个小的点上如何解决问题，然后再通过递归/迭代的方式扩展到整个问题** 。

比如说我们前文 [ 手把手带你刷二叉树第三期 ](https://labuladong.gitee.io/algo/2/17/23/)
，解决二叉树的题目，我们就会把整个问题细化到某一个节点上，想象自己站在某个节点上，需要做什么，然后套二叉树递归框架就行了。

动态规划系列问题也是一样，尤其是子序列相关的问题。 **本文从「最长公共子序列问题」展开，总结三道子序列问题**
，解这道题仔细讲讲这种子序列问题的套路，你就能感受到这种思维方式了。

### 最长公共子序列

计算最长公共子序列（Longest Common Subsequence，简称 LCS）是一道经典的动态规划题目，大家应该都见过：

给你输入两个字符串 ` s1 ` 和 ` s2 ` ，请你找出他们俩的最长公共子序列，返回这个子序列的长度。

力扣第 1143 题就是这道题，函数签名如下：

```java
    int longestCommonSubsequence(String s1, String s2);

```

比如说输入 ` s1 = "zabcde", s2 = "acez" ` ，它俩的最长公共子序列是 ` lcs = "ace" ` ，长度为 3，所以算法返回 3。

如果没有做过这道题，一个最简单的暴力算法就是，把 ` s1 ` 和 ` s2 `的所有子序列都穷举出来，然后看看有没有公共的，然后在所有公共子序列里面再寻找一个长度最大的。

显然，这种思路的复杂度非常高，你要穷举出所有子序列，这个复杂度就是指数级的，肯定不实际。

正确的思路是不要考虑整个字符串，而是细化到 ` s1 ` 和 ` s2 ` 的每个字符。前文 [ 子序列解题模板 ](https://labuladong.gitee.io/algo/3/23/78/)
中总结的一个规律：

**＿＿＿＿＿＿＿＿＿＿＿＿＿**

应合作方要求，本文不便在此发布，请扫码关注回复关键词「LCS」查看：

![](https://labuladong.gitee.io/algo/images/qrcode.jpg)

## 动态规划之子序列问题解题模板



读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 516. 最长回文子序列（中等） ](https://leetcode-cn.com/problems/longest-palindromic-
subsequence)

**———–**

子序列问题是常见的算法问题，而且并不好解决。

首先，子序列问题本身就相对子串、子数组更困难一些，因为前者是不连续的序列，而后两者是连续的，就算穷举你都不一定会，更别说求解相关的算法问题了。

而且，子序列问题很可能涉及到两个字符串，比如前文 [ 最长公共子序列 ](https://labuladong.gitee.io/algo/3/23/77/)
，如果没有一定的处理经验，真的不容易想出来。所以本文就来扒一扒子序列问题的套路，其实就有两种模板，相关问题只要往这两种思路上想，十拿九稳。

一般来说，这类问题都是让你求一个 **最长子序列** ，因为最短子序列就是一个字符嘛，没啥可问的。一旦涉及到子序列和最值，那几乎可以肯定，
**考察的是动态规划技巧，时间复杂度一般都是 O(n^2)** 。

原因很简单，你想想一个字符串，它的子序列有多少种可能？起码是指数级的吧，这种情况下，不用动态规划技巧，还想怎么着？

既然要用动态规划，那就要定义 dp 数组，找状态转移关系。我们说的两种思路模板，就是 dp 数组的定义思路。不同的问题可能需要不同的 dp 数组定义来解决。

### 一、两种思路

**＿＿＿＿＿＿＿＿＿＿＿＿＿**

应合作方要求，本文不便在此发布，请扫码关注回复关键词「子序列」查看：

![](https://labuladong.gitee.io/algo/images/qrcode.jpg)

# 背包类型问题



## 经典动态规划：0-1 背包问题



**———–**

本文有视频版： [ 0-1背包问题详解 ](https://www.bilibili.com/video/BV15B4y1P7X7/)

后台天天有人问背包问题，这个问题其实不难啊，如果我们号动态规划系列的十几篇文章你都看过，借助框架，遇到背包问题可以说是手到擒来好吧。无非就是状态 + 选择，也没啥特别之处嘛。

今天就来说一下背包问题吧，就讨论最常说的 0-1 背包问题。描述：

给你一个可装载重量为 ` W ` 的背包和 ` N ` 个物品，每个物品有重量和价值两个属性。其中第 ` i ` 个物品的重量为 ` wt[i] `，价值为 ` val[i] ` ，现在让你用这个背包装物品，最多能装的价值是多少？

![](https://labuladong.gitee.io/algo/images/knapsack/1.png)

举个简单的例子，输入如下：

```java
    N = 3, W = 4
    wt = [2, 1, 3]
    val = [4, 2, 3]

```

算法返回 6，选择前两件物品装进背包，总重量 3 小于 ` W ` ，可以获得最大价值 6。

题目就是这么简单，一个典型的动态规划问题。这个题目中的物品不可以分割，要么装进包里，要么不装，不能说切成两块装一半。这就是 0-1 背包这个名词的来历。

解决这个问题没有什么排序之类巧妙的方法，只能穷举所有可能，根据我们 [ 动态规划详解 ](https://labuladong.gitee.io/algo/3/22/66/) 中的套路，直接走流程就行了。

### 动规标准套路

看来我得每篇动态规划文章都得重复一遍套路，历史文章中的动态规划问题都是按照下面的套路来的。

**第一步要明确两点，「状态」和「选择」** 。

先说状态，如何才能描述一个问题局面？只要给几个物品和一个背包的容量限制，就形成了一个背包问题呀。
**所以状态有两个，就是「背包的容量」和「可选择的物品」** 。

再说选择，也很容易想到啊，对于每件物品，你能选择什么？ **选择就是「装进背包」或者「不装进背包」嘛** 。

明白了状态和选择，动态规划问题基本上就解决了，只要往这个框架套就完事儿了：

```java
    for 状态1 in 状态1的所有取值：
        for 状态2 in 状态2的所有取值：
            for ...
                dp[状态1][状态2][...] = 择优(选择1，选择2...)

```

> PS：此框架出自历史文章 [ 团灭 LeetCode 股票问题 ](https://labuladong.gitee.io/algo/3/25/94/) 。

**第二步要明确` dp ` 数组的定义 ** 。

首先看看刚才找到的「状态」，有两个，也就是说我们需要一个二维 ` dp ` 数组。

` dp[i][w] ` 的定义如下：对于前 ` i ` 个物品，当前背包的容量为 ` w ` ，这种情况下可以装的最大价值是 ` dp[i][w] ` 。

比如说，如果 ` dp[3][5] = 6 ` ，其含义为：对于给定的一系列物品中，若只对前 3 个物品进行选择，当背包容量为 5 时，最多可以装下的价值为 6。

> PS：为什么要这么定义？便于状态转移，或者说这就是套路，记下来就行了。建议看一下我们的动态规划系列文章，几种套路都被扒得清清楚楚了。

根据这个定义，我们想求的最终答案就是 ` dp[N][W] ` 。base case 就是 ` dp[0][..] = dp[..][0] = 0 `，因为没有物品或者背包没有空间的时候，能装的最大价值就是 0。

细化上面的框架：

```java
    int[][] dp[N+1][W+1]
    dp[0][..] = 0
    dp[..][0] = 0
    
    for i in [1..N]:
        for w in [1..W]:
            dp[i][w] = max(
                把物品 i 装进背包,
                不把物品 i 装进背包
            )
    return dp[N][W]

```

**第三步，根据「选择」，思考状态转移的逻辑** 。

简单说就是，上面伪码中「把物品 ` i ` 装进背包」和「不把物品 ` i ` 装进背包」怎么用代码体现出来呢？

这就要结合对 ` dp ` 数组的定义，看看这两种选择会对状态产生什么影响：

先重申一下刚才我们的 ` dp ` 数组的定义：

` dp[i][w] ` 表示：对于前 ` i ` 个物品，当前背包的容量为 ` w ` 时，这种情况下可以装下的最大价值是 ` dp[i][w] ` 。

**如果你没有把这第` i ` 个物品装入背包 ** ，那么很显然，最大价值 ` dp[i][w] ` 应该等于 ` dp[i-1][w] `，继承之前的结果。

**如果你把这第` i ` 个物品装入了背包 ** ，那么 ` dp[i][w] ` 应该等于 ` dp[i-1][w - wt[i-1]] + val[i-1] ` 。

首先，由于 ` i ` 是从 1 开始的，所以 ` val ` 和 ` wt ` 的索引是 ` i-1 ` 时表示第 ` i ` 个物品的价值和重量。

而 ` dp[i-1][w - wt[i-1]] ` 也很好理解：你如果装了第 ` i ` 个物品，就要寻求剩余重量 ` w - wt[i-1] `限制下的最大价值，加上第 ` i ` 个物品的价值 ` val[i-1] ` 。

综上就是两种选择，我们都已经分析完毕，也就是写出来了状态转移方程，可以进一步细化代码：

```java
    for i in [1..N]:
        for w in [1..W]:
            dp[i][w] = max(
                dp[i-1][w],
                dp[i-1][w - wt[i-1]] + val[i-1]
            )
    return dp[N][W]

```

**最后一步，把伪码翻译成代码，处理一些边界情况** 。

我用 C++ 写的代码，把上面的思路完全翻译了一遍，并且处理了 ` w - wt[i-1] ` 可能小于 0 导致数组索引越界的问题：

```java
    int knapsack(int W, int N, vector<int>& wt, vector<int>& val) {
        // base case 已初始化
        vector<vector<int>> dp(N + 1, vector<int>(W + 1, 0));
        for (int i = 1; i <= N; i++) {
            for (int w = 1; w <= W; w++) {
                if (w - wt[i-1] < 0) {
                    // 这种情况下只能选择不装入背包
                    dp[i][w] = dp[i - 1][w];
                } else {
                    // 装入或者不装入背包，择优
                    dp[i][w] = max(dp[i - 1][w - wt[i-1]] + val[i-1], 
                                   dp[i - 1][w]);
                }
            }
        }
        
        return dp[N][W];
    }

```

至此，背包问题就解决了，相比而言，我觉得这是比较简单的动态规划问题，因为状态转移的推导比较自然，基本上你明确了 ` dp `数组的定义，就可以理所当然地确定状态转移了。

接下来可阅读：

* [ 完全背包问题之零钱兑换 ](https://labuladong.gitee.io/algo/3/24/82/)
* [ 背包问题变体之子集分割 ](https://labuladong.gitee.io/algo/3/24/81/)



## 经典动态规划：子集背包问题



读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 416. 分割等和子集（中等） ](https://leetcode-cn.com/problems/partition-equal-subset-
sum)

**———–**

上篇文章 [ 经典动态规划：0-1 背包问题 ](https://labuladong.gitee.io/algo/3/24/80/) 详解了通用的 0-1 背包问题，今天来看看背包问题的思想能够如何运用到其他算法题目。

而且，不是经常有读者问，怎么将二维动态规划压缩成一维动态规划吗？这就是状态压缩，很容易的，本文也会提及这种技巧。

**读者在阅读本文之前务必读懂前文[ 经典动态规划：0-1 背包问题 ](https://labuladong.gitee.io/algo/3/24/80/)
中讲的套路，因为本文就是按照背包问题的解题模板来讲解的 ** 。

### 一、问题分析

先看一下题目：

![](https://labuladong.gitee.io/algo/images/knapsackSubset/title.jpg)

算法的函数签名如下：

```java
    // 输入一个集合，返回是否能够分割成和相等的两个子集
    bool canPartition(vector<int>& nums);

```

对于这个问题，看起来和背包没有任何关系，为什么说它是背包问题呢？

首先回忆一下背包问题大致的描述是什么：

给你一个可装载重量为 ` W ` 的背包和 ` N ` 个物品，每个物品有重量和价值两个属性。其中第 ` i ` 个物品的重量为 ` wt[i] `，价值为 ` val[i] ` ，现在让你用这个背包装物品，最多能装的价值是多少？

那么对于这个问题，我们可以先对集合求和，得出 ` sum ` ，把问题转化为背包问题：

**给一个可装载重量为` sum / 2 ` 的背包和 ` N ` 个物品，每个物品的重量为 ` nums[i] `。现在让你装物品，是否存在一种装法，能够恰好将背包装满 ** ？

你看，这就是背包问题的模型，甚至比我们之前的经典背包问题还要简单一些， **下面我们就直接转换成背包问题** ，开始套前文讲过的背包问题框架即可。

### 二、解法分析

**第一步要明确两点，「状态」和「选择」** 。

这个前文 [ 经典动态规划：背包问题 ](https://labuladong.gitee.io/algo/3/24/80/)
已经详细解释过了，状态就是「背包的容量」和「可选择的物品」，选择就是「装进背包」或者「不装进背包」。

**第二步要明确` dp ` 数组的定义 ** 。

按照背包问题的套路，可以给出如下定义：

` dp[i][j] = x ` 表示，对于前 ` i ` 个物品，当前背包的容量为 ` j ` 时，若 ` x ` 为 ` true `，则说明可以恰好将背包装满，若 ` x ` 为 ` false ` ，则说明不能恰好将背包装满。

比如说，如果 ` dp[4][9] = true ` ，其含义为：对于容量为 9 的背包，若只是用前 4 个物品，可以有一种方法把背包恰好装满。

或者说对于本题，含义是对于给定的集合中，若只对前 4 个数字进行选择，存在一个子集的和可以恰好凑出 9。

根据这个定义，我们想求的最终答案就是 ` dp[N][sum/2] ` ，base case 就是 ` dp[..][0] = true ` 和 `dp[0][..] = false ` ，因为背包没有空间的时候，就相当于装满了，而当没有物品可选择的时候，肯定没办法装满背包。

**第三步，根据「选择」，思考状态转移的逻辑** 。

回想刚才的 ` dp ` 数组含义，可以根据「选择」对 ` dp[i][j] ` 得到以下状态转移：

如果不把 ` nums[i] ` 算入子集， **或者说你不把这第` i ` 个物品装入背包 ** ，那么是否能够恰好装满背包，取决于上一个状态 `dp[i-1][j] ` ，继承之前的结果。

如果把 ` nums[i] ` 算入子集， **或者说你把这第` i ` 个物品装入了背包 ** ，那么是否能够恰好装满背包，取决于状态 `dp[i-1][j-nums[i-1]] ` 。

首先，由于 ` i ` 是从 1 开始的，而数组索引是从 0 开始的，所以第 ` i ` 个物品的重量应该是 ` nums[i-1] ` ，这一点不要搞混。

` dp[i - 1][j-nums[i-1]] ` 也很好理解：你如果装了第 ` i ` 个物品，就要看背包的剩余重量 ` j - nums[i-1] `限制下是否能够被恰好装满。

换句话说，如果 ` j - nums[i-1] ` 的重量可以被恰好装满，那么只要把第 ` i ` 个物品装进去，也可恰好装满 ` j `的重量；否则的话，重量 ` j ` 肯定是装不满的。

**最后一步，把伪码翻译成代码，处理一些边界情况** 。

以下是我的 C++ 代码，完全翻译了之前的思路，并处理了一些边界情况：

```java
    boolean canPartition(int[] nums) {
        int sum = 0;
        for (int num : nums) sum += num;
        // 和为奇数时，不可能划分成两个和相等的集合
        if (sum % 2 != 0) return false;
        int n = nums.length;
        sum = sum / 2;
        boolean[][] dp = new boolean[n + 1][sum + 1];
        // base case
        for (int i = 0; i <= n; i++)
            dp[i][0] = true;
    
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= sum; j++) {
                if (j - nums[i - 1] < 0) {
                    // 背包容量不足，不能装入第 i 个物品
                    dp[i][j] = dp[i - 1][j];
                } else {
                    // 装入或不装入背包
                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]];
                }
            }
        }
        return dp[n][sum];
    }

```

### 三、进行状态压缩

再进一步，是否可以优化这个代码呢？ **注意到` dp[i][j] ` 都是通过上一行 ` dp[i-1][..] ` 转移过来的 **
，之前的数据都不会再使用了。

所以，我们可以进行状态压缩，将二维 ` dp ` 数组压缩为一维，节约空间复杂度：

```java
    boolean canPartition(int[] nums) {
        int sum = 0;
        for (int num : nums) sum += num;
        // 和为奇数时，不可能划分成两个和相等的集合
        if (sum % 2 != 0) return false;
        int n = nums.length;
        sum = sum / 2;
        boolean[] dp = new boolean[sum + 1];
        
        // base case
        dp[0] = true;
    
        for (int i = 0; i < n; i++) {
            for (int j = sum; j >= 0; j--) {
                if (j - nums[i] >= 0) {
                    dp[j] = dp[j] || dp[j - nums[i]];
                }
            }
        }
        return dp[sum];
    }

```

其实这段代码和之前的解法思路完全相同，只在一行 ` dp ` 数组上操作， ` i ` 每进行一轮迭代， ` dp[j] ` 其实就相当于 `dp[i-1][j] ` ，所以只需要一维数组就够用了。

**唯一需要注意的是` j ` 应该从后往前反向遍历，因为每个物品（或者说数字）只能用一次，以免之前的结果影响其他的结果 ** 。

至此，子集切割的问题就完全解决了，时间复杂度 O(n*sum)，空间复杂度 O(sum)。



## 经典动态规划：完全背包问题



读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 518. 零钱兑换II（中等） ](https://leetcode-cn.com/problems/coin-change-2)

**———–**

零钱兑换 2 是另一种典型背包问题的变体，我们前文已经讲了 [ 经典动态规划：0-1 背包问题 ](https://labuladong.gitee.io/algo/3/24/80/) 和 [
背包问题变体：相等子集分割 ](https://labuladong.gitee.io/algo/3/24/81/) 。

**读本文之前，希望你已经看过前两篇文章** ，看过了动态规划和背包问题的套路，这篇继续按照背包问题的套路，列举一个背包问题的变形。

本文聊的是 LeetCode 第 518 题 Coin Change 2，题目如下：

![](https://labuladong.gitee.io/algo/images/knapsackCoin/title.jpg)

```java
    int change(int amount, int[] coins);

```

> PS：至于 Coin Change 1，在我们前文 [ 动态规划套路详解 ](https://labuladong.gitee.io/algo/3/22/66/) 写过。

**我们可以把这个问题转化为背包问题的描述形式** ：

有一个背包，最大容量为 ` amount ` ，有一系列物品 ` coins ` ，每个物品的重量为 ` coins[i] ` ，
**每个物品的数量无限** 。请问有多少种方法，能够把背包恰好装满？

这个问题和我们前面讲过的两个背包问题，有一个最大的区别就是，每个物品的数量是无限的，这也就是传说中的「 **完全背包问题**
」，没啥高大上的，无非就是状态转移方程有一点变化而已。

下面就以背包问题的描述形式，继续按照流程来分析。

### 解题思路

**第一步要明确两点，「状态」和「选择」** 。

状态有两个，就是「背包的容量」和「可选择的物品」，选择就是「装进背包」或者「不装进背包」嘛，背包问题的套路都是这样。

明白了状态和选择，动态规划问题基本上就解决了，只要往这个框架套就完事儿了：

```java
    for 状态1 in 状态1的所有取值：
        for 状态2 in 状态2的所有取值：
            for ...
                dp[状态1][状态2][...] = 计算(选择1，选择2...)

```

**第二步要明确` dp ` 数组的定义 ** 。

首先看看刚才找到的「状态」，有两个，也就是说我们需要一个二维 ` dp ` 数组。

` dp[i][j] ` 的定义如下：

若只使用前 ` i ` 个物品（可以重复使用），当背包容量为 ` j ` 时，有 ` dp[i][j] ` 种方法可以装满背包。

换句话说，翻译回我们题目的意思就是：

**若只使用` coins ` 中的前 ` i ` 个硬币的面值，若想凑出金额 ` j ` ，有 ` dp[i][j] ` 种凑法 ** 。

经过以上的定义，可以得到：

base case 为 ` dp[0][..] = 0， dp[..][0] = 1 `。因为如果不使用任何硬币面值，就无法凑出任何金额；如果凑出的目标金额为 0，那么“无为而治”就是唯一的一种凑法。

我们最终想得到的答案就是 ` dp[N][amount] ` ，其中 ` N ` 为 ` coins ` 数组的大小。

大致的伪码思路如下：

```java
    int dp[N+1][amount+1]
    dp[0][..] = 0
    dp[..][0] = 1
    
    for i in [1..N]:
        for j in [1..amount]:
            把物品 i 装进背包,
            不把物品 i 装进背包
    return dp[N][amount]

```

**第三步，根据「选择」，思考状态转移的逻辑** 。

注意，我们这个问题的特殊点在于物品的数量是无限的，所以这里和之前写的 [ 0-1 背包问题 ](https://labuladong.gitee.io/algo/3/24/80/) 文章有所不同。

**如果你不把这第` i ` 个物品装入背包 ** ，也就是说你不使用 ` coins[i] ` 这个面值的硬币，那么凑出面额 ` j ` 的方法数 `dp[i][j] ` 应该等于 ` dp[i-1][j] ` ，继承之前的结果。

**如果你把这第` i ` 个物品装入了背包 ** ，也就是说你使用 ` coins[i] ` 这个面值的硬币，那么 ` dp[i][j] ` 应该等于 `dp[i][j-coins[i-1]] ` 。

首先由于 ` i ` 是从 1 开始的，所以 ` coins ` 的索引是 ` i-1 ` 时表示第 ` i ` 个硬币的面值。

` dp[i][j-coins[i-1]] ` 也不难理解，如果你决定使用这个面值的硬币，那么就应该关注如何凑出金额 ` j - coins[i-1] `。

比如说，你想用面值为 2 的硬币凑出金额 5，那么如果你知道了凑出金额 3 的方法，再加上一枚面额为 2 的硬币，不就可以凑出 5 了嘛。

**综上就是两种选择，而我们想求的` dp[i][j] ` 是「共有多少种凑法」，所以 ` dp[i][j] ` 的值应该是以上两种选择的结果之和 ** ：

```java
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= amount; j++) {
            if (j - coins[i-1] >= 0)
                dp[i][j] = dp[i - 1][j] 
                         + dp[i][j-coins[i-1]];
    return dp[N][W]

```

> PS：有的读者在这里可能会有疑问，不是说可以重复使用硬币吗？那么如果我确定「使用第 ` i `> 个面值的硬币」，我怎么确定这个面值的硬币被使用了多少枚？简单的一个 ` dp[i][j-coins[i-1]] ` 可以包含重复使用第 ` i `> 个硬币的情况吗？

对于这个问题，建议你再仔回头细阅读一下我们对 ` dp ` 数组的定义，然后把这个定义代入 ` dp[i][j-coins[i-1]] ` 看看：

若只使用前 ` i ` 个物品（可以重复使用），当背包容量为 ` j-coins[i-1] ` 时，有 ` dp[i][j-coins[i-1]] `种方法可以装满背包。

看到了吗， ` dp[i][j-coins[i-1]] ` 也是允许你使用第 ` i ` 个硬币的，所以说已经包含了重复使用硬币的情况，你一百个放心。

**最后一步，把伪码翻译成代码，处理一些边界情况** 。

我用 Java 写的代码，把上面的思路完全翻译了一遍，并且处理了一些边界问题：

```java
    int change(int amount, int[] coins) {
        int n = coins.length;
        int[][] dp = int[n + 1][amount + 1];
        // base case
        for (int i = 0; i <= n; i++) 
            dp[i][0] = 1;
    
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= amount; j++)
                if (j - coins[i-1] >= 0)
                    dp[i][j] = dp[i - 1][j] 
                             + dp[i][j - coins[i-1]];
                else 
                    dp[i][j] = dp[i - 1][j];
        }
        return dp[n][amount];
    }

```

而且，我们通过观察可以发现， ` dp ` 数组的转移只和 ` dp[i][..] ` 和 ` dp[i-1][..] `有关，所以可以压缩状态，进一步降低算法的空间复杂度：

```java
    int change(int amount, int[] coins) {
        int n = coins.length;
        int[] dp = new int[amount + 1];
        dp[0] = 1; // base case
        for (int i = 0; i < n; i++)
            for (int j = 1; j <= amount; j++)
                if (j - coins[i] >= 0)
                    dp[j] = dp[j] + dp[j-coins[i]];
        
        return dp[amount];
    }

```

这个解法和之前的思路完全相同，将二维 ` dp ` 数组压缩为一维，时间复杂度 O(N*amount)，空间复杂度 O(amount)。

至此，这道零钱兑换问题也通过背包问题的框架解决了。

接下来可阅读：

* [ 背包问题变体之子集分割 ](https://labuladong.gitee.io/algo/3/24/81/)



# 用动态规划玩游戏



## 动态规划之最小路径和



读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 64. 最小路径和（中等） ](https://leetcode-cn.com/problems/minimum-path-sum)

**———–**

今天聊一道经典的动态规划题目，最小路径和。

它是力扣第 64 题，我来简单描述一下题目：

现在给你输入一个二维数组 ` grid ` ，其中的元素都是 **非负整数** ，现在你站在左上角， **只能向右或者向下移动**
，需要到达右下角。现在请你计算，经过的路径和最小是多少？

函数签名如下：

```java
    int minPathSum(int[][] grid);

```

比如题目举的例子，输入如下的 ` grid ` 数组：

![](https://labuladong.gitee.io/algo/images/%e6%9c%80%e7%9f%ad%e8%b7%af%e5%be%84%e5%92%8c/titlepic.jpg)

算法应该返回 7，最小路径和为 7，就是上图黄色的路径。

其实这道题难度不算大，但我们刷题群里很多朋友讨论，而且这个问题还有一些难度比较大的变体，所以讲一下这种问题的通用思路。

**一般来说，让你在二维矩阵中求最优化问题（最大值或者最小值），肯定需要递归 + 备忘录，也就是动态规划技巧** 。

就拿题目举的例子来说，我给图中的几个格子编个号方便描述：

![](https://labuladong.gitee.io/algo/images/%e6%9c%80%e7%9f%ad%e8%b7%af%e5%be%84%e5%92%8c/minpath.jpg)

我们想计算从起点 ` D ` 到达 ` B ` 的最小路径和，那你说怎么才能到达 ` B ` 呢？

题目说了只能向右或者向下走，所以只有从 ` A ` 或者 ` C ` 走到 ` B ` 。

那么算法怎么知道从 ` A ` 走到 ` B ` 才能使路径和最小，而不是从 ` C ` 走到 ` B ` 呢？

难道是因为位置 ` A ` 的元素大小是 1，位置 ` C ` 的元素是 2，1 小于 2，所以一定要从 ` A ` 走到 ` B ` 才能使路径和最小吗？

其实不是的， **真正的原因是，从` D ` 走到 ` A ` 的最小路径和是 6，而从 ` D ` 走到 ` C ` 的最小路径和是 8，6 小于 8，所以一定要从 ` A ` 走到 ` B ` 才能使路径和最小 ** 。

换句话说，我们把「从 ` D ` 走到 ` B ` 的最小路径和」这个问题转化成了「从 ` D ` 走到 ` A ` 的最小路径和」和 「从 ` D `走到 ` C ` 的最小路径和」这两个问题。

理解了上面的分析，这不就是状态转移方程吗？所以这个问题肯定会用到动态规划技巧来解决。

比如我们定义如下一个 ` dp ` 函数：

```java
    int dp(int[][] grid, int i, int j);

```

这个 ` dp ` 函数的定义如下：

**从左上角位置` (0, 0) ` 走到位置 ` (i, j) ` 的最小路径和为 ` dp(grid, i, j) ` ** 。

根据这个定义，我们想求的最小路径和就可以通过调用这个 ` dp ` 函数计算出来：

```java
    int minPathSum(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        // 计算从左上角走到右下角的最小路径和
        return dp(grid, m - 1, n - 1);
    }

```

再根据刚才的分析，很容易发现， ` dp(grid, i, j) ` 的值取决于 ` dp(grid, i - 1, j) ` 和 ` dp(grid, i, j - 1) ` 返回的值。

我们可以直接写代码了：

```java
    int dp(int[][] grid, int i, int j) {
        // base case
        if (i == 0 && j == 0) {
            return grid[0][0];
        }
        // 如果索引出界，返回一个很大的值，
        // 保证在取 min 的时候不会被取到
        if (i < 0 || j < 0) {
            return Integer.MAX_VALUE;
        }
    
        // 左边和上面的最小路径和加上 grid[i][j]
        // 就是到达 (i, j) 的最小路径和
        return Math.min(
                dp(grid, i - 1, j), 
                dp(grid, i, j - 1)
            ) + grid[i][j];
    }

```

上述代码逻辑已经完整了，接下来就分析一下，这个递归算法是否存在重叠子问题？是否需要用备忘录优化一下执行效率？

**前文多次说过判断重叠子问题的技巧，首先抽象出上述代码的递归框架** ：

```java
    int dp(int i, int j) {
        dp(i - 1, j); // #1
        dp(i, j - 1); // #2
    }

```

如果我想从 ` dp(i, j) ` 递归到 ` dp(i-1, j-1) ` ，有几种不同的递归调用路径？

可以是 ` dp(i, j) -> #1 -> #2 ` 或者 ` dp(i, j) -> #2 -> #1 ` ，不止一种，说明 ` dp(i-1, j-1) ` 会被多次计算，所以一定存在重叠子问题。

那么我们可以使用备忘录技巧进行优化：

```java
    int[][] memo;
    
    int minPathSum(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        // 构造备忘录，初始值全部设为 -1
        memo = new int[m][n];
        for (int[] row : memo)
            Arrays.fill(row, -1);
        
        return dp(grid, m - 1, n - 1);
    }
    
    int dp(int[][] grid, int i, int j) {
        // base case
        if (i == 0 && j == 0) {
            return grid[0][0];
        }
        if (i < 0 || j < 0) {
            return Integer.MAX_VALUE;
        }
        // 避免重复计算
        if (memo[i][j] != -1) {
            return memo[i][j];
        }
        // 将计算结果记入备忘录
        memo[i][j] = Math.min(
            dp(grid, i - 1, j),
            dp(grid, i, j - 1)
        ) + grid[i][j];
    
        return memo[i][j];
    }

```

至此，本题就算是解决了，时间复杂度和空间复杂度都是 ` O(MN) ` ，标准的自顶向下动态规划解法。

有的读者可能问，能不能用自底向上的迭代解法来做这道题呢？完全可以的。

首先，类似刚才的 ` dp ` 函数，我们需要一个二维 ` dp ` 数组，定义如下：

**从左上角位置` (0, 0) ` 走到位置 ` (i, j) ` 的最小路径和为 ` dp[i][j] ` ** 。

状态转移方程当然不会变的， ` dp[i][j] ` 依然取决于 ` dp[i-1][j] ` 和 ` dp[i][j-1] ` ，直接看代码吧：

```java
    int minPathSum(int[][] grid) {
            int m = grid.length;
            int n = grid[0].length;
            int[][] dp = new int[m][n];
    
            /**** base case ****/
            dp[0][0] = grid[0][0];
    
            for (int i = 1; i < m; i++)
                dp[i][0] = dp[i - 1][0] + grid[i][0];
            
            for (int j = 1; j < n; j++)
                dp[0][j] = dp[0][j - 1] + grid[0][j];        
            /*******************/
            
            // 状态转移
            for (int i = 1; i < m; i++) {
                for (int j = 1; j < n; j++) {
                    dp[i][j] = Math.min(
                        dp[i - 1][j],
                        dp[i][j - 1]
                    ) + grid[i][j];
                }
            }
    
            return dp[m - 1][n - 1];
        }

```

**这个解法的 base case 看起来和递归解法略有不同，但实际上是一样的** 。

因为状态转移为下面这段代码：

```java
    dp[i][j] = Math.min(
        dp[i - 1][j],
        dp[i][j - 1]
    ) + grid[i][j];

```

那如果 ` i ` 或者 ` j ` 等于 0 的时候，就会出现索引越界的错误。

所以我们需要提前计算出 ` dp[0][..] ` 和 ` dp[..][0] ` ，然后让 ` i ` 和 ` j ` 的值从 1 开始迭代。

` dp[0][..] ` 和 ` dp[..][0] ` 的值怎么算呢？其实很简单，第一行和第一列的路径和只有下面这一种情况嘛：

![](https://labuladong.gitee.io/algo/images/%e6%9c%80%e7%9f%ad%e8%b7%af%e5%be%84%e5%92%8c/1.jpeg)

那么按照 ` dp ` 数组的定义， ` dp[i][0] = sum(grid[0..i][0]), dp[0][j] = sum(grid[0][0..j]) ` ，也就是如下代码：

```java
    /**** base case ****/
    dp[0][0] = grid[0][0];
    
    for (int i = 1; i < m; i++)
        dp[i][0] = dp[i - 1][0] + grid[i][0];
    
    for (int j = 1; j < n; j++)
        dp[0][j] = dp[0][j - 1] + grid[0][j];        
    /*******************/

```

到这里，自底向上的迭代解法也搞定了，那有的读者可能又要问了，能不能优化一下算法的空间复杂度呢？

前文 [ 动态规划的降维打击：状态压缩 ](https://labuladong.gitee.io/algo/3/22/70/) 说过降低 ` dp `数组的技巧，这里也是适用的，不过略微复杂些，本文由于篇幅所限就不写了，有兴趣的读者可以自己尝试一下。

本文到此结束，下篇文章写一道进阶题目，更加巧妙和有趣，敬请期待~



## 动态规划帮我通关了《魔塔》



读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 174. 地下城游戏（困难） ](https://leetcode-cn.com/problems/dungeon-game)

**———–**

「魔塔」是一款经典的地牢类游戏，碰怪物要掉血，吃血瓶能加血，你要收集钥匙，一层一层上楼，最后救出美丽的公主。

现在手机上仍然可以玩这个游戏：

![](https://labuladong.gitee.io/algo/images/%e5%9c%b0%e4%b8%8b%e5%9f%8e/0.png)

嗯，相信这款游戏承包了不少人的童年回忆，记得小时候，一个人拿着游戏机玩，两三个人围在左右指手画脚，这导致玩游戏的人体验极差，而左右的人异常快乐 😂

力扣第 174 题是一道类似的题目，我简单描述一下：

输入一个存储着整数的二维数组 ` grid ` ，如果 ` grid[i][j] > 0 ` ，说明这个格子装着血瓶，经过它可以增加对应的生命值；如果 `grid[i][j] == 0 ` ，则这是一个空格子，经过它不会发生任何事情；如果 ` grid[i][j] < 0 `，说明这个格子有怪物，经过它会损失对应的生命值。

现在你是一名骑士，将会出现在最上角，公主被困在最右下角，你只能向右和向下移动，请问你初始至少需要多少生命值才能成功救出公主？

**换句话说，就是问你至少需要多少初始生命值，能够让骑士从最左上角移动到最右下角，且任何时候生命值都要大于 0** 。

函数签名如下：

```java
    int calculateMinimumHP(int[][] grid);

```

比如题目给我们举的例子，输入如下一个二维数组 ` grid ` ，用 ` K ` 表示骑士，用 ` P ` 表示公主：

![](https://labuladong.gitee.io/algo/images/%e5%9c%b0%e4%b8%8b%e5%9f%8e/1.png)

算法应该返回 7，也就是说骑士的初始生命值 **至少** 为 7 时才能成功救出公主，行进路线如图中的箭头所示。

上篇文章 [ 最小路径和 ](https://labuladong.gitee.io/algo/3/25/84/) 写过类似的问题，问你从左上角到右下角的最小路径和是多少。

我们做算法题一定要尝试举一反三，感觉今天这道题和最小路径和有点关系对吧？

想要最小化骑士的初始生命值，是不是意味着要最大化骑士行进路线上的血瓶？是不是相当于求「最大路径和」？是不是可以直接套用计算「最小路径和」的思路？

但是稍加思考，发现这个推论并不成立，吃到最多的血瓶，并不一定就能获得最小的初始生命值。

比如如下这种情况，如果想要吃到最多的血瓶获得「最大路径和」，应该按照下图箭头所示的路径，初始生命值需要 11：

![](https://labuladong.gitee.io/algo/images/%e5%9c%b0%e4%b8%8b%e5%9f%8e/2.png)

但也很容易看到，正确的答案应该是下图箭头所示的路径，初始生命值只需要 1：

![](https://labuladong.gitee.io/algo/images/%e5%9c%b0%e4%b8%8b%e5%9f%8e/3.png)

**所以，关键不在于吃最多的血瓶，而是在于如何损失最少的生命值** 。

这类求最值的问题，肯定要借助动态规划技巧，要合理设计 ` dp ` 数组/函数的定义。类比前文 [ 最小路径和问题 ](https://labuladong.gitee.io/algo/3/25/84/)
， ` dp ` 函数签名肯定长这样：

```java
    int dp(int[][] grid, int i, int j);

```

但是这道题对 ` dp ` 函数的定义比较有意思，按照常理，这个 ` dp ` 函数的定义应该是：

**从左上角（` grid[0][0] ` ）走到 ` grid[i][j] ` 至少需要 ` dp(grid, i, j) ` 的生命值 ** 。

这样定义的话，base case 就是 ` i, j ` 都等于 0 的时候，我们可以这样写代码：

```java
    int calculateMinimumHP(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        // 我们想计算左上角到右下角所需的最小生命值
        return dp(grid, m - 1, n - 1);
    }
    
    int dp(int[][] grid, int i, int j) {
        // base case
        if (i == 0 && j == 0) {
            // 保证骑士落地不死就行了
            return gird[i][j] > 0 ? 1 : -grid[i][j] + 1;
        }
        ...
    }

```

> **PS：为了简洁，之后` dp(grid, i, j) ` 就简写为 ` dp(i, j) ` ，大家理解就好 ** 。

接下来我们需要找状态转移了，还记得如何找状态转移方程吗？我们这样定义 ` dp ` 函数能否正确进行状态转移呢？

我们希望 ` dp(i, j) ` 能够通过 ` dp(i-1, j) ` 和 ` dp(i, j-1) ` 推导出来，这样就能不断逼近 base case，也就能够正确进行状态转移。

具体来说，「到达 ` A ` 的最小生命值」应该能够由「到达 ` B ` 的最小生命值」和「到达 ` C ` 的最小生命值」推导出来：

![](https://labuladong.gitee.io/algo/images/%e5%9c%b0%e4%b8%8b%e5%9f%8e/4.png)

**但问题是，能推出来么？实际上是不能的** 。

因为按照 ` dp ` 函数的定义，你只知道「能够从左上角到达 ` B ` 的最小生命值」，但并不知道「到达 ` B ` 时的生命值」。

「到达 ` B ` 时的生命值」是进行状态转移的必要参考，我给你举个例子你就明白了，假设下图这种情况：

![](https://labuladong.gitee.io/algo/images/%e5%9c%b0%e4%b8%8b%e5%9f%8e/5.png)

你说这种情况下，骑士救公主的最优路线是什么？

显然是按照图中蓝色的线走到 ` B ` ，最后走到 ` A ` 对吧，这样初始血量只需要 1 就可以；如果走黄色箭头这条路，先走到 ` C ` 然后走到 `A ` ，初始血量至少需要 6。

为什么会这样呢？骑士走到 ` B ` 和 ` C ` 的最少初始血量都是 1，为什么最后是从 ` B ` 走到 ` A ` ，而不是从 ` C ` 走到 `A ` 呢？

因为骑士走到 ` B ` 的时候生命值为 11，而走到 ` C ` 的时候生命值依然是 1。

如果骑士执意要通过 ` C ` 走到 ` A ` ，那么初始血量必须加到 6 点才行；而如果通过 ` B ` 走到 ` A ` ，初始血量为 1 就够了，因为路上吃到血瓶了，生命值足够抗 ` A ` 上面怪物的伤害。

这下应该说的很清楚了，再回顾我们对 ` dp ` 函数的定义，上图的情况，算法只知道 ` dp(1, 2) = dp(2, 1) = 1 `，都是一样的，怎么做出正确的决策，计算出 ` dp(2, 2) ` 呢？

**所以说，我们之前对` dp ` 数组的定义是错误的，信息量不足，算法无法做出正确的状态转移 ** 。

正确的做法需要反向思考，依然是如下的 ` dp ` 函数：

```java
    int dp(int[][] grid, int i, int j);

```

但是我们要修改 ` dp ` 函数的定义：

**从` grid[i][j] ` 到达终点（右下角）所需的最少生命值是 ` dp(grid, i, j) ` ** 。

那么可以这样写代码：

```java
    int calculateMinimumHP(int[][] grid) {
        // 我们想计算左上角到右下角所需的最小生命值
        return dp(grid, 0, 0);
    }
    
    int dp(int[][] grid, int i, int j) {
        int m = grid.length;
        int n = grid[0].length;
        // base case
        if (i == m - 1 && j == n - 1) {
            return grid[i][j] >= 0 ? 1 : -grid[i][j] + 1;
        }
        ...
    }

```

根据新的 ` dp ` 函数定义和 base case，我们想求 ` dp(0, 0) ` ，那就应该试图通过 ` dp(i, j+1) ` 和 `dp(i+1, j) ` 推导出 ` dp(i, j) ` ，这样才能不断逼近 base case，正确进行状态转移。

具体来说，「从 ` A ` 到达右下角的最少生命值」应该由「从 ` B ` 到达右下角的最少生命值」和「从 ` C ` 到达右下角的最少生命值」推导出来：

![](https://labuladong.gitee.io/algo/images/%e5%9c%b0%e4%b8%8b%e5%9f%8e/6.png)

能不能推导出来呢？这次是可以的，假设 ` dp(0, 1) = 5, dp(1, 0) = 4 ` ，那么可以肯定要从 ` A ` 走向 ` C ` ，因为 4 小于 5 嘛。

那么怎么推出 ` dp(0, 0) ` 是多少呢？

假设 ` A ` 的值为 1，既然知道下一步要往 ` C ` 走，且 ` dp(1, 0) = 4 ` 意味着走到 ` grid[1][0] `的时候至少要有 4 点生命值，那么就可以确定骑士出现在 ` A ` 点时需要 4 - 1 = 3 点初始生命值，对吧。

那如果 ` A ` 的值为 10，落地就能捡到一个大血瓶，超出了后续需求，4 - 10 = -6 意味着骑士的初始生命值为负数，这显然不可以，骑士的生命值小于 1 就挂了，所以这种情况下骑士的初始生命值应该是 1。

综上，状态转移方程已经推出来了：

```java
    int res = min(
        dp(i + 1, j),
        dp(i, j + 1)
    ) - grid[i][j];
    
    dp(i, j) = res <= 0 ? 1 : res;

```

根据这个核心逻辑，加一个备忘录消除重叠子问题，就可以直接写出最终的代码了：

```java
    /* 主函数 */
    int calculateMinimumHP(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        // 备忘录中都初始化为 -1
        memo = new int[m][n];
        for (int[] row : memo) {
            Arrays.fill(row, -1);
        }
    
        return dp(grid, 0, 0);
    }
    
    // 备忘录，消除重叠子问题
    int[][] memo;
    
    /* 定义：从 (i, j) 到达右下角，需要的初始血量至少是多少 */
    int dp(int[][] grid, int i, int j) {
        int m = grid.length;
        int n = grid[0].length;
        // base case
        if (i == m - 1 && j == n - 1) {
            return grid[i][j] >= 0 ? 1 : -grid[i][j] + 1;
        }
        if (i == m || j == n) {
            return Integer.MAX_VALUE;
        }
        // 避免重复计算
        if (memo[i][j] != -1) {
            return memo[i][j];
        }
        // 状态转移逻辑
        int res = Math.min(
                dp(grid, i, j + 1),
                dp(grid, i + 1, j)
            ) - grid[i][j];
        // 骑士的生命值至少为 1
        memo[i][j] = res <= 0 ? 1 : res;
    
        return memo[i][j];
    }

```

这就是自顶向下带备忘录的动态规划解法，参考前文 [ 动态规划套路详解 ](https://labuladong.gitee.io/algo/3/22/66/) 很容易就可以改写成 ` dp `数组的迭代解法，这里就不写了，读者可以尝试自己写一写。

这道题的核心是定义 ` dp ` 函数，找到正确的状态转移方程，从而计算出正确的答案。



## 动态规划帮我通关了《辐射4》



读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 514. 自由之路（困难） ](https://leetcode-cn.com/problems/freedom-trail/)

**———–**

本文的封面图是一款叫做《辐射4》的游戏中的一个任务剧情画面：

![](https://labuladong.gitee.io/algo/images/%e8%bd%ac%e7%9b%98/1.jpg)

这个可以转动的圆盘类似是一个密码机关，中间偏上的位置有个红色的指针看到没，你只要转动圆盘可以让指针指向不同的字母，然后再按下中间的按钮就可以输入指针指向的字母。

只要转动圆环，让指针依次指向 R、A、I、L、R、O、A、D 并依次按下按钮，就可以触发机关，打开旁边的门。

至于密码为什么是这几个字母，在游戏中的剧情有暗示，这里就不多说了。

那么这个游戏场景和动态规划有什么关系呢？

**我们来没事儿找事儿地想一想，拨动圆盘输入这些字母还挺麻烦的，按照什么顺序才能使得拨动圆盘所需的操作次数最少呢** ？

拨动圆盘的不同方法所需的操作次数肯定是不同的。

比如说你想把一个字母对准到指针上，你可以顺时针转圆盘，也可以逆时针转圆盘；而且某些字母可能不止出现一次，比如上图中大写字母 O 就在圆盘的不同位置出现了三次，你到时候应该拨哪个 O 才能使得整体的操作次数最少呢？

我们之前也多次说过，遇到求最值的问题，基本都是由动态规划算法来解决，因为动态规划本身就是运筹优化算法的一种嘛。

力扣上就有一道这个转盘游戏的算法题，难度还是 Hard，但我当时看了一眼就做出来了，因为我以前思考过生活中一个非常有意思的例子可以类比到这个问题，下面来简单介绍一下。

关注了我的视频号的朋友，知道我弹过李斯特和肖邦的几首钢琴曲，但是没练过钢琴的读者可能不知道，练习钢琴曲谱是需要提前确定「指法」的。

五线谱的音符七上八下的，两个手的手指必须互相配合，也就是说你必须确定好每个音符用哪只手的哪个手指来弹奏，写到谱子上。

比如说我很喜欢的一首曲子叫做《爱之梦》，这是我的谱子：

![](https://labuladong.gitee.io/algo/images/%e8%bd%ac%e7%9b%98/2.jpg)

音符上的数字 1 代表用大拇指，2 代表用食指，以此类推。按照确定下来的指法不断练习，形成肌肉记忆，就算是练会一首曲子了。

指法这东西因人而异，比如手大的人可以让中指跨到大拇指的左边，手小的人可能就有些别扭，那同一段谱子对应的指法可能就不一样。

**那么问题来了，我应该如何设计指法，才能最小化手指切换的「别扭程度」，也就是最大化演奏的流畅度呢** ？

这里我就借助了动态规划算法技巧：手指的切换不就是状态的转移么？参考前文 [ 动态规划套路详解 ](https://labuladong.gitee.io/algo/3/22/66/)
，只要明确「状态」和「选择」就可以解决这个问题。

**状态是什么？状态就是「下一个需要弹奏的音符」和「当前的手的状态」** 。

下一个需要弹奏的音符，无非就是钢琴上 88 个琴键中的一个；手的状态也很简单，五个手指头，每个手指头要么按下去了要么没按下去，2 的 5 次方 32 种情况，5 个二进制位就可以表示。

**选择是什么？选择就是「下一个音符应该由哪个手指头来弹」** ，无非就是穷举五个手指头。

当然，结合当前手的状态，做出每个选择需要对应代价的，刚才说过这个代价是因人而异的，所以我需要给自己定制一个损失函数，计算不同指法切换的「别扭程度」。

现在的问题就变成了一个标准的动态规划问题，根据损失函数做出「别扭程度」最小的选择，使得整段演奏最流畅……

当然，最后这个算法时间复杂度太高了，我们刚才分析的只是单个的音符，但如果串成曲子，时空复杂度还得再乘曲子的音符数，很大。

而且，这个损失函数很难量化，钢琴的黑白键命中难度不同，而且「别扭程度」只能靠感觉，有点不严谨……

不过，本就没必要计算整首曲子的指法，只需要计算某些复杂段落的指法即可，这个算法还是比较有效的。

扯了这么多题外话终于要步入正题了，今天要讲的力扣第 514 题「自由之路」和钢琴指法问题有异曲同工之妙，如果你能理解钢琴的例子，相信你也能很快做出这道算法题。

题目给你输入一个字符串 ` ring ` 代表圆盘上的字符（指针位置在 12 点钟方向，初始指向 ` ring[0] ` ），再输入一个字符串 ` key
` 代表你需要拨动圆盘输入的字符串，你的算法需要返回输入这个 ` key ` 至少进行多少次操作（拨动一格圆盘和按下圆盘中间的按钮都算是一次操作）。

函数签名如下：

```java
    int findRotateSteps(string ring, string key);

```

比如题目举的例子，输入 ` ring = "godding", key = "gd" `，对应的圆盘如下（大写只是为了清晰，实际上输入的字符串都是小写字母）：

![](https://labuladong.gitee.io/algo/images/%e8%bd%ac%e7%9b%98/3.jpg)

我们需要输入 ` key = "gd" ` ，算法返回 4。

因为现在指针指的字母就是字母 ` "g" ` ，所以可以直接按下中间的按钮，然后再将圆盘逆时针拨动两格，让指针指向字母 ` "d" `，然后再按一次中间的按钮。

上述过程，按了两次按钮，拨了两格转盘，总共操作了 4 次，是最少的操作次数，所以算法应该返回 4。

我们这里可以首先给题目做一个等价，转动圆盘是不是就等于拨动指针？

**原题可以转化为：圆盘固定，我们可以拨动指针；现在需要我们拨动指针并按下按钮，以最少的操作次数输入` key ` 对应的字符串 ** 。

那么，这个问题如何使用动态规划的技巧解决呢？或者说，这道题的「状态」和「选择」是什么呢？

**「状态」就是「当前需要输入的字符」和「当前圆盘指针的位置」** 。

再具体点，「状态」就是 ` i ` 和 ` j ` 两个变量。我们可以用 ` i ` 表示当前圆盘上指针指向的字符（也就是 ` ring[i] ` ）；用
` j ` 表示需要输入的字符（也就是 ` key[j] ` ）。

这样我们可以写这样一个 ` dp ` 函数：

```java
    int dp(string& ring, int i, string& key, int j);

```

这个 ` dp ` 函数的定义如下：

**当圆盘指针指向` ring[i] ` 时，输入字符串 ` key[j..] ` 至少需要 ` dp(ring, i, key, j) ` 次操作 **
。

根据这个定义，题目其实就是想计算 ` dp(ring, 0, key, 0) ` 的值，而且我们可以把 ` dp ` 函数的 base case 写出来：

```java
    int dp(string& ring, int i, string& key, int j) {
        // base case，完成输入
        if (j == key.size()) return 0;
        // ...
    }

```

接下来，思考一下如何根据状态做选择，如何进行状态转移？

**「选择」就是「如何拨动指针得到待输入的字符」** 。

再具体点就是，对于现在想输入的字符 ` key[j] ` ，我们可以如何拨动圆盘，得到这个字符？

比如说输入 ` ring = "gdonidg" ` ，现在圆盘的状态如下图：

![](https://labuladong.gitee.io/algo/images/%e8%bd%ac%e7%9b%98/4.jpeg)

假设我想输入的字符 ` key[j] = "d" ` ，圆盘中有两个字母 ` "d" `，而且我可以顺时针也可以逆时针拨动指针，所以总共有四种「选择」输入字符 ` "d" ` ，我们需要选择操作次数最少的那个拨法。

大致的代码逻辑如下：

```java
    int dp(string& ring, int i, string& key, int j) {
        // base case 完成输入
        if (j == key.size()) return 0;
        
        // 做选择
        int res = INT_MAX;
        for (int k : [字符 key[j] 在 ring 中的所有索引]) {
            res = min(
                把 i 顺时针转到 k 的代价,
                把 i 逆时针转到 k 的代价
            );
        }
        
        return res;
    }

```

至于到底是顺时针还是逆时针，其实非常好判断，怎么近就怎么来；但是对于圆盘中的两个字符 ` "d" ` ，还能是怎么近怎么来吗？

不能，因为这和 ` key[i] ` 之后需要输入的字符有关，还是上面的例子：

![](https://labuladong.gitee.io/algo/images/%e8%bd%ac%e7%9b%98/4.jpeg)

如果输入的是 ` key = "di" ` ，那么即便右边的 ` "d" ` 离得近，也应该去左边的 ` "d" ` ，因为左边的 ` "d" ` 旁边就是
` "i" ` ，「整体」的操作数最少。

那么，应该如何判断呢？其实就是穷举，递归调用 ` dp ` 函数，把两种选择的「整体」代价算出来，然后再做比较就行了。

讲到这就差不多了，直接看代码吧：

```java
    // 字符 -> 索引列表
    unordered_map<char, vector<int>> charToIndex;
    // 备忘录
    vector<vector<int>> memo;
    
    /* 主函数 */
    int findRotateSteps(string ring, string key) {
        int m = ring.size();
        int n = key.size();
        // 备忘录全部初始化为 0
        memo.resize(m, vector<int>(n, 0));
        // 记录圆环上字符到索引的映射
        for (int i = 0; i < ring.size(); i++) {
            charToIndex[ring[i]].push_back(i);
        }
        // 圆盘指针最初指向 12 点钟方向，
        // 从第一个字符开始输入 key
        return dp(ring, 0, key, 0);
    }
    
    // 计算圆盘指针在 ring[i]，输入 key[j..] 的最少操作数
    int dp(string& ring, int i, string& key, int j) {
        // base case 完成输入
        if (j == key.size()) return 0;
        // 查找备忘录，避免重叠子问题
        if (memo[i][j] != 0) return memo[i][j];
        
        int n = ring.size();
        // 做选择
        int res = INT_MAX;
        // ring 上可能有多个字符 key[j]
        for (int k : charToIndex[key[j]]) {
            // 拨动指针的次数
            int delta = abs(k - i);
            // 选择顺时针还是逆时针
            delta = min(delta, n - delta);
            // 将指针拨到 ring[k]，继续输入 key[j+1..]
            int subProblem = dp(ring, k, key, j + 1);
            // 选择「整体」操作次数最少的
            // 加一是因为按动按钮也是一次操作
            res = min(res, 1 + delta + subProblem);
        }
        // 将结果存入备忘录
        memo[i][j] = res;
        return res;
    }

```

这段代码是 C++ 写的，因为我觉得涉及字符串的算法 C++ 更方便一些，这里说一些语言相关的细节问题：

1、 ` unordered_map ` 就是哈希表，当访问不存在的键时，会自动创建对应的值，所以可以直接 ` push_back `而不用担心空指针错误。

2、 ` min ` 函数的参数都是 int 型，所以必须先用一个 int 型变量 ` n ` 存储 ` ring.size() ` ，然后调用 `min(delta, n - delta) ` ，否则会报错。

至此，这道题就解决了。



## 旅游省钱大法：加权最短路径



读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 787. K 站中转内最便宜的航班（中等） ](https://leetcode-cn.com/problems/cheapest-flights-
within-k-stops/)

**———–**

毕业季，对过去也许有些欢乐和感伤，对未来也许有些迷茫和向往，不过这些终究是过眼云烟，迟早会被时间淡化和遗忘。

在这段美好时光的末尾，确实应该来一场说走就走的毕业旅行，放肆一把，给青春画上一个完美的句号。

那么，本文就教给你一个动态规划算法， ~~在毕业旅行中省钱~~ 节约追求诗和远方的资本。

![](https://labuladong.gitee.io/algo/images/%e6%97%85%e8%a1%8c%e6%9c%80%e7%9f%ad%e8%b7%af%e5%be%84/6.png)

假设，你准备从学校所在的城市出发，游历多个城市，一路浪到公司入职，那么你应该如何安排旅游路线，才能最小化机票的开销？

我们来看看力扣第 787 题「K 站中转内最便宜的航班」，我描述一下题目：

现在有 ` n ` 个城市，分别用 ` 0 ` , ` 1 ` …, ` n - 1 ` 这些序号表示，城市之间的航线用三元组 ` [from, to, price] ` 来表示，比如说三元组 ` [0,1,100] `就表示，从城市 ` 0 ` 到城市 ` 1 ` 之间的机票价格是 100 元。

题目会给你输入若干参数：正整数 ` n ` 代表城市个数，数组 ` flights ` 装着若干三元组代表城市间的航线及价格，城市编号 ` src `代表你所在的城市，城市编号 ` dst ` 代表你要去的目标城市，整数 ` K ` 代表你最多经过的中转站个数。

函数签名如下：

```java
    int findCheapestPrice(int n, int[][] flights, int src, int dst, int K);

```

请你的算法计算，在 ` K ` 次中转之内，从 ` src ` 到 ` dst ` 所需的最小花费是多少钱，如果无法到达，则返回 -1。

比方说题目给的例子：

` n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, K = 1 `
航线就是如下这张图所示，有向边代表航向的方向，边上的数字代表航线的机票价格：

![](https://labuladong.gitee.io/algo/images/%e6%97%85%e8%a1%8c%e6%9c%80%e7%9f%ad%e8%b7%af%e5%be%84/7.png)

出发点是 ` 0 ` ，到达点是 ` 2 ` ，允许的最大中转次数 ` K ` 为 1，所以最小的开销就是图中红色的两条边，从 ` 0 `出发，经过中转城市 ` 1 ` 到达目标城市 ` 2 ` ，所以算法的返回值应该是 200。

注意这个中转次数的上限 ` K ` 是比较棘手的，如果上述题目将 ` K ` 改为 0，也就是不允许中转，那么我们的算法只能返回 500 了，也就是直接从
` 0 ` 飞到 ` 2 ` 。

**很明显，这题就是个加权有向图中求最短路径的问题** 。

说白了，就是给你一幅加权有向图，让你求 ` src ` 到 ` dst ` 权重最小的一条路径，同时要满足， **这条路径最多不能超过` K + 1 `条边 ** （经过 ` K ` 个节点相当于经过 ` K + 1 ` 条边）。

我们来分析下求最短路径相关的算法。

### BFS 算法思路

我们前文 [ BFS 算法框架详解 ](https://labuladong.gitee.io/algo/4/28/110/) 中说到，求最短路径，肯定可以用 BFS 算法来解决。

因为 BFS 算法相当于从起始点开始，一步一步向外扩散，那当然是离起点越近的节点越先被遍历到，如果 BFS 遍历的过程中遇到终点，那么走的肯定是最短路径。

不过呢，我们在 [ BFS 算法框架详解 ](https://labuladong.gitee.io/algo/4/28/110/) 用的是普通的队列 ` Queue `来遍历多叉树，而对于加权图的最短路径来说，普通的队列不管用了，得用优先级队列 ` PriorityQueue ` 。

为什么呢？也好理解，在多叉树（或者扩展到无权图）的遍历中，与其说边没有权重，不如说每条边的权重都是 1，起点与终点之间的路径权重就是它们之间「边」的条数。

这样，按照 BFS 算法一步步向四周扩散的逻辑，先遍历到的节点和起点之间的「边」更少，累计的权重当然少。

换言之，先进入 ` Queue ` 的节点就是离起点近的，路径权重小的节点。

但对于加权图，路径中边的条数和路径的权重并不是正相关的关系了，有的路径可能边的条数很少，但每条边的权重都很大，那显然这条路径权重也会很大，很难成为最短路径。

比如题目给的这个例子：

![](https://labuladong.gitee.io/algo/images/%e6%97%85%e8%a1%8c%e6%9c%80%e7%9f%ad%e8%b7%af%e5%be%84/7.png)

你是可以一步从 ` 0 ` 走到 ` 2 ` ，但路径权重不见得是最小的。

所以，对于加权图的场景，我们需要优先级队列「自动排序」的特性，将路径权重较小的节点排在队列前面，以此为基础施展 BFS 算法，也就变成了 [
Dijkstra 算法 ](https://labuladong.gitee.io/algo/2/18/41/) 。

说了这么多 BFS 算法思路，只是帮助大家融会贯通一下，我们本文准备用动态规划来解决这道题，因为我们公众号好久没有写动态规划相关的算法了，关于 Dijkstra 算法的实现代码，文末有写，供读者参考。

### 动态规划思路

我们前文 [ 动态规划核心套路详解 ](https://labuladong.gitee.io/algo/3/22/66/) 中说过，求最值的问题，很多都可能使用动态规划来求解。

加权最短路径问题，再加个 ` K ` 的限制也无妨，不也是个求最值的问题嘛，动态规划统统拿下。

我们先不管 ` K ` 的限制，但就「加权最短路径」这个问题来看看，它怎么就是个动态规划问题了呢？

比方说，现在我想计算 ` src ` 到 ` dst ` 的最短路径：

![](https://labuladong.gitee.io/algo/images/%e6%97%85%e8%a1%8c%e6%9c%80%e7%9f%ad%e8%b7%af%e5%be%84/1.jpeg)

最小权重是多少？我不知道。

但我可以把问题进行分解：

![](https://labuladong.gitee.io/algo/images/%e6%97%85%e8%a1%8c%e6%9c%80%e7%9f%ad%e8%b7%af%e5%be%84/2.jpeg)

` s1, s2 ` 是指向 ` dst ` 的相邻节点，它们之间的权重我是知道的，分别是 ` w1, w2 ` 。

只要我知道了从 ` src ` 到 ` s1, s2 ` 的最短路径，我不就知道 ` src ` 到 ` dst ` 的最短路径了吗！

```java
    minPath(src, dst) = min(
        minPath(src, s1) + w1, 
        minPath(src, s2) + w2
    )

```

这其实就是递归关系了，就是这么简单。

**不过别忘了，题目对我们的最短路径还有个「路径上不能超过` K + 1 ` 条边」的限制 ** 。

那么我们不妨定义这样一个 ` dp ` 函数：

```java
    int dp(int s, int k);

```

函数的定义如下：

**从起点` src ` 出发， ` k ` 步之内（一步就是一条边）到达节点 ` s ` 的最小路径权重为 ` dp(s, k) ` ** 。

那么， ` dp ` 函数的 base case 就显而易见了：

```java
    // 定义：从 src 出发，k 步之内到达 s 的最小成本
        int dp(int s, int k) {
            // 从 src 到 src，一步都不用走
            if (s == src) {
                return 0;
            }
            // 如果步数用尽，就无解了
            if (k == 0) {
                return -1;
            }
    
            // ...
        }

```

题目想求的最小机票开销就可以用 ` dp(dst, K+1) ` 来表示：

```java
    int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {
        // 将中转站个数转化成边的条数
        K++;
        /.
        return dp(dst, K);

```

添加了一个 ` K ` 条边的限制，状态转移方程怎么写呢？其实和刚才是一样的：

![](https://labuladong.gitee.io/algo/images/%e6%97%85%e8%a1%8c%e6%9c%80%e7%9f%ad%e8%b7%af%e5%be%84/3.jpeg)

` K ` 步之内从 ` src ` 到 ` dst ` 的最小路径权重是多少？我不知道。

但我可以把问题分解：

![](https://labuladong.gitee.io/algo/images/%e6%97%85%e8%a1%8c%e6%9c%80%e7%9f%ad%e8%b7%af%e5%be%84/4.jpeg)

` s1, s2 ` 是指向 ` dst ` 的相邻节点，我只要知道 ` K - 1 ` 步之内从 ` src ` 到达 ` s1, s2 `，那我就可以在 ` K ` 步之内从 ` src ` 到达 ` dst ` 。

也就是如下关系式：

```java
    dp(dst, k) = min(
        dp(s1, k - 1) + w1, 
        dp(s2, k - 1) + w2
    )

```

这就是新的状态转移方程，如果你能看懂这个算式，就已经可以解决这道题了。

### 代码实现

根据上述思路，我怎么知道 ` s1, s2 ` 是指向 ` dst ` 的相邻节点，他们之间的权重是 ` w1, w2 ` ？

我希望给一个节点，就能知道有谁指向这个节点，还知道它们之间的权重，对吧。

专业点说，得用一个数据结构记录每个节点的「入度」indegree：

```java
    // 哈希表记录每个点的入度
    // to -> [from, price]
    HashMap<Integer, List<int[]>> indegree;
    int src, dst;
    
    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {
        // 将中转站个数转化成边的条数
        K++;
        this.src = src;
        this.dst = dst;
        
        indegree = new HashMap<>();
        for (int[] f : flights) {
            int from = f[0];
            int to = f[1];
            int price = f[2];
            // 记录谁指向该节点，以及之间的权重
            indegree.putIfAbsent(to, new LinkedList<>());
            indegree.get(to).add(new int[] {from, price});
        }
        
        return dp(dst, K);
    }

```

有了 ` indegree ` 存储入度，那么就可以具体实现 ` dp ` 函数了：

```java
    // 定义：从 src 出发，k 步之内到达 s 的最短路径权重
    int dp(int s, int k) {
        // base case
        if (s == src) {
            return 0;
        }
        if (k == 0) {
            return -1;
        }
        // 初始化为最大值，方便等会取最小值
        int res = Integer.MAX_VALUE;
        if (indegree.containsKey(s)) {
            // 当 s 有入度节点时，分解为子问题
            for (int[] v : indegree.get(s)) {
                int from = v[0];
                int price = v[1];
                // 从 src 到达相邻的入度节点所需的最短路径权重
                int subProblem = dp(from, k - 1);
                // 跳过无解的情况
                if (subProblem != -1) {
                    res = Math.min(res, subProblem + price);
                }
            }
        }
        // 如果还是初始值，说明此节点不可达
        return res == Integer.MAX_VALUE ? -1 : res;
    }

```

有之前的铺垫，这段解法逻辑应该是很清晰的。当然，对于动态规划问题，肯定要消除重叠子问题。

为什么有重叠子问题？很简单，如果某个节点同时指向两个其他节点，那么这两个节点就有相同的一个入度节点，就会产生重复的递归计算。

怎么消除重叠子问题？找问题的「状态」。

状态是什么？在问题分解（状态转移）的过程中变化的，就是状态。

**谁在变化？显然就是` dp ` 函数的参数 ` s ` 和 ` k ` ，每次递归调用，目标点 ` s ` 和步数约束 ` k ` 在变化 ** 。

所以，本题的状态有两个，应该算是二维动态规划，我们可以用一个 ` memo ` 二维数组或者哈希表作为备忘录，减少重复计算。

我们选用二维数组做备忘录吧，注意 ` K ` 是从 1 开始算的，所以备忘录初始大小要再加一：

```java
    int src, dst;
    HashMap<Integer, List<int[]>> indegree;
    // 备忘录
    int[][] memo;
    
    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {
        K++;
        this.src = src;
        this.dst = dst;
        // 初始化备忘录，全部填一个特殊值
        memo = new int[n][K + 1];
        for (int[] row : memo) {
            Arrays.fill(row, -888);
        }
        
        // 其他不变
        // ...
        
        return dp(dst, K);
    }
    
    // 定义：从 src 出发，k 步之内到达 s 的最小成本
    int dp(int s, int k) {
        // base case
        if (s == src) {
            return 0;
        }
        if (k == 0) {
            return -1;
        }
        // 查备忘录，防止冗余计算
        if (memo[s][k] != -888) {
            return memo[s][k];
        }
        
        // 状态转移不变
        // ...
        
        // 存入备忘录
        memo[s][k] = res == Integer.MAX_VALUE ? -1 : res;
        return memo[s][k];
    }

```

备忘录初始值为啥初始为 -888？前文 [ base case 和备忘录的初始值怎么定 ](https://labuladong.gitee.io/algo/3/22/69/)
说过，随便初始化一个无意义的值就行。

至此，这道题就通过自顶向下的递归方式解决了。当然，完全可以按照这个解法衍生出自底向上迭代的动态规划解法，但由于篇幅所限，我就不写了，反正本质上都是一样的。

其实，大家如果把我们号之前的所有动态规划文章都看一遍，就会发现我们一直在套用 [ 动态规划核心套路 ](https://labuladong.gitee.io/algo/3/22/66/)
，其实真没什么困难的。

最后扩展一下，有的读者可能会问：既然这个问题本质上是一个图的遍历问题，为什么不需要 ` visited ` 集合记录已经访问过的节点？

这个问题我在 [ Dijkstra 算法模板 ](https://labuladong.gitee.io/algo/2/18/41/) 中探讨过，可以去看看。另外，这题也可以利用 Dijkstra 算法模板来解决，代码如下：

```java
    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {
        List<int[]>[] graph = new LinkedList[n];
        for (int i = 0; i < n; i++) {
            graph[i] = new LinkedList<>();
        }
        for (int[] edge : flights) {
            int from = edge[0];
            int to = edge[1];
            int price = edge[2];
            graph[from].add(new int[]{to, price});
        }
    
        // 启动 dijkstra 算法
        // 计算以 src 为起点在 k 次中转到达 dst 的最短路径
        K++;
        return dijkstra(graph, src, K, dst);
    }
    
    class State {
        // 图节点的 id
        int id;
        // 从 src 节点到当前节点的花费
        int costFromSrc;
        // 从 src 节点到当前节点经过的节点个数
        int nodeNumFromSrc;
    
        State(int id, int costFromSrc, int nodeNumFromSrc) {
            this.id = id;
            this.costFromSrc = costFromSrc;
            this.nodeNumFromSrc = nodeNumFromSrc;
        }
    }
    
    // 输入一个起点 src，计算从 src 到其他节点的最短距离
    int dijkstra(List<int[]>[] graph, int src, int k, int dst) {
        // 定义：从起点 src 到达节点 i 的最短路径权重为 distTo[i]
        int[] distTo = new int[graph.length];
        // 定义：从起点 src 到达节点 i 至少要经过 nodeNumTo[i] 个节点
        int[] nodeNumTo = new int[graph.length];
        Arrays.fill(distTo, Integer.MAX_VALUE);
        Arrays.fill(nodeNumTo, Integer.MAX_VALUE);
        // base case
        distTo[src] = 0;
        nodeNumTo[src] = 0;
    
        // 优先级队列，costFromSrc 较小的排在前面
        Queue<State> pq = new PriorityQueue<>((a, b) -> {
            return a.costFromSrc - b.costFromSrc;
        });
        // 从起点 src 开始进行 BFS
        pq.offer(new State(src, 0, 0));
    
        while (!pq.isEmpty()) {
            State curState = pq.poll();
            int curNodeID = curState.id;
            int costFromSrc = curState.costFromSrc;
            int curNodeNumFromSrc = curState.nodeNumFromSrc;
            
            if (curNodeID == dst) {
                // 找到最短路径
                return costFromSrc;
            }
            if (curNodeNumFromSrc == k) {
                // 中转次数耗尽
                continue;
            }
    
            // 将 curNode 的相邻节点装入队列
            for (int[] neighbor : graph[curNodeID]) {
                int nextNodeID = neighbor[0];
                int costToNextNode = costFromSrc + neighbor[1];
                // 中转次数消耗 1
                int nextNodeNumFromSrc = curNodeNumFromSrc + 1;
    
                // 更新 dp table
                if (distTo[nextNodeID] > costToNextNode) {
                    distTo[nextNodeID] = costToNextNode;
                    nodeNumTo[nextNodeID] = nextNodeNumFromSrc;
                }
                // 剪枝，如果中转次数更多，花费还更大，那必然不会是最短路径
                if (costToNextNode > distTo[nextNodeID]
                    && nextNodeNumFromSrc > nodeNumTo[nextNodeID]) {
                    continue;
                }
                
                pq.offer(new State(nextNodeID, costToNextNode, nextNodeNumFromSrc));
            }
        }
        return -1;
    }

```

关于这个解法这里就不多解释了，可对照前文 [ Dijkstra 算法模板 ](https://labuladong.gitee.io/algo/2/18/41/) 理解。



## 经典动态规划：正则表达式



读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 10. 正则表达式匹配（困难） ](https://leetcode-cn.com/problems/regular-expression-
matching/)

**———–**

正则表达式是一个非常强力的工具，本文就来具体看一看正则表达式的底层原理是什么。力扣第 10 题「正则表达式匹配」就要求我们实现一个简单的正则匹配算法，包括「.」通配符和「*」通配符。

这两个通配符是最常用的，其中点号「.」可以匹配任意一个字符，星号「*」可以让之前的那个字符重复任意次数（包括 0 次）。

比如说模式串 ` ".a*b" ` 就可以匹配文本 ` "zaaab" ` ，也可以匹配 ` "cb" ` ；模式串 ` "a..b" ` 可以匹配文本 `"amnb" ` ；而模式串 ` ".*" ` 就比较牛逼了，它可以匹配任何文本。

题目会给我们输入两个字符串 ` s ` 和 ` p ` ， ` s ` 代表文本， ` p ` 代表模式串，请你判断模式串 ` p ` 是否可以匹配文本 `s ` 。我们可以假设模式串只包含小写字母和上述两种通配符且一定合法，不会出现 ` *a ` 或者 ` b** ` 这种不合法的模式串，

函数签名如下：

```java
    bool isMatch(string s, string p);

```

对于我们将要实现的这个正则表达式，难点在那里呢？

点号通配符其实很好实现， ` s ` 中的任何字符，只要遇到 ` . ` 通配符，无脑匹配就完事了。主要是这个星号通配符不好实现，一旦遇到 ` * `通配符，前面的那个字符可以选择重复一次，可以重复多次，也可以一次都不出现，这该怎么办？

对于这个问题，答案很简单，对于所有可能出现的情况，全部穷举一遍，只要有一种情况可以完成匹配，就认为 ` p ` 可以匹配 ` s `。那么一旦涉及两个字符串的穷举，我们就应该条件反射地想到动态规划的技巧了。

### 一、思路分析

我们先脑补一下， ` s ` 和 ` p ` 相互匹配的过程大致是，两个指针 ` i, j ` 分别在 ` s ` 和 ` p `上移动，如果最后两个指针都能移动到字符串的末尾，那么久匹配成功，反之则匹配失败。

**正则表达算法问题只需要把住一个基本点：看两个字符是否匹配，一切逻辑围绕匹配/不匹配两种情况展开即可​** 。

如果不考虑 ` * ` 通配符，面对两个待匹配字符 ` s[i] ` 和 ` p[j] ` ，我们唯一能做的就是看他俩是否匹配：

```java
    bool isMatch(string s, string p) {
        int i = 0, j = 0;
        while (i < s.size() && j < p.size()) {
            // 「.」通配符就是万金油
            if (s[i] == p[j] || p[j] == '.') {
                // 匹配，接着匹配 s[i+1..] 和 p[j+1..]
                i++; j++;
            } else {
                // 不匹配
                return false;
            }
        }
        return i == j;
    }

```

那么考虑一下，如果加入 ` * ` 通配符，局面就会稍微复杂一些，不过只要分情况来分析，也不难理解。

**当` p[j + 1] ` 为 ` * ` 通配符时，我们分情况讨论下 ** ：

1、如果 ` s[i] == p[j] ` ，那么有两种情况：

1.1 ` p[j] ` 有可能会匹配多个字符，比如 ` s = "aaa", p = "a*" ` ，那么 ` p[0] ` 会通过 ` * ` 匹配 3 个字符 ` "a" ` 。

1.2 ` p[i] ` 也有可能匹配 0 个字符，比如 ` s = "aa", p = "a*aa" ` ，由于后面的字符可以匹配 ` s ` ，所以 `p[0] ` 只能匹配 0 次。

2、如果 ` s[i] != p[j] ` ，只有一种情况：

` p[j] ` 只能匹配 0 次，然后看下一个字符是否能和 ` s[i] ` 匹配。比如说 ` s = "aa", p = "b*aa" ` ，此时 `p[0] ` 只能匹配 0 次。

综上，可以把之前的代码针对 ` * ` 通配符进行一下改造：

```java
    if (s[i] == p[j] || p[j] == '.') {
        // 匹配
        if (j < p.size() - 1 && p[j + 1] == '*') {
            // 有 * 通配符，可以匹配 0 次或多次
        } else {
            // 无 * 通配符，老老实实匹配 1 次
            i++; j++;
        }
    } else {
        // 不匹配
        if (j < p.size() - 1 && p[j + 1] == '*') {
            // 有 * 通配符，只能匹配 0 次
        } else {
            // 无 * 通配符，匹配无法进行下去了
            return false;
        }
    }

```

整体的思路已经很清晰了，但现在的问题是，遇到 ` * ` 通配符时，到底应该匹配 0 次还是匹配多次？多次是几次？

你看，这就是一个做「选择」的问题，要把所有可能的选择都穷举一遍才能得出结果。动态规划算法的核心就是「状态」和「选择」， **「状态」无非就是` i ` 和
` j ` 两个指针的位置，「选择」就是 ` p[j] ` 选择匹配几个字符 ** 。

### 二、动态规划解法

根据「状态」，我们可以定义一个 ` dp ` 函数：

```java
    bool dp(string& s, int i, string& p, int j);

```

**＿＿＿＿＿＿＿＿＿＿＿＿＿**

应合作方要求，本文不便在此发布，请扫码关注回复关键词「正则」查看：

![](https://labuladong.gitee.io/algo/images/qrcode.jpg)

## 经典动态规划：高楼扔鸡蛋



读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 887. 鸡蛋掉落（困难） ](https://leetcode-cn.com/problems/super-egg-drop/)

**———–**

今天要聊一个很经典的算法问题，若干层楼，若干个鸡蛋，让你算出最少的尝试次数，找到鸡蛋恰好摔不碎的那层楼。国内大厂以及谷歌脸书面试都经常考察这道题，只不过他们觉得扔鸡蛋太浪费，改成扔杯子，扔破碗什么的。

具体的问题等会再说，但是这道题的解法技巧很多，光动态规划就好几种效率不同的思路，最后还有一种极其高效数学解法。秉承咱们号一贯的作风，拒绝奇技淫巧，拒绝过于诡异的技巧，因为这些技巧无法举一反三，学了也不划算。

下面就来用我们一直强调的动态规划通用思路来研究一下这道题。

### 一、解析题目

题目是这样：你面前有一栋从 1 到 ` N ` 共 ` N ` 层的楼，然后给你 ` K ` 个鸡蛋（ ` K ` 至少为 1）。现在确定这栋楼存在楼层 `0 <= F <= N ` ，在这层楼将鸡蛋扔下去，鸡蛋 **恰好没摔碎** （高于 ` F ` 的楼层都会碎，低于 ` F `的楼层都不会碎）。现在问你， **最坏** 情况下，你 **至少** 要扔几次鸡蛋，才能 **确定** 这个楼层 ` F ` 呢？

也就是让你找摔不碎鸡蛋的最高楼层 ` F ` ，但什么叫「最坏情况」下「至少」要扔几次呢？我们分别举个例子就明白了。

比方说 **现在先不管鸡蛋个数的限制** ，有 7 层楼，你怎么去找鸡蛋恰好摔碎的那层楼？

最原始的方式就是线性扫描：我先在 1 楼扔一下，没碎，我再去 2 楼扔一下，没碎，我再去 3 楼……

以这种策略， **最坏** 情况应该就是我试到第 7 层鸡蛋也没碎（ ` F = 7 ` ），也就是我扔了 7 次鸡蛋。

先在你应该理解什么叫做「最坏情况」下了， **鸡蛋破碎一定发生在搜索区间穷尽时** ，不会说你在第 1 层摔一下鸡蛋就碎了，这是你运气好，不是最坏情况。

现在再来理解一下什么叫「至少」要扔几次。依然不考虑鸡蛋个数限制，同样是 7 层楼，我们可以优化策略。

最好的策略是使用二分查找思路，我先去第 ` (1 + 7) / 2 = 4 ` 层扔一下：

如果碎了说明 ` F ` 小于 4，我就去第 ` (1 + 3) / 2 = 2 ` 层试……

如果没碎说明 ` F ` 大于等于 4，我就去第 ` (5 + 7) / 2 = 6 ` 层试……

以这种策略， **最坏** 情况应该是试到第 7 层鸡蛋还没碎（ ` F = 7 ` ），或者鸡蛋一直碎到第 1 层（ ` F = 0 `）。然而无论那种最坏情况，只需要试 ` log7 ` 向上取整等于 3 次，比刚才尝试 7 次要少，这就是所谓的 **至少** 要扔几次。

> PS：这有点像 Big O 表示法计算​算法的复杂度。

实际上，如果不限制鸡蛋个数的话，二分思路显然可以得到最少尝试的次数，但问题是， **现在给你了鸡蛋个数的限制` K ` ，直接使用二分思路就不行了 ** 。

比如说只给你 1 个鸡蛋，7 层楼，你敢用二分吗？你直接去第 4 层扔一下，如果鸡蛋没碎还好，但如果碎了你就没有鸡蛋继续测试了，无法确定鸡蛋恰好摔不碎的楼层
` F ` 了。这种情况下只能用线性扫描的方法，算法返回结果应该是 7。

有的读者也许会有这种想法：二分查找排除楼层的速度无疑是最快的，那干脆先用二分查找，等到只剩 1 个鸡蛋的时候再执行线性扫描，这样得到的结果是不是就是最少的扔鸡蛋次数呢？

很遗憾，并不是，比如说把楼层变高一些，100 层，给你 2 个鸡蛋，你在 50 层扔一下，碎了，那就只能线性扫描 1～49 层了，最坏情况下要扔 50 次。

如果不要「二分」，变成「五分」「十分」都会大幅减少最坏情况下的尝试次数。比方说第一个鸡蛋每隔十层楼扔，在哪里碎了第二个鸡蛋一个个线性扫描，总共不会超过 20 次​。

最优解其实是 14 次。最优策略非常多，而且并没有什么规律可言。

说了这么多废话，就是确保大家理解了题目的意思，而且认识到这个题目确实复杂，就连我们手算都不容易，如何用算法解决呢？

### 二、思路分析

**＿＿＿＿＿＿＿＿＿＿＿＿＿**

应合作方要求，本文不便在此发布，请扫码关注回复关键词「鸡蛋」查看：

![](https://labuladong.gitee.io/algo/images/qrcode.jpg)

## 经典动态规划：高楼扔鸡蛋（进阶）



读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 887. 鸡蛋掉落（困难） ](https://leetcode-cn.com/problems/super-egg-drop/)

**———–**

上篇文章聊了高楼扔鸡蛋问题，讲了一种效率不是很高，但是较为容易理解的动态规划解法。后台很多读者问如何更高效地解决这个问题，今天就谈两种思路，来优化一下这个问题，分别是二分查找优化和重新定义状态转移。

如果还不知道高楼扔鸡蛋问题的读者可以看下「经典动态规划：高楼扔鸡蛋」，那篇文章详解了题目的含义和基本的动态规划解题思路，请确保理解前文，因为今天的优化都是基于这个基本解法的。

二分搜索的优化思路也许是我们可以尽力尝试写出的，而修改状态转移的解法可能是不容易想到的，可以借此见识一下动态规划算法设计的玄妙，当做思维拓展。

### 二分搜索优化

之前提到过这个解法，核心是因为状态转移方程的单调性，这里可以具体展开看看。

首先简述一下原始动态规划的思路：

1、暴力穷举尝试在所有楼层 ` 1 <= i <= N ` 扔鸡蛋，每次选择尝试次数 **最少** 的那一层；

2、每次扔鸡蛋有两种可能，要么碎，要么没碎；

3、如果鸡蛋碎了， ` F ` 应该在第 ` i ` 层下面，否则， ` F ` 应该在第 ` i ` 层上面；

4、鸡蛋是碎了还是没碎，取决于哪种情况下尝试次数 **更多** ，因为我们想求的是最坏情况下的结果。

核心的状态转移代码是这段：

```java
    ## 当前状态为 K 个鸡蛋，面对 N 层楼
    ## 返回这个状态下的最优结果
    def dp(K, N):
        for 1 <= i <= N:
            ## 最坏情况下的最少扔鸡蛋次数
            res = min(res, 
                      max( 
                            dp(K - 1, i - 1), ## 碎
                            dp(K, N - i)      ## 没碎
                         ) + 1 ## 在第 i 楼扔了一次
                     )
        return res

```

这个 for 循环就是下面这个状态转移方程的具体代码实现：

![](https://labuladong.gitee.io/algo/images/%e6%89%94%e9%b8%a1%e8%9b%8b/formula1.png)

如果能够理解这个状态转移方程，那么就很容易理解二分查找的优化思路。

首先我们根据 ` dp(K, N) ` 数组的定义（有 ` K ` 个鸡蛋面对 ` N ` 层楼，最少需要扔几次）， **很容易知道` K `固定时，这个函数随着 ` N ` 的增加一定是单调递增的 ** ，无论你策略多聪明，楼层增加测试次数一定要增加。

那么注意 ` dp(K - 1, i - 1) ` 和 ` dp(K, N - i) ` 这两个函数，其中 ` i ` 是从 1 到 ` N `单增的，如果我们固定 ` K ` 和 ` N ` ， **把这两个函数看做关于` i ` 的函数，前者随着 ` i ` 的增加应该也是单调递增的，而后者随着
` i ` 的增加应该是单调递减的 ** ：

![](https://labuladong.gitee.io/algo/images/%e6%89%94%e9%b8%a1%e8%9b%8b/2.jpg)

这时候求二者的较大值，再求这些最大值之中的最小值，其实就是求这两条直线交点，也就是红色折线的最低点嘛。

我们前文 [ 二分查找只能用来查找元素吗 ](https://labuladong.gitee.io/algo/2/20/58/) 讲过，二分查找的运用很广泛，形如下面这种形式的 for 循环代码：

```java
    for (int i = 0; i < n; i++) {
        if (isOK(i))
            return i;
    }

```

都很有可能可以运用二分查找来优化线性搜索的复杂度，回顾这两个 ` dp ` 函数的曲线，我们要找的最低点其实就是这种情况：

```java
    for (int i = 1; i <= N; i++) {
        if (dp(K - 1, i - 1) == dp(K, N - i))
            return dp(K, N - i);
    }

```

熟悉二分搜索的同学肯定敏感地想到了，这不就是相当于求 Valley（山谷）值嘛，可以用二分查找来快速寻找这个点的，直接看代码吧，整体的思路还是一样，只是加快了搜索速度：

```java
    def superEggDrop(self, K: int, N: int) -> int:
            
        memo = dict()
        def dp(K, N):
            if K == 1: return N
            if N == 0: return 0
            if (K, N) in memo:
                return memo[(K, N)]
                                
            ## for 1 <= i <= N:
            ##     res = min(res, 
            ##             max( 
            ##                 dp(K - 1, i - 1), 
            ##                 dp(K, N - i)      
            ##                 ) + 1 
            ##             )
    
            res = float('INF')
            ## 用二分搜索代替线性搜索
            lo, hi = 1, N
            while lo <= hi:
                mid = (lo + hi) // 2
                broken = dp(K - 1, mid - 1) ## 碎
                not_broken = dp(K, N - mid) ## 没碎
                ## res = min(max(碎，没碎) + 1)
                if broken > not_broken:
                    hi = mid - 1
                    res = min(res, broken + 1)
                else:
                    lo = mid + 1
                    res = min(res, not_broken + 1)
    
            memo[(K, N)] = res
            return res
        
        return dp(K, N)

```

这个算法的时间复杂度是多少呢？ **动态规划算法的时间复杂度就是子问题个数 × 函数本身的复杂度** 。

函数本身的复杂度就是忽略递归部分的复杂度，这里 ` dp ` 函数中用了一个二分搜索，所以函数本身的复杂度是 O(logN)。

子问题个数也就是不同状态组合的总数，显然是两个状态的乘积，也就是 O(KN)。

所以算法的总时间复杂度是 O(K*N*logN), 空间复杂度 O(KN)。效率上比之前的算法 O(KN^2) 要高效一些。

### 重新定义状态转移

前文 [ 不同定义有不同解法 ](https://labuladong.gitee.io/algo/3/25/93/)
就提过，找动态规划的状态转移本就是见仁见智，比较玄学的事情，不同的状态定义可以衍生出不同的解法，其解法和复杂程度都可能有巨大差异。这里就是一个很好的例子。

再回顾一下我们之前定义的 ` dp ` 数组含义：

```java
    def dp(k, n) -> int
    ## 当前状态为 k 个鸡蛋，面对 n 层楼
    ## 返回这个状态下最少的扔鸡蛋次数

```

用 dp 数组表示的话也是一样的：

```java
    dp[k][n] = m
    ## 当前状态为 k 个鸡蛋，面对 n 层楼
    ## 这个状态下最少的扔鸡蛋次数为 m

```

按照这个定义，就是 **确定当前的鸡蛋个数和面对的楼层数，就知道最小扔鸡蛋次数** 。最终我们想要的答案就是 ` dp(K, N) ` 的结果。

这种思路下，肯定要穷举所有可能的扔法的，用二分搜索优化也只是做了「剪枝」，减小了搜索空间，但本质思路没有变，还是穷举。

现在，我们稍微修改 ` dp ` 数组的定义， **确定当前的鸡蛋个数和最多允许的扔鸡蛋次数，就知道能够确定` F ` 的最高楼层数 **
。具体来说是这个意思：

```java
    dp[k][m] = n
    ## 当前有 k 个鸡蛋，可以尝试扔 m 次鸡蛋
    ## 这个状态下，最坏情况下最多能确切测试一栋 n 层的楼
    
    ## 比如说 dp[1][7] = 7 表示：
    ## 现在有 1 个鸡蛋，允许你扔 7 次;
    ## 这个状态下最多给你 7 层楼，
    ## 使得你可以确定楼层 F 使得鸡蛋恰好摔不碎
    ## （一层一层线性探查嘛）

```

这其实就是我们原始思路的一个「反向」版本，我们先不管这种思路的状态转移怎么写，先来思考一下这种定义之下，最终想求的答案是什么？

我们最终要求的其实是扔鸡蛋次数 ` m ` ，但是这时候 ` m ` 在状态之中而不是 ` dp ` 数组的结果，可以这样处理：

```java
    int superEggDrop(int K, int N) {
    
        int m = 0;
        while (dp[K][m] < N) {
            m++;
            // 状态转移...
        }
        return m;
    }

```

题目不是 **给你` K ` 鸡蛋， ` N ` 层楼，让你求最坏情况下最少的测试次数 ` m ` ** 吗？ ` while ` 循环结束的条件是 `dp[K][m] == N ` ，也就是 **给你` K ` 个鸡蛋，测试 ` m ` 次，最坏情况下最多能测试 ` N ` 层楼 ** 。

注意看这两段描述，是完全一样的！所以说这样组织代码是正确的，关键就是状态转移方程怎么找呢？还得从我们原始的思路开始讲。之前的解法配了这样图帮助大家理解状态转移思路：

![](https://labuladong.gitee.io/algo/images/%e6%89%94%e9%b8%a1%e8%9b%8b/1.jpg)

这个图描述的仅仅是某一个楼层 ` i ` ，原始解法还得线性或者二分扫描所有楼层，要求最大值、最小值。但是现在这种 ` dp `定义根本不需要这些了，基于下面两个事实：

**1、无论你在哪层楼扔鸡蛋，鸡蛋只可能摔碎或者没摔碎，碎了的话就测楼下，没碎的话就测楼上** 。

**2、无论你上楼还是下楼，总的楼层数 = 楼上的楼层数 + 楼下的楼层数 + 1（当前这层楼）** 。

根据这个特点，可以写出下面的状态转移方程：

` dp[k][m] = dp[k][m - 1] + dp[k - 1][m - 1] + 1 `
**` dp[k][m - 1] ` 就是楼上的楼层数 ** ，因为鸡蛋个数 ` k ` 不变，也就是鸡蛋没碎，扔鸡蛋次数 ` m ` 减一；

**` dp[k - 1][m - 1] ` 就是楼下的楼层数 ** ，因为鸡蛋个数 ` k ` 减一，也就是鸡蛋碎了，同时扔鸡蛋次数 ` m ` 减一。

> PS：这个 ` m ` 为什么要减一而不是加一？之前定义得很清楚，这个 ` m ` 是一个允许的次数上界，而不是扔了几次。

![](https://labuladong.gitee.io/algo/images/%e6%89%94%e9%b8%a1%e8%9b%8b/3.jpg)

至此，整个思路就完成了，只要把状态转移方程填进框架即可：

```java
    int superEggDrop(int K, int N) {
        // m 最多不会超过 N 次（线性扫描）
        int[][] dp = new int[K + 1][N + 1];
        // base case:
        // dp[0][..] = 0
        // dp[..][0] = 0
        // Java 默认初始化数组都为 0
        int m = 0;
        while (dp[K][m] < N) {
            m++;
            for (int k = 1; k <= K; k++)
                dp[k][m] = dp[k][m - 1] + dp[k - 1][m - 1] + 1;
        }
        return m;
    }

```

如果你还觉得这段代码有点难以理解，其实它就等同于这样写：

```java
    for (int m = 1; dp[K][m] < N; m++)
        for (int k = 1; k <= K; k++)
            dp[k][m] = dp[k][m - 1] + dp[k - 1][m - 1] + 1;

```

看到这种代码形式就熟悉多了吧，因为我们要求的不是 ` dp ` 数组里的值，而是某个符合条件的索引 ` m ` ，所以用 ` while ` 循环来找到这个
` m ` 而已。

这个算法的时间复杂度是多少？很明显就是两个嵌套循环的复杂度 O(KN)。

另外注意到 ` dp[m][k] ` 转移只和左边和左上的两个状态有关，所以很容易优化成一维 ` dp ` 数组，这里就不写了。

### 还可以再优化

再往下就要用一些数学方法了，不具体展开，就简单提一下思路吧。

在刚才的思路之上， **注意函数` dp(m, k) ` 是随着 ` m ` 单增的，因为鸡蛋个数 ` k `不变时，允许的测试次数越多，可测试的楼层就越高 ** 。

这里又可以借助二分搜索算法快速逼近 ` dp[K][m] == N ` 这个终止条件，时间复杂度进一步下降为 O(KlogN)，我们可以设 ` g(k, m) = ` ……

算了算了，打住吧。我觉得我们能够写出 O(K*N*logN)
的二分优化算法就行了，后面的这些解法呢，听个响鼓个掌就行了，把欲望限制在能力的范围之内才能拥有快乐！

不过可以肯定的是，根据二分搜索代替线性扫描 ` m ` 的取值，代码的大致框架肯定是修改穷举 ` m ` 的 for 循环：

```java
    // 把线性搜索改成二分搜索
    // for (int m = 1; dp[K][m] < N; m++)
    int lo = 1, hi = N;
    while (lo < hi) {
        int mid = (lo + hi) / 2;
        if (... < N) {
            lo = ...
        } else {
            hi = ...
        }
        
        for (int k = 1; k <= K; k++)
            // 状态转移方程
    }

```

简单总结一下吧，第一个二分优化是利用了 ` dp `函数的单调性，用二分查找技巧快速搜索答案；第二种优化是巧妙地修改了状态转移方程，简化了求解了流程，但相应的，解题逻辑比较难以想到；后续还可以用一些数学方法和二分搜索进一步优化第二种解法，不过看了看镜子中的发量，算了。

本文终，希望对你有一点启发。



## 经典动态规划：戳气球



读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 312. 戳气球（困难） ](https://leetcode-cn.com/problems/burst-balloons)

**———–**

今天我们要聊的这道题「Burst Balloon」和之前我们写过的那篇 [ 经典动态规划：高楼扔鸡蛋问题 ](https://labuladong.gitee.io/algo/3/25/89/)
分析过的高楼扔鸡蛋问题类似，知名度很高，但难度确实也很大。因此 labuladong 公众号就给这道题赐个座，来看一看这道题目到底有多难。

它是 LeetCode 第 312 题，题目如下：

![](https://labuladong.gitee.io/algo/images/burstBalloon/title.jpg)

首先必须要说明，这个题目的状态转移方程真的比较巧妙，所以说如果你看了题目之后完全没有思路恰恰是正常的。虽然最优答案不容易想出来，但基本的思路分析是我们应该力求做到的。所以本文会先分析一下常规思路，然后再引入动态规划解法。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**

应合作方要求，本文不便在此发布，请扫码关注回复关键词「气球」查看：

![](https://labuladong.gitee.io/algo/images/qrcode.jpg)

## 经典动态规划：博弈问题



读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 877. 石子游戏（中等） ](https://leetcode-cn.com/problems/stone-game)

**———–**

上一篇文章 [ 几道智力题 ](https://labuladong.gitee.io/algo/4/29/121/)
中讨论到一个有趣的「石头游戏」，通过题目的限制条件，这个游戏是先手必胜的。但是智力题终究是智力题，真正的算法问题肯定不会是投机取巧能搞定的。所以，本文就借石头游戏来讲讲「假设两个人都足够聪明，最后谁会获胜」这一类问题该如何用动态规划算法解决。

博弈类问题的套路都差不多，下文参考 [ 这个 YouTube 视频

](https://www.youtube.com/watch?v=WxpIHvsu1RI) 的思路讲解，其核心思路是在二维 dp
的基础上使用元组分别存储两个人的博弈结果。掌握了这个技巧以后，别人再问你什么俩海盗分宝石，俩人拿硬币的问题，你就告诉别人：我懒得想，直接给你写个算法算一下得了。

我们把「石头游戏」改的更具有一般性：

你和你的朋友面前有一排石头堆，用一个数组 ` piles ` 表示， ` piles[i] ` 表示第 ` i `堆石子有多少个。你们轮流拿石头，一次拿一堆，但是只能拿走最左边或者最右边的石头堆。所有石头被拿完后，谁拥有的石头多，谁获胜。

石头的堆数可以是任意正整数，石头的总数也可以是任意正整数，这样就能打破先手必胜的局面了。比如有三堆石头 ` piles = [1, 100, 3] `，先手不管拿 1 还是 3，能够决定胜负的 100 都会被后手拿走，后手会获胜。

**假设两人都很聪明** ，请你设计一个算法，返回先手和后手的最后得分（石头总数）之差。比如上面那个例子，先手能获得 4 分，后手会获得 100 分，你的算法应该返回 -96。

这样推广之后，这个问题算是一道 Hard 的动态规划问题了。 **博弈问题的难点在于，两个人要轮流进行选择，而且都贼精明，应该如何编程表示这个过程呢？**

还是强调多次的套路，首先明确 ` dp ` 数组的含义，然后只要找到「状态」和「选择」，一切就水到渠成了。

### 一、定义 dp 数组的含义

定义 ` dp `数组的含义是很有技术含量的，同一问题可能有多种定义方法，不同的定义会引出不同的状态转移方程，不过只要逻辑没有问题，最终都能得到相同的答案。

我建议不要迷恋那些看起来很牛逼，代码很短小的奇技淫巧，最好是稳一点，采取可解释性最好，最容易推广的设计思路。本文就给出一种博弈问题的通用设计框架。

介绍 ` dp ` 数组的含义之前，我们先看一下 ` dp ` 数组最终的样子：

![](https://labuladong.gitee.io/algo/images/%e5%8d%9a%e5%bc%88%e9%97%ae%e9%a2%98/1.png)

下文讲解时，认为元组是包含 ` first ` 和 ` second ` 属性的一个类，而且为了节省篇幅，将这两个属性简写为 ` fir ` 和 ` sec
` 。比如按上图的数据，我们说 ` dp[1][3].fir = 11 ` ， ` dp[0][1].sec = 2 ` 。

先回答几个读者可能提出的问题：

这个二维 dp table 中存储的是元组，怎么编程表示呢？这个 dp table 有一半根本没用上，怎么优化？很简单，都不要管，先把解题的思路想明白了再谈也不迟。

**以下是对 dp 数组含义的解释：**

` dp[i][j].fir = x ` 表示，对于 ` piles[i...j] ` 这部分石头堆，先手能获得的最高分数为 ` x ` 。

` dp[i][j].sec = y ` 表示，对于 ` piles[i...j] ` 这部分石头堆，后手能获得的最高分数为 ` y ` 。

举例理解一下，假设 ` piles = [2, 8, 3, 5] ` ，索引从 0 开始，那么：

` dp[0][1].fir = 8 ` 意味着：面对石头堆 ` [2, 8] ` ，先手最多能够获得 8 分； ` dp[1][3].sec = 5 `意味着：面对石头堆 ` [8, 3, 5] ` ，后手最多能够获得 5 分。

我们想求的答案是先手和后手最终分数之差，按照这个定义也就是 ` dp[0][n-1].fir - dp[0][n-1].sec ` ，即面对整个 `piles ` ，先手的最优得分和后手的最优得分之差。

### 二、状态转移方程

写状态转移方程很简单，首先要找到所有「状态」和每个状态可以做的「选择」，然后择优。

根据前面对 dp 数组的定义， **状态显然有三个：开始的索引` i ` ，结束的索引 ` j ` ，当前轮到的人。 **

```java
    dp[i][j][fir or sec]
    其中：
    0 <= i < piles.length
    i <= j < piles.length

```

对于这个问题的每个状态，可以做的 **选择有两个：选择最左边的那堆石头，或者选择最右边的那堆石头。** 我们可以这样穷举所有状态：

```java
    n = piles.length
    for 0 <= i < n:
        for j <= i < n:
            for who in {fir, sec}:
                dp[i][j][who] = max(left, right)

```

上面的伪码是动态规划的一个大致的框架，这道题的难点在于，两人足够聪明，而且是交替进行选择的，也就是说先手的选择会对后手有影响，这怎么表达出来呢？

根据我们对 ` dp ` 数组的定义，很容易解决这个难点， **写出状态转移方程：**

```java
    dp[i][j].fir = max(piles[i] + dp[i+1][j].sec, piles[j] + dp[i][j-1].sec)
    dp[i][j].fir = max(     选择最左边的石头堆     ,     选择最右边的石头堆      )
    ## 解释：我作为先手，面对 piles[i...j] 时，有两种选择：
    ## 要么我选择最左边的那一堆石头，然后面对 piles[i+1...j]
    ## 但是此时轮到对方，相当于我变成了后手；
    ## 要么我选择最右边的那一堆石头，然后面对 piles[i...j-1]
    ## 但是此时轮到对方，相当于我变成了后手。
    
    if 先手选择左边:
        dp[i][j].sec = dp[i+1][j].fir
    if 先手选择右边:
        dp[i][j].sec = dp[i][j-1].fir
    ## 解释：我作为后手，要等先手先选择，有两种情况：
    ## 如果先手选择了最左边那堆，给我剩下了 piles[i+1...j]
    ## 此时轮到我，我变成了先手；
    ## 如果先手选择了最右边那堆，给我剩下了 piles[i...j-1]
    ## 此时轮到我，我变成了先手。

```

根据 dp 数组的定义，我们也可以找出 **base case** ，也就是最简单的情况：

```java
    dp[i][j].fir = piles[i]
    dp[i][j].sec = 0
    其中 0 <= i == j < n
    ## 解释：i 和 j 相等就是说面前只有一堆石头 piles[i]
    ## 那么显然先手的得分为 piles[i]
    ## 后手没有石头拿了，得分为 0

```

![](https://labuladong.gitee.io/algo/images/%e5%8d%9a%e5%bc%88%e9%97%ae%e9%a2%98/2.png)

这里需要注意一点，我们发现 base case 是斜着的，而且我们推算 ` dp[i][j] ` 时需要用到 ` dp[i+1][j] ` 和 `dp[i][j-1] ` ：

![](https://labuladong.gitee.io/algo/images/%e5%8d%9a%e5%bc%88%e9%97%ae%e9%a2%98/3.png)

根据前文 [ 动态规划答疑篇 ](https://labuladong.gitee.io/algo/3/22/68/) 判断 ` dp ` 数组遍历方向的原则，算法应该倒着遍历 ` dp ` 数组：

```java
    for (int i = n - 2; i >= 0; i--) {
        for (int j = i + 1; j < n; j++) {
            dp[i][j] = ...
        }
    }

```

![](https://labuladong.gitee.io/algo/images/%e5%8d%9a%e5%bc%88%e9%97%ae%e9%a2%98/4.png)

### 三、代码实现

如何实现这个 fir 和 sec 元组呢，你可以用 python，自带元组类型；或者使用 C++ 的 pair 容器；或者用一个三维数组 `dp[n][n][2] ` ，最后一个维度就相当于元组；或者我们自己写一个 Pair 类：

```java
    class Pair {
        int fir, sec;
        Pair(int fir, int sec) {
            this.fir = fir;
            this.sec = sec;
        }
    }

```

然后直接把我们的状态转移方程翻译成代码即可，注意我们要倒着遍历数组：

```java
    /* 返回游戏最后先手和后手的得分之差 */
    int stoneGame(int[] piles) {
        int n = piles.length;
        // 初始化 dp 数组
        Pair[][] dp = new Pair[n][n];
        for (int i = 0; i < n; i++) 
            for (int j = i; j < n; j++)
                dp[i][j] = new Pair(0, 0);
        // 填入 base case
        for (int i = 0; i < n; i++) {
            dp[i][i].fir = piles[i];
            dp[i][i].sec = 0;
        }
    
        // 倒着遍历数组
        for (int i = n - 2; i >= 0; i--) {
            for (int j = i + 1; j < n; j++) {
                // 先手选择最左边或最右边的分数
                int left = piles[i] + dp[i+1][j].sec;
                int right = piles[j] + dp[i][j-1].sec;
                // 套用状态转移方程
                // 先手肯定会选择更大的结果，后手的选择随之改变
                if (left > right) {
                    dp[i][j].fir = left;
                    dp[i][j].sec = dp[i+1][j].fir;
                } else {
                    dp[i][j].fir = right;
                    dp[i][j].sec = dp[i][j-1].fir;
                }
            }
        }
        Pair res = dp[0][n-1];
        return res.fir - res.sec;
    }

```

动态规划解法，如果没有状态转移方程指导，绝对是一头雾水，但是根据前面的详细解释，读者应该可以清晰理解这一大段代码的含义。

而且，注意到计算 ` dp[i][j] ` 只依赖其左边和下边的元素，所以说肯定有优化空间，转换成一维 dp，想象一下把二维平面压扁，也就是投影到一维。但是，一维 ` dp ` 比较复杂，可解释性比较差，大家就不必浪费这个时间去理解了。

### 四、最后总结

本文给出了解决博弈问题的动态规划解法。博弈问题的前提一般都是在两个聪明人之间进行，编程描述这种游戏的一般方法是二维 dp 数组，数组中通过元组分别表示两人的最优决策。

之所以这样设计，是因为先手在做出选择之后，就成了后手，后手在对方做完选择后，就变成了先手。
**这种角色转换使得我们可以重用之前的结果，典型的动态规划标志** 。

读到这里的朋友应该能理解算法解决博弈问题的套路了。学习算法，一定要注重算法的模板框架，而不是一些看起来牛逼的思路，也不要奢求上来就写一个最优的解法。不要舍不得多用空间，不要过早尝试优化，不要惧怕多维数组。
` dp ` 数组就是存储信息避免重复计算的，随便用，直到咱满意为止。



## 经典动态规划：四键键盘



读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 651. 四键键盘（中等） ](https://leetcode-cn.com/problems/4-keys-keyboard)

**———–**

四键键盘问题很有意思，而且可以明显感受到：对 ` dp ` 数组的不同定义需要完全不同的逻辑，从而产生完全不同的解法。

首先看一下题目：

![](https://labuladong.gitee.io/algo/images/4keyboard/title.png)

如何在 ` N ` 次敲击按钮后得到最多的 ` A ` ？我们穷举呗，每次有对于每次按键，我们可以穷举四种可能，很明显就是一个动态规划问题。

### 第一种思路

这种思路会很容易理解，但是效率并不高，我们直接走流程： **对于动态规划问题，首先要明白有哪些「状态」，有哪些「选择」** 。

具体到这个问题，对于每次敲击按键，有哪些「选择」是很明显的：4 种，就是题目中提到的四个按键，分别是 ` A ` 、 ` C-A ` 、 ` C-C ` 、
` C-V ` （ ` Ctrl ` 简写为 ` C ` ）。

接下来，思考一下对于这个问题有哪些「状态」？ **或者换句话说，我们需要知道什么信息，才能将原问题分解为规模更小的子问题** ？

你看我这样定义三个状态行不行：第一个状态是剩余的按键次数，用 ` n ` 表示；第二个状态是当前屏幕上字符 A 的数量，用 ` a_num `表示；第三个状态是剪切板中字符 A 的数量，用 ` copy ` 表示。

如此定义「状态」，就可以知道 base case：当剩余次数 ` n ` 为 0 时， ` a_num ` 就是我们想要的答案。

结合刚才说的 4 种「选择」，我们可以把这几种选择通过状态转移表示出来：

```java
    dp(n - 1, a_num + 1, copy),    ## A
    解释：按下 A 键，屏幕上加一个字符
    同时消耗 1 个操作数
    
    dp(n - 1, a_num + copy, copy), ## C-V
    解释：按下 C-V 粘贴，剪切板中的字符加入屏幕
    同时消耗 1 个操作数
    
    dp(n - 2, a_num, a_num)        ## C-A C-C
    解释：全选和复制必然是联合使用的，
    剪切板中 A 的数量变为屏幕上 A 的数量
    同时消耗 2 个操作数

```

这样可以看到问题的规模 ` n ` 在不断减小，肯定可以到达 ` n = 0 ` 的 base case，所以这个思路是正确的：

```java
    def maxA(N: int) -> int:
    
        ## 对于 (n, a_num, copy) 这个状态，
        ## 屏幕上能最终最多能有 dp(n, a_num, copy) 个 A
        def dp(n, a_num, copy):
            ## base case
            if n <= 0: return a_num;
            ## 几种选择全试一遍，选择最大的结果
            return max(
                    dp(n - 1, a_num + 1, copy),    ## A
                    dp(n - 1, a_num + copy, copy), ## C-V
                    dp(n - 2, a_num, a_num)        ## C-A C-C
                )
    
        ## 可以按 N 次按键，屏幕和剪切板里都还没有 A
        return dp(N, 0, 0)

```

这个解法应该很好理解，因为语义明确。下面就继续走流程，用备忘录消除一下重叠子问题：

```java
    def maxA(N: int) -> int:
        ## 备忘录
        memo = dict()
        def dp(n, a_num, copy):
            if n <= 0: return a_num;
            ## 避免计算重叠子问题
            if (n, a_num, copy) in memo:
                return memo[(n, a_num, copy)]
    
            memo[(n, a_num, copy)] = max(
                    ## 几种选择还是一样的
                )
            return memo[(n, a_num, copy)]
    
        return dp(N, 0, 0)

```

这样优化代码之后，子问题虽然没有重复了，但数目仍然很多，在 LeetCode 提交会超时的。

我们尝试分析一下这个算法的时间复杂度，就会发现不容易分析。我们可以把这个 dp 函数写成 dp 数组：

```java
    dp[n][a_num][copy]
    ## 状态的总数（时空复杂度）就是这个三维数组的体积

```

我们知道变量 ` n ` 最多为 ` N ` ，但是 ` a_num ` 和 ` copy ` 最多为多少我们很难计算，复杂度起码也有 O(N^3)
把。所以这个算法并不好，复杂度太高，且已经无法优化了。

这也就说明，我们这样定义「状态」是不太优秀的，下面我们换一种定义 dp 的思路。

### 第二种思路

这种思路稍微有点复杂，但是效率高。继续走流程，「选择」还是那 4 个，但是这次我们只定义一个「状态」，也就是剩余的敲击次数 ` n ` 。

这个算法基于这样一个事实， **最优按键序列一定只有两种情况** ：

要么一直按 ` A ` ：A,A,…A（当 N 比较小时）。

要么是这么一个形式：A,A,…C-A,C-C,C-V,C-V,…C-V（当 N 比较大时）。

因为字符数量少（N 比较小）时， ` C-A C-C C-V ` 这一套操作的代价相对比较高，可能不如一个个按 ` A ` ；而当 N 比较大时，后期 `C-V ` 的收获肯定很大。这种情况下整个操作序列大致是： **开头连按几个` A ` ，然后 ` C-A C-C ` 组合再接若干 ` C-V `，然后再 ` C-A C-C ` 接着若干 ` C-V ` ，循环下去 ** 。

换句话说，最后一次按键要么是 ` A ` 要么是 ` C-V ` 。明确了这一点，可以通过这两种情况来设计算法：

```java
    int[] dp = new int[N + 1];
    // 定义：dp[i] 表示 i 次操作后最多能显示多少个 A
    for (int i = 0; i <= N; i++) 
        dp[i] = max(
                这次按 A 键，
                这次按 C-V
            )

```

对于「按 ` A ` 键」这种情况，就是状态 ` i - 1 ` 的屏幕上新增了一个 A 而已，很容易得到结果：

```java
    // 按 A 键，就比上次多一个 A 而已
    dp[i] = dp[i - 1] + 1;

```

但是，如果要按 ` C-V ` ，还要考虑之前是在哪里 ` C-A C-C ` 的。

**刚才说了，最优的操作序列一定是` C-A C-C ` 接着若干 ` C-V ` ，所以我们用一个变量 ` j ` 作为若干 ` C-V ` 的起点 **
。那么 ` j ` 之前的 2 个操作就应该是 ` C-A C-C ` 了：

```java
    public int maxA(int N) {
        int[] dp = new int[N + 1];
        dp[0] = 0;
        for (int i = 1; i <= N; i++) {
            // 按 A 键
            dp[i] = dp[i - 1] + 1;
            for (int j = 2; j < i; j++) {
                // 全选 & 复制 dp[j-2]，连续粘贴 i - j 次
                // 屏幕上共 dp[j - 2] * (i - j + 1) 个 A
                dp[i] = Math.max(dp[i], dp[j - 2] * (i - j + 1));
            }
        }
        // N 次按键之后最多有几个 A？
        return dp[N];
    }

```

其中 ` j ` 变量减 2 是给 ` C-A C-C ` 留下操作数，看个图就明白了：

![](https://labuladong.gitee.io/algo/images/4keyboard/1.jpg)

这样，此算法就完成了，时间复杂度 O(N^2)，空间复杂度 O(N)，这种解法应该是比较高效的了。

### 最后总结

动态规划难就难在寻找状态转移，不同的定义可以产生不同的状态转移逻辑，虽然最后都能得到正确的结果，但是效率可能有巨大的差异。

回顾第一种解法，重叠子问题已经消除了，但是效率还是低，到底低在哪里呢？抽象出递归框架：

```java
    def dp(n, a_num, copy):
        dp(n - 1, a_num + 1, copy),    ## A
        dp(n - 1, a_num + copy, copy), ## C-V
        dp(n - 2, a_num, a_num)        ## C-A C-C

```

看这个穷举逻辑，是有可能出现这样的操作序列 ` C-A C-C，C-A C-C... ` 或者 ` C-V,C-V,... `。然这种操作序列的结果不是最优的，但是我们并没有想办法规避这些情况的发生，从而增加了很多没必要的子问题计算。

回顾第二种解法，我们稍加思考就能想到，最优的序列应该是这种形式： ` A,A..C-A,C-C,C-V,C-V..C-A,C-C,C-V.. ` 。

根据这个事实，我们重新定义了状态，重新寻找了状态转移，从逻辑上减少了无效的子问题个数，从而提高了算法的效率。



## 团灭 LeetCode 股票买卖问题



读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 121. 买卖股票的最佳时机（简单） ](https://leetcode-cn.com/problems/best-time-to-buy-and-
sell-stock/)

[ 122. 买卖股票的最佳时机 II（简单） ](https://leetcode-cn.com/problems/best-time-to-buy-
and-sell-stock-ii/)

[ 123. 买卖股票的最佳时机 III（困难） ](https://leetcode-cn.com/problems/best-time-to-buy-
and-sell-stock-iii/)

[ 188. 买卖股票的最佳时机 IV（困难） ](https://leetcode-cn.com/problems/best-time-to-buy-
and-sell-stock-iv/)

[ 309. 最佳买卖股票时机含冷冻期（中等） ](https://leetcode-cn.com/problems/best-time-to-buy-
and-sell-stock-with-cooldown/)

[ 714. 买卖股票的最佳时机含手续费（中等） ](https://leetcode-cn.com/problems/best-time-to-buy-
and-sell-stock-with-transaction-fee/)

**———–**

很多读者抱怨 LeetCode 的股票系列问题奇技淫巧太多，如果面试真的遇到这类问题，基本不会想到那些巧妙的办法，怎么办？
**所以本文拒绝奇技淫巧，而是稳扎稳打，只用一种通用方法解决所用问题，以不变应万变** 。

这篇文章参考 [ 英文版高赞题解 ](https://leetcode.com/problems/best-time-to-buy-and-sell-
stock-with-transaction-fee/discuss/108870/Most-consistent-ways-of-dealing- with-the-series-of-stock-problems)
的思路，用状态机的技巧来解决，可以全部提交通过。不要觉得这个名词高大上，文学词汇而已，实际上就是 DP table，看一眼就明白了。

先随便抽出一道题，看看别人的解法：

```java
    int maxProfit(vector<int>& prices) {
        if(prices.empty()) return 0;
        int s1 = -prices[0], s2 = INT_MIN, s3 = INT_MIN, s4 = INT_MIN;
    
        for(int i = 1; i < prices.size(); ++i) {            
            s1 = max(s1, -prices[i]);
            s2 = max(s2, s1 + prices[i]);
            s3 = max(s3, s2 - prices[i]);
            s4 = max(s4, s3 + prices[i]);
        }
        return max(0, s4);
    }

```

能看懂吧？会做了吗？不可能的，你看不懂，这才正常。就算你勉强看懂了，下一个问题你还是做不出来。为什么别人能写出这么诡异却又高效的解法呢？因为这类问题是有框架的，但是人家不会告诉你的，因为一旦告诉你，你五分钟就学会了，该算法题就不再神秘，变得不堪一击了。

本文就来告诉你这个框架，然后带着你一道一道秒杀。这篇文章用状态机的技巧来解决，可以全部提交通过。不要觉得这个名词高大上，文学词汇而已，实际上就是 DP table，看一眼就明白了。

这 6 道题目是有共性的，我就抽出来第 4 道题目，因为这道题是一个最泛化的形式，其他的问题都是这个形式的简化，看下题目：

![](https://labuladong.gitee.io/algo/images/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/title.png)

第一题是只进行一次交易，相当于 ` k = 1 ` ；第二题是不限交易次数，相当于 ` k = +infinity ` （正无穷）；第三题是只进行 2 次交易，相当于 ` k = 2 `；剩下两道也是不限次数，但是加了交易「冷冻期」和「手续费」的额外条件，其实就是第二题的变种，都很容易处理。

如果你还不熟悉题目，可以去 LeetCode 查看这些题目的内容，本文为了节省篇幅，就不列举这些题目的具体内容了。下面言归正传，开始解题。

### 一、穷举框架

首先，还是一样的思路：如何穷举？

[ 动态规划核心套路 ](https://labuladong.gitee.io/algo/3/22/66/) 说过，动态规划算法本质上就是穷举「状态」，然后在「选择」中选择最优解。

那么对于这道题，我们具体到每一天，看看总共有几种可能的「状态」，再找出每个「状态」对应的「选择」。我们要穷举所有「状态」，穷举的目的是根据对应的「选择」更新状态。听起来抽象，你只要记住「状态」和「选择」两个词就行，下面实操一下就很容易明白了。

```java
    for 状态1 in 状态1的所有取值：
        for 状态2 in 状态2的所有取值：
            for ...
                dp[状态1][状态2][...] = 择优(选择1，选择2...)

```

比如说这个问题， **每天都有三种「选择」** ：买入、卖出、无操作，我们用 ` buy ` , ` sell ` , ` rest ` 表示这三种选择。

但问题是，并不是每天都可以任意选择这三种选择的，因为 ` sell ` 必须在 ` buy ` 之后， ` buy ` 必须在 ` sell ` 之后。那么
` rest ` 操作还应该分两种状态，一种是 ` buy ` 之后的 ` rest ` （持有了股票），一种是 ` sell ` 之后的 ` rest `（没有持有股票）。而且别忘了，我们还有交易次数 ` k ` 的限制，就是说你 ` buy ` 还只能在 ` k > 0 ` 的前提下操作。

很复杂对吧，不要怕，我们现在的目的只是穷举，你有再多的状态，老夫要做的就是一把梭全部列举出来。

**这个问题的「状态」有三个** ，第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态（即之前说的 ` rest ` 的状态，我们不妨用 1 表示持有，0 表示没有持有）。然后我们用一个三维数组就可以装下这几种状态的全部组合：

```java
    dp[i][k][0 or 1]
    0 <= i <= n - 1, 1 <= k <= K
    n 为天数，大 K 为交易数的上限，0 和 1 代表是否持有股票。
    此问题共 n × K × 2 种状态，全部穷举就能搞定。
    
    for 0 <= i < n:
        for 1 <= k <= K:
            for s in {0, 1}:
                dp[i][k][s] = max(buy, sell, rest)

```

而且我们可以用自然语言描述出每一个状态的含义，比如说 ` dp[3][2][1] ` 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。再比如 ` dp[2][3][0] `的含义：今天是第二天，我现在手上没有持有股票，至今最多进行 3 次交易。很容易理解，对吧？

我们想求的最终答案是 ` dp[n - 1][K][0] ` ，即最后一天，最多允许 ` K ` 次交易，最多获得多少利润。

读者可能问为什么不是 ` dp[n - 1][K][1] ` ？因为 ` dp[n - 1][K][1] ` 代表到最后一天手上还持有股票， ` dp[n

- 1][K][0] ` 表示最后一天手上的股票已经卖出去了，很显然后者得到的利润一定大于前者。

记住如何解释「状态」，一旦你觉得哪里不好理解，把它翻译成自然语言就容易理解了。

### 二、状态转移框架

现在，我们完成了「状态」的穷举，我们开始思考每种「状态」有哪些「选择」，应该如何更新「状态」。

只看「持有状态」，可以画个状态转移图：

![](https://labuladong.gitee.io/algo/images/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/1.png)

通过这个图可以很清楚地看到，每种状态（0 和 1）是如何转移而来的。根据这个图，我们来写一下状态转移方程：

```java
    dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
                  max( 今天选择 rest,        今天选择 sell       )

```

解释：今天我没有持有股票，有两种可能，我从这两种可能中求最大利润：

1、我昨天就没有持有，且截至昨天最大交易次数限制为 ` k ` ；然后我今天选择 ` rest ` ，所以我今天还是没有持有，最大交易次数限制依然为 ` k
` 。

2、我昨天持有股票，且截至昨天最大交易次数限制为 ` k ` ；但是今天我 ` sell ` 了，所以我今天没有持有股票了，最大交易次数限制依然为 ` k
` 。

```java
    dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
                  max( 今天选择 rest,         今天选择 buy         )

```

解释：今天我持有着股票，最大交易次数限制为 ` k ` ，那么对于昨天来说，有两种可能，我从这两种可能中求最大利润：

1、我昨天就持有着股票，且截至昨天最大交易次数限制为 ` k ` ；然后今天选择 ` rest ` ，所以我今天还持有着股票，最大交易次数限制依然为 ` k
` 。

2、我昨天本没有持有，且截至昨天最大交易次数限制为 ` k - 1 ` ；但今天我选择 ` buy ` ，所以今天我就持有股票了，最大交易次数限制为 ` k
` 。

> 这里着重提醒一下，时刻牢记「状态」的定义， ` k `> 的定义并不是「已进行的交易次数」，而是「最大交易次数的上限限制」。如果确定今天进行一次交易，且要保证截至今天最大交易次数上限为 ` k `> ，那么昨天的最大交易次数上限必须是 ` k - 1 ` 。

这个解释应该很清楚了，如果 ` buy ` ，就要从利润中减去 ` prices[i] ` ，如果 ` sell ` ，就要给利润增加 `prices[i] ` 。今天的最大利润就是这两种可能选择中较大的那个。

注意 ` k ` 的限制，在选择 ` buy ` 的时候相当于开启了一次交易，那么对于昨天来说，交易次数的上限 ` k ` 应该减小 1。

> 修正：以前我以为在 ` sell ` 的时候给 ` k ` 减小 1 和在 ` buy ` 的时候给 ` k ` 减小 1
> 是等效的，但细心的读者向我提出质疑，经过深入思考我发现前者确实是错误的，因为交易是从 ` buy ` 开始，如果 ` buy ` 的选择不改变交易次数
> ` k ` 的约束，会出现交易次数超出限制的的错误。

现在，我们已经完成了动态规划中最困难的一步：状态转移方程。 **如果之前的内容你都可以理解，那么你已经可以秒杀所有问题了，只要套这个框架就行了**
。不过还差最后一点点，就是定义 base case，即最简单的情况。

```java
    dp[-1][...][0] = 0
    解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0。
    
    dp[-1][...][1] = -infinity
    解释：还没开始的时候，是不可能持有股票的。
    因为我们的算法要求一个最大值，所以初始值设为一个最小值，方便取最大值。
    
    dp[...][0][0] = 0
    解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0。
    
    dp[...][0][1] = -infinity
    解释：不允许交易的情况下，是不可能持有股票的。
    因为我们的算法要求一个最大值，所以初始值设为一个最小值，方便取最大值。

```

把上面的状态转移方程总结一下：

```java
    base case：
    dp[-1][...][0] = dp[...][0][0] = 0
    dp[-1][...][1] = dp[...][0][1] = -infinity
    
    状态转移方程：
    dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
    dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])

```

读者可能会问，这个数组索引是 -1 怎么编程表示出来呢，负无穷怎么表示呢？这都是细节问题，有很多方法实现。现在完整的框架已经完成，下面开始具体化。

### 三、秒杀题目

**第一题，k = 1**

直接套状态转移方程，根据 base case，可以做一些化简：

```java
    dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])
    dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i]) 
                = max(dp[i-1][1][1], -prices[i])
    解释：k = 0 的 base case，所以 dp[i-1][0][0] = 0。
    
    现在发现 k 都是 1，不会改变，即 k 对状态转移已经没有影响了。
    可以进行进一步化简去掉所有 k：
    dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
    dp[i][1] = max(dp[i-1][1], -prices[i])

```

直接写出代码：

```java
    int n = prices.length;
    int[][] dp = new int[n][2];
    for (int i = 0; i < n; i++) {
        dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
        dp[i][1] = Math.max(dp[i-1][1], -prices[i]);
    }
    return dp[n - 1][0];

```

显然 ` i = 0 ` 时 ` i - 1 ` 是不合法的索引，这是因为我们没有对 ` i ` 的 base case 进行处理，可以这样给一个特化处理：

```java
    if (i - 1 == -1) {
        dp[i][0] = 0;
        // 根据状态转移方程可得：
        //   dp[i][0] 
        // = max(dp[-1][0], dp[-1][1] + prices[i])
        // = max(0, -infinity + prices[i]) = 0
    
        dp[i][1] = -prices[i];
        // 根据状态转移方程可得：
        //   dp[i][1] 
        // = max(dp[-1][1], dp[-1][0] - prices[i])
        // = max(-infinity, 0 - prices[i]) 
        // = -prices[i]
        continue;
    }

```

第一题就解决了，但是这样处理 base case 很麻烦，而且注意一下状态转移方程，新状态只和相邻的一个状态有关，其实不用整个 ` dp `数组，只需要一个变量储存相邻的那个状态就足够了，这样可以把空间复杂度降到 O(1):

```java
    // 原始版本
    int maxProfit_k_1(int[] prices) {
        int n = prices.length;
        int[][] dp = new int[n][2];
        for (int i = 0; i < n; i++) {
            if (i - 1 == -1) {
                // base case
                dp[i][0] = 0;
                dp[i][1] = -prices[i];
                continue;
            }
            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i-1][1], -prices[i]);
        }
        return dp[n - 1][0];
    }
    
    // 空间复杂度优化版本
    int maxProfit_k_1(int[] prices) {
        int n = prices.length;
        // base case: dp[-1][0] = 0, dp[-1][1] = -infinity
        int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;
        for (int i = 0; i < n; i++) {
            // dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
            dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
            // dp[i][1] = max(dp[i-1][1], -prices[i])
            dp_i_1 = Math.max(dp_i_1, -prices[i]);
        }
        return dp_i_0;
    }

```

两种方式都是一样的，不过这种编程方法简洁很多，但是如果没有前面状态转移方程的引导，是肯定看不懂的。后续的题目，你可以对比一下如何把 ` dp `数组的空间优化掉。

**第二题，k = +infinity**

如果 ` k ` 为正无穷，那么就可以认为 ` k ` 和 ` k - 1 ` 是一样的。可以这样改写框架：

```java
    dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
    dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
                = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i])
    
    我们发现数组中的 k 已经不会改变了，也就是说不需要记录 k 这个状态了：
    dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
    dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])

```

直接翻译成代码：

```java
    // 原始版本
    int maxProfit_k_inf(int[] prices) {
        int n = prices.length;
        int[][] dp = new int[n][2];
        for (int i = 0; i < n; i++) {
            if (i - 1 == -1) {
                // base case
                dp[i][0] = 0;
                dp[i][1] = -prices[i];
                continue;
            }
            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] - prices[i]);
        }
        return dp[n - 1][0];
    }
    
    // 空间复杂度优化版本
    int maxProfit_k_inf(int[] prices) {
        int n = prices.length;
        int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;
        for (int i = 0; i < n; i++) {
            int temp = dp_i_0;
            dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
            dp_i_1 = Math.max(dp_i_1, temp - prices[i]);
        }
        return dp_i_0;
    }

```

**第三题，k = +infinity with cooldown**

每次 ` sell ` 之后要等一天才能继续交易。只要把这个特点融入上一题的状态转移方程即可：

```java
    dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
    dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])
    解释：第 i 天选择 buy 的时候，要从 i-2 的状态转移，而不是 i-1 。

```

翻译成代码：

```java
    // 原始版本
    int maxProfit_with_cool(int[] prices) {
        int n = prices.length;
        int[][] dp = new int[n][2];
        for (int i = 0; i < n; i++) {
            if (i - 1 == -1) {
                // base case 1
                dp[i][0] = 0;
                dp[i][1] = -prices[i];
                continue;
            }
            if (i - 2 == -1) {
                // base case 2
                dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
                // i - 2 小于 0 时根据状态转移方程推出对应 base case
                dp[i][1] = Math.max(dp[i-1][1], -prices[i]);
                //   dp[i][1] 
                // = max(dp[i-1][1], dp[-1][0] - prices[i])
                // = max(dp[i-1][1], 0 - prices[i])
                // = max(dp[i-1][1], -prices[i])
                continue;
            }
            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i-1][1], dp[i-2][0] - prices[i]);
        }
        return dp[n - 1][0];
    }
    
    // 空间复杂度优化版本
    int maxProfit_with_cool(int[] prices) {
        int n = prices.length;
        int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;
        int dp_pre_0 = 0; // 代表 dp[i-2][0]
        for (int i = 0; i < n; i++) {
            int temp = dp_i_0;
            dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
            dp_i_1 = Math.max(dp_i_1, dp_pre_0 - prices[i]);
            dp_pre_0 = temp;
        }
        return dp_i_0;
    }

```

**第四题，k = +infinity with fee**

每次交易要支付手续费，只要把手续费从利润中减去即可。改写方程：

```java
    dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
    dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i] - fee)
    解释：相当于买入股票的价格升高了。
    在第一个式子里减也是一样的，相当于卖出股票的价格减小了。

```

> 如果直接把 ` fee ` 放在第一个式子里减，会有测试用例无法通过，错误原因是整型溢出而不是思路问题。一种解决方案是把代码中的 ` int `> 类型都改成 ` long ` 类型，避免 ` int ` 的整型溢出。

直接翻译成代码，注意状态转移方程改变后 base case 也要做出对应改变：

```java
    // 原始版本
    int maxProfit_with_fee(int[] prices, int fee) {
        int n = prices.length;
        int[][] dp = new int[n][2];
        for (int i = 0; i < n; i++) {
            if (i - 1 == -1) {
                // base case
                dp[i][0] = 0;
                dp[i][1] = -prices[i] - fee;
                //   dp[i][1]
                // = max(dp[i - 1][1], dp[i - 1][0] - prices[i] - fee)
                // = max(dp[-1][1], dp[-1][0] - prices[i] - fee)
                // = max(-inf, 0 - prices[i] - fee)
                // = -prices[i] - fee
                continue;
            }
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i] - fee);
        }
        return dp[n - 1][0];
    }
    
    // 空间复杂度优化版本
    int maxProfit_with_fee(int[] prices, int fee) {
        int n = prices.length;
        int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;
        for (int i = 0; i < n; i++) {
            int temp = dp_i_0;
            dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
            dp_i_1 = Math.max(dp_i_1, temp - prices[i] - fee);
        }
        return dp_i_0;
    }

```

**第五题，k = 2**

` k = 2 ` 和前面题目的情况稍微不同，因为上面的情况都和 ` k ` 的关系不太大。要么 ` k ` 是正无穷，状态转移和 ` k `没关系了；要么 ` k = 1 ` ，跟 ` k = 0 ` 这个 base case 挨得近，最后也没有存在感。

这道题 ` k = 2 ` 和后面要讲的 ` k ` 是任意正整数的情况中，对 ` k ` 的处理就凸显出来了。我们直接写代码，边写边分析原因。

```java
    原始的状态转移方程，没有可化简的地方
    dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
    dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])

```

按照之前的代码，我们可能想当然这样写代码（错误的）：

```java
    int k = 2;
    int[][][] dp = new int[n][k + 1][2];
    for (int i = 0; i < n; i++) {
        if (i - 1 == -1) {
            // 处理 base case
            dp[i][k][0] = 0;
            dp[i][k][1] = -prices[i];
            continue;
        }
        dp[i][k][0] = Math.max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);
        dp[i][k][1] = Math.max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);
    }
    return dp[n - 1][k][0];

```

为什么错误？我这不是照着状态转移方程写的吗？

还记得前面总结的「穷举框架」吗？就是说我们必须穷举所有状态。其实我们之前的解法，都在穷举所有状态，只是之前的题目中 ` k ` 都被化简掉了。

比如说第一题， ` k = 1 ` 时的代码框架：

```java
    int n = prices.length;
    int[][] dp = new int[n][2];
    for (int i = 0; i < n; i++) {
        dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
        dp[i][1] = Math.max(dp[i-1][1], -prices[i]);
    }
    return dp[n - 1][0];

```

但当 ` k = 2 ` 时，由于没有消掉 ` k ` 的影响，所以必须要对 ` k ` 进行穷举：

```java
    // 原始版本
    int maxProfit_k_2(int[] prices) {
        int max_k = 2, n = prices.length;
        int[][][] dp = new int[n][max_k + 1][2];
        for (int i = 0; i < n; i++) {
            for (int k = max_k; k >= 1; k--) {
                if (i - 1 == -1) {
                    // 处理 base case
                    dp[i][k][0] = 0;
                    dp[i][k][1] = -prices[i];
                    continue;
                }
                dp[i][k][0] = Math.max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);
                dp[i][k][1] = Math.max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);
            }
        }
        // 穷举了 n × max_k × 2 个状态，正确。
        return dp[n - 1][max_k][0];
    }

```

> **PS：这里肯定会有读者疑惑，` k ` 的 base case 是 0，按理说应该从 ` k = 1, k++ ` 这样穷举状态 ` k `> 才对？而且如果你真的这样从小到大遍历 ` k ` ，提交发现也是可以的 ** 。

这个疑问很正确，因为我们前文 [ 动态规划答疑篇 ](https://labuladong.gitee.io/algo/3/22/68/) 有介绍 ` dp ` 数组的遍历顺序是怎么确定的，主要是根据 base case，以 base case 为起点，逐步向结果靠近。

但为什么我从大到小遍历 ` k ` 也可以正确提交呢？因为你注意看， ` dp[i][k] ` 不会依赖 ` dp[i][k - 1] ` ，而是依赖 `dp[i - 1][k - 1] ` ，对于 ` dp[i - 1][...] ` ，都是已经计算出来的。所以不管你是 ` k = max_k, k-- `，还是 ` k = 1, k++ ` ，都是可以得出正确答案的。

那为什么我使用 ` k = max_k, k-- ` 的方式呢？因为这样符合语义。

你买股票，初始的「状态」是什么？应该是从第 0 天开始，而且还没有进行过买卖，所以最大交易次数限制 ` k ` 应该是 ` max_k `；而随着「状态」的推移，你会进行交易，那么交易次数上限 ` k ` 应该不断减少，这样一想， ` k = max_k, k-- `的方式是比较合乎实际场景的。

当然，这里 ` k ` 取值范围比较小，所以可以不用 for 循环，直接把 k = 1 和 2 的情况全部列举出来也可以：

```java
    // 状态转移方程：
    // dp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])
    // dp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])
    // dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])
    // dp[i][1][1] = max(dp[i-1][1][1], -prices[i])
    
    // 空间复杂度优化版本
    int maxProfit_k_2(int[] prices) {
        // base case
        int dp_i10 = 0, dp_i11 = Integer.MIN_VALUE;
        int dp_i20 = 0, dp_i21 = Integer.MIN_VALUE;
        for (int price : prices) {
            dp_i20 = Math.max(dp_i20, dp_i21 + price);
            dp_i21 = Math.max(dp_i21, dp_i10 - price);
            dp_i10 = Math.max(dp_i10, dp_i11 + price);
            dp_i11 = Math.max(dp_i11, -price);
        }
        return dp_i20;
    }

```

有状态转移方程和含义明确的变量名指导，相信你很容易看懂。其实我们可以故弄玄虚，把上述四个变量换成 ` a, b, c, d `。这样当别人看到你的代码时就会大惊失色，对你肃然起敬。

**第六题，k = any integer**

有了上一题 ` k = 2 ` 的铺垫，这题应该和上一题的第一个解法没啥区别。但是出现了一个超内存的错误，原来是传入的 ` k ` 值会非常大， ` dp
` 数组太大了。现在想想，交易次数 ` k ` 最多有多大呢？

一次交易由买入和卖出构成，至少需要两天。所以说有效的限制 ` k ` 应该不超过 ` n/2 ` ，如果超过，就没有约束作用了，相当于 ` k = +infinity ` 。这种情况是之前解决过的。

直接把之前的代码重用：

```java
    int maxProfit_k_any(int max_k, int[] prices) {
        int n = prices.length;
        if (n <= 0) {
            return 0;
        }
        if (max_k > n / 2) {
            // 交易次数 k 没有限制的情况
            return maxProfit_k_inf(prices);
        }
    
        // base case：
        // dp[-1][...][0] = dp[...][0][0] = 0
        // dp[-1][...][1] = dp[...][0][1] = -infinity
        int[][][] dp = new int[n][max_k + 1][2];
        // k = 0 时的 base case
        for (int i = 0; i < n; i++) {
            dp[i][0][1] = Integer.MIN_VALUE;
            dp[i][0][0] = 0;
        }
    
        for (int i = 0; i < n; i++) 
            for (int k = max_k; k >= 1; k--) {
                if (i - 1 == -1) {
                    // 处理 i = -1 时的 base case
                    dp[i][k][0] = 0;
                    dp[i][k][1] = -prices[i];
                    continue;
                }
                dp[i][k][0] = Math.max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);
                dp[i][k][1] = Math.max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);     
            }
        return dp[n - 1][max_k][0];
    }

```

至此，6 道题目通过一个状态转移方程全部解决。

**四、最后总结**

本文给大家讲了如何通过状态转移的方法解决复杂的问题，用一个状态转移方程秒杀了 6 道股票买卖问题，现在想想，其实也不算难对吧？这已经属于动态规划问题中较困难的了。

关键就在于列举出所有可能的「状态」，然后想想怎么穷举更新这些「状态」。一般用一个多维 ` dp ` 数组储存这些状态，从 base case
开始向后推进，推进到最后的状态，就是我们想要的答案。想想这个过程，你是不是有点理解「动态规划」这个名词的意义了呢？

具体到股票买卖问题，我们发现了三个状态，使用了一个三维数组，无非还是穷举 + 更新，不过我们可以说的高大上一点，这叫「三维 DP」，怕不怕？这个大实话一说，立刻显得你高人一等，名利双收有没有，所以给个在看/分享吧，鼓励一下我。



## 团灭 LeetCode 打家劫舍问题



读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 198. 打家劫舍（简单） ](https://leetcode-cn.com/problems/house-robber)

[ 213. 打家劫舍II（中等） ](https://leetcode-cn.com/problems/house-robber-ii)

[ 337. 打家劫舍III（中等） ](https://leetcode-cn.com/problems/house-robber-iii)

**———–**

有读者私下问我 LeetCode 「打家劫舍」系列问题（英文版叫 House Robber）怎么做，我发现这一系列题目的点赞非常之高，是比较有代表性和技巧性的动态规划题目，今天就来聊聊这道题目。

打家劫舍系列总共有三道，难度设计非常合理，层层递进。第一道是比较标准的动态规划问题，而第二道融入了环形数组的条件，第三道更绝，把动态规划的自底向上和自顶向下解法和二叉树结合起来，我认为很有启发性。如果没做过的朋友，建议学习一下。

下面，我们从第一道开始分析。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**

应合作方要求，本文不便在此发布，请扫码关注回复关键词「抢房子」查看：

![](https://labuladong.gitee.io/algo/images/qrcode.jpg)

## 有限状态机之 KMP 字符匹配算法



读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 28. 实现 strStr(简单) ](https://leetcode-cn.com/problems/implement-strstr)

**———–**

KMP 算法（Knuth-Morris-Pratt 算法）是一个著名的字符串匹配算法，效率很高，但是确实有点复杂。

很多读者抱怨 KMP 算法无法理解，这很正常，想到大学教材上关于 KMP 算法的讲解，也不知道有多少未来的 Knuth、Morris、Pratt 被提前劝退了。有一些优秀的同学通过手推 KMP
算法的过程来辅助理解该算法，这是一种办法，不过本文要从逻辑层面帮助读者理解算法的原理。十行代码之间，KMP 灰飞烟灭。

**先在开头约定，本文用` pat ` 表示模式串，长度为 ` M ` ， ` txt ` 表示文本串，长度为 ` N ` 。KMP 算法是在 ` txt
` 中查找子串 ` pat ` ，如果存在，返回这个子串的起始索引，否则返回 -1 ** 。

为什么我认为 KMP 算法就是个动态规划问题呢，等会再解释。对于动态规划，之前多次强调了要明确 ` dp ` 数组的含义，而且同一个问题可能有不止一种定义
` dp ` 数组含义的方法，不同的定义会有不同的解法。

读者见过的 KMP 算法应该是，一波诡异的操作处理 ` pat ` 后形成一个一维的数组 ` next ` ，然后根据这个数组经过又一波复杂操作去匹配 `txt ` 。时间复杂度 O(N)，空间复杂度 O(M)。其实它这个 ` next ` 数组就相当于 ` dp ` 数组，其中元素的含义跟 ` pat `的前缀和后缀有关，判定规则比较复杂，不好理解。 **本文则用一个二维的` dp ` 数组（但空间复杂度还是 O(M)），重新定义其中元素的含义，使得代码长度大大减少，可解释性大大提高 ** 。

> PS：本文的代码参考《算法4》，原代码使用的数组名称是 ` dfa `> （确定有限状态机），因为我们的公众号之前有一系列动态规划的文章，就不说这么高大上的名词了，我对书中代码进行了一点修改，并沿用 ` dp ` 数组的名称。

### 一、KMP 算法概述

首先还是简单介绍一下 KMP 算法和暴力匹配算法的不同在哪里，难点在哪里，和动态规划有啥关系。

暴力的字符串匹配算法很容易写，看一下它的运行逻辑：

```java
    // 暴力匹配（伪码）
    int search(String pat, String txt) {
        int M = pat.length;
        int N = txt.length;
        for (int i = 0; i <= N - M; i++) {
            int j;
            for (j = 0; j < M; j++) {
                if (pat[j] != txt[i+j])
                    break;
            }
            // pat 全都匹配了
            if (j == M) return i;
        }
        // txt 中不存在 pat 子串
        return -1;
    }

```

对于暴力算法，如果出现不匹配字符，同时回退 ` txt ` 和 ` pat ` 的指针，嵌套 for 循环，时间复杂度 ` O(MN) ` ，空间复杂度 `O(1) ` 。最主要的问题是，如果字符串中重复的字符比较多，该算法就显得很蠢。

比如 txt = “aaacaaab” pat = “aaab”：

![](https://labuladong.gitee.io/algo/images/kmp/1.gif)

很明显， ` pat ` 中根本没有字符 c，根本没必要回退指针 ` i ` ，暴力解法明显多做了很多不必要的操作。

KMP 算法的不同之处在于，它会花费空间来记录一些信息，在上述情况中就会显得很聪明：

![](https://labuladong.gitee.io/algo/images/kmp/2.gif)

再比如类似的 txt = “aaaaaaab” pat = “aaab”，暴力解法还会和上面那个例子一样蠢蠢地回退指针 ` i ` ，而 KMP 算法又会耍聪明：

![](https://labuladong.gitee.io/algo/images/kmp/3.gif)

因为 KMP 算法知道字符 b 之前的字符 a 都是匹配的，所以每次只需要比较字符 b 是否被匹配就行了。

**KMP 算法永不回退` txt ` 的指针 ` i ` ，不走回头路（不会重复扫描 ` txt ` ），而是借助 ` dp ` 数组中储存的信息把 `pat ` 移到正确的位置继续匹配 ** ，时间复杂度只需 O(N)，用空间换时间，所以我认为它是一种动态规划算法。

KMP 算法的难点在于，如何计算 ` dp ` 数组中的信息？如何根据这些信息正确地移动 ` pat ` 的指针？这个就需要 **确定有限状态自动机**
来辅助了，别怕这种高大上的文学词汇，其实和动态规划的 ` dp ` 数组如出一辙，等你学会了也可以拿这个词去吓唬别人。

还有一点需要明确的是： **计算这个` dp ` 数组，只和 ` pat ` 串有关 ** 。意思是说，只要给我个 ` pat `，我就能通过这个模式串计算出 ` dp ` 数组，然后你可以给我不同的 ` txt ` ，我都不怕，利用这个 ` dp ` 数组我都能在 O(N)
时间完成字符串匹配。

具体来说，比如上文举的两个例子：

```java
    txt1 = "aaacaaab" 
    pat = "aaab"
    txt2 = "aaaaaaab" 
    pat = "aaab"

```

我们的 ` txt ` 不同，但是 ` pat ` 是一样的，所以 KMP 算法使用的 ` dp ` 数组是同一个。

只不过对于 ` txt1 ` 的下面这个即将出现的未匹配情况：

![](https://labuladong.gitee.io/algo/images/kmp/txt1.jpg)

` dp ` 数组指示 ` pat ` 这样移动：

![](https://labuladong.gitee.io/algo/images/kmp/txt2.jpg)

> PS：这个 ` j ` 不要理解为索引，它的含义更准确地说应该是 **状态** （state），所以它会出现这个奇怪的位置，后文会详述。

而对于 ` txt2 ` 的下面这个即将出现的未匹配情况：

![](https://labuladong.gitee.io/algo/images/kmp/txt3.jpg)

` dp ` 数组指示 ` pat ` 这样移动：

![](https://labuladong.gitee.io/algo/images/kmp/txt4.jpg)

明白了 ` dp ` 数组只和 ` pat ` 有关，那么我们这样设计 KMP 算法就会比较漂亮：

```java
    public class KMP {
        private int[][] dp;
        private String pat;
    
        public KMP(String pat) {
            this.pat = pat;
            // 通过 pat 构建 dp 数组
            // 需要 O(M) 时间
        }
    
        public int search(String txt) {
            // 借助 dp 数组去匹配 txt
            // 需要 O(N) 时间
        }
    }

```

这样，当我们需要用同一 ` pat ` 去匹配不同 ` txt ` 时，就不需要浪费时间构造 ` dp ` 数组了：

```java
    KMP kmp = new KMP("aaab");
    int pos1 = kmp.search("aaacaaab"); //4
    int pos2 = kmp.search("aaaaaaab"); //4

```

### 二、状态机概述

为什么说 KMP 算法和状态机有关呢？是这样的，我们可以认为 ` pat ` 的匹配就是状态的转移。比如当 pat = “ABABC”：

![](https://labuladong.gitee.io/algo/images/kmp/state.jpg)

如上图，圆圈内的数字就是状态，状态 0 是起始状态，状态 5（ ` pat.length ` ）是终止状态。开始匹配时 ` pat `处于起始状态，一旦转移到终止状态，就说明在 ` txt ` 中找到了 ` pat ` 。比如说当前处于状态 2，就说明字符 “AB” 被匹配：

![](https://labuladong.gitee.io/algo/images/kmp/state2.jpg)

另外，处于不同状态时， ` pat ` 状态转移的行为也不同。比如说假设现在匹配到了状态 4，如果遇到字符 A 就应该转移到状态 3，遇到字符 C 就应该转移到状态 5，如果遇到字符 B 就应该转移到状态 0：

![](https://labuladong.gitee.io/algo/images/kmp/state4.jpg)

具体什么意思呢，我们来一个个举例看看。用变量 ` j ` 表示指向当前状态的指针，当前 ` pat ` 匹配到了状态 4：

![](https://labuladong.gitee.io/algo/images/kmp/exp1.jpg)

如果遇到了字符 “A”，根据箭头指示，转移到状态 3 是最聪明的：

![](https://labuladong.gitee.io/algo/images/kmp/exp3.jpg)

如果遇到了字符 “B”，根据箭头指示，只能转移到状态 0（一夜回到解放前）：

![](https://labuladong.gitee.io/algo/images/kmp/exp5.jpg)

如果遇到了字符 “C”，根据箭头指示，应该转移到终止状态 5，这也就意味着匹配完成：

![](https://labuladong.gitee.io/algo/images/kmp/exp7.jpg)

当然了，还可能遇到其他字符，比如 Z，但是显然应该转移到起始状态 0，因为 ` pat ` 中根本都没有字符 Z：

![](https://labuladong.gitee.io/algo/images/kmp/z.jpg)

这里为了清晰起见，我们画状态图时就把其他字符转移到状态 0 的箭头省略，只画 ` pat ` 中出现的字符的状态转移：

![](https://labuladong.gitee.io/algo/images/kmp/allstate.jpg)

KMP 算法最关键的步骤就是构造这个状态转移图。 **要确定状态转移的行为，得明确两个变量，一个是当前的匹配状态，另一个是遇到的字符**
；确定了这两个变量后，就可以知道这个情况下应该转移到哪个状态。

下面看一下 KMP 算法根据这幅状态转移图匹配字符串 ` txt ` 的过程：

![](https://labuladong.gitee.io/algo/images/kmp/kmp.gif)

**请记住这个 GIF 的匹配过程，这就是 KMP 算法的核心逻辑** ！

为了描述状态转移图，我们定义一个二维 dp 数组，它的含义如下：

```java
    dp[j][c] = next
    0 <= j < M，代表当前的状态
    0 <= c < 256，代表遇到的字符（ASCII 码）
    0 <= next <= M，代表下一个状态
    
    dp[4]['A'] = 3 表示：
    当前是状态 4，如果遇到字符 A，
    pat 应该转移到状态 3
    
    dp[1]['B'] = 2 表示：
    当前是状态 1，如果遇到字符 B，
    pat 应该转移到状态 2

```

根据我们这个 dp 数组的定义和刚才状态转移的过程，我们可以先写出 KMP 算法的 search 函数代码：

```java
    public int search(String txt) {
        int M = pat.length();
        int N = txt.length();
        // pat 的初始态为 0
        int j = 0;
        for (int i = 0; i < N; i++) {
            // 当前是状态 j，遇到字符 txt[i]，
            // pat 应该转移到哪个状态？
            j = dp[j][txt.charAt(i)];
            // 如果达到终止态，返回匹配开头的索引
            if (j == M) return i - M + 1;
        }
        // 没到达终止态，匹配失败
        return -1;
    }

```

到这里，应该还是很好理解的吧， ` dp ` 数组就是我们刚才画的那幅状态转移图，如果不清楚的话回去看下 GIF 的算法演进过程。下面讲解：如何通过 `pat ` 构建这个 ` dp ` 数组？

### 三、构建状态转移图

回想刚才说的： **要确定状态转移的行为，必须明确两个变量，一个是当前的匹配状态，另一个是遇到的字符** ，而且我们已经根据这个逻辑确定了 ` dp `数组的含义，那么构造 ` dp ` 数组的框架就是这样：

```java
    for 0 <= j < M: ## 状态
        for 0 <= c < 256: ## 字符
            dp[j][c] = next

```

这个 next 状态应该怎么求呢？显然， **如果遇到的字符` c ` 和 ` pat[j] ` 匹配的话 ** ，状态就应该向前推进一个，也就是说 `next = j + 1 ` ，我们不妨称这种情况为 **状态推进** ：

![](https://labuladong.gitee.io/algo/images/kmp/forward.jpg)

**如果字符` c ` 和 ` pat[j] ` 不匹配的话 ** ，状态就要回退（或者原地不动），我们不妨称这种情况为 **状态重启** ：

![](https://labuladong.gitee.io/algo/images/kmp/back.jpg)

那么，如何得知在哪个状态重启呢？解答这个问题之前，我们再定义一个名字： **影子状态** （我编的名字），用变量 ` X ` 表示。
**所谓影子状态，就是和当前状态具有相同的前缀** 。比如下面这种情况：

![](https://labuladong.gitee.io/algo/images/kmp/shadow.jpg)

当前状态 ` j = 4 ` ，其影子状态为 ` X = 2 ` ，它们都有相同的前缀 “AB”。因为状态 ` X ` 和状态 ` j `存在相同的前缀，所以当状态 ` j ` 准备进行状态重启的时候（遇到的字符 ` c ` 和 ` pat[j] ` 不匹配），可以通过 ` X `的状态转移图来获得 **最近的重启位置** 。

比如说刚才的情况，如果状态 ` j ` 遇到一个字符 “A”，应该转移到哪里呢？首先只有遇到 “C” 才能推进状态，遇到 “A” 显然只能进行状态重启。
**状态` j ` 会把这个字符委托给状态 ` X ` 处理，也就是 ` dp[j]['A'] = dp[X]['A'] ` ** ：

![](https://labuladong.gitee.io/algo/images/kmp/shadow1.jpg)

为什么这样可以呢？因为：既然 ` j ` 这边已经确定字符 “A” 无法推进状态， **只能回退** ，而且 KMP 就是要 **尽可能少的回退**
，以免多余的计算。那么 ` j ` 就可以去问问和自己具有相同前缀的 ` X ` ，如果 ` X ` 遇见 “A” 可以进行「状态推进」，那就转移过去，因为这样回退最少。

![](https://labuladong.gitee.io/algo/images/kmp/A.gif)

当然，如果遇到的字符是 “B”，状态 ` X ` 也不能进行「状态推进」，只能回退， ` j ` 只要跟着 ` X ` 指引的方向回退就行了：

![](https://labuladong.gitee.io/algo/images/kmp/shadow2.jpg)

你也许会问，这个 ` X ` 怎么知道遇到字符 “B” 要回退到状态 0 呢？因为 ` X ` 永远跟在 ` j ` 的身后，状态 ` X `如何转移，在之前就已经算出来了。动态规划算法不就是利用过去的结果解决现在的问题吗？

这样，我们就细化一下刚才的框架代码：

```java
    int X ## 影子状态
    for 0 <= j < M:
        for 0 <= c < 256:
            if c == pat[j]:
                ## 状态推进
                dp[j][c] = j + 1
            else: 
                ## 状态重启
                ## 委托 X 计算重启位置
                dp[j][c] = dp[X][c] 

```

### 四、代码实现

如果之前的内容你都能理解，恭喜你，现在就剩下一个问题：影子状态 ` X ` 是如何得到的呢？下面先直接看完整代码吧。

```java
    public class KMP {
        private int[][] dp;
        private String pat;
    
        public KMP(String pat) {
            this.pat = pat;
            int M = pat.length();
            // dp[状态][字符] = 下个状态
            dp = new int[M][256];
            // base case
            dp[0][pat.charAt(0)] = 1;
            // 影子状态 X 初始为 0
            int X = 0;
            // 当前状态 j 从 1 开始
            for (int j = 1; j < M; j++) {
                for (int c = 0; c < 256; c++) {
                    if (pat.charAt(j) == c) 
                        dp[j][c] = j + 1;
                    else 
                        dp[j][c] = dp[X][c];
                }
                // 更新影子状态
                X = dp[X][pat.charAt(j)];
            }
        }
    
        public int search(String txt) {...}
    }

```

先解释一下这一行代码：

```java
    // base case
    dp[0][pat.charAt(0)] = 1;

```

这行代码是 base case，只有遇到 pat[0] 这个字符才能使状态从 0 转移到 1，遇到其它字符的话还是停留在状态 0（Java 默认初始化数组全为 0）。

影子状态 ` X ` 是先初始化为 0，然后随着 ` j ` 的前进而不断更新的。下面看看到底应该 **如何更新影子状态` X ` ** ：

```java
    int X = 0;
    for (int j = 1; j < M; j++) {
        ...
        // 更新影子状态
        // 当前是状态 X，遇到字符 pat[j]，
        // pat 应该转移到哪个状态？
        X = dp[X][pat.charAt(j)];
    }

```

更新 ` X ` 其实和 ` search ` 函数中更新状态 ` j ` 的过程是非常相似的：

```java
    int j = 0;
    for (int i = 0; i < N; i++) {
        // 当前是状态 j，遇到字符 txt[i]，
        // pat 应该转移到哪个状态？
        j = dp[j][txt.charAt(i)];
        ...
    }

```

**其中的原理非常微妙** ，注意代码中 for 循环的变量初始值，可以这样理解：后者是在 ` txt ` 中匹配 ` pat ` ，前者是在 ` pat
` 中匹配 ` pat[1..end] ` ，状态 ` X ` 总是落后状态 ` j ` 一个状态，与 ` j ` 具有最长的相同前缀。所以我把 ` X `比喻为影子状态，似乎也有一点贴切。

另外，构建 dp 数组是根据 base case ` dp[0][..] ` 向后推演。这就是我认为 KMP 算法就是一种动态规划算法的原因。

下面来看一下状态转移图的完整构造过程，你就能理解状态 ` X ` 作用之精妙了：

![](https://labuladong.gitee.io/algo/images/kmp/dfa.gif)

至此，KMP 算法的核心终于写完啦啦啦啦！看下 KMP 算法的完整代码吧：

```java
    public class KMP {
        private int[][] dp;
        private String pat;
    
        public KMP(String pat) {
            this.pat = pat;
            int M = pat.length();
            // dp[状态][字符] = 下个状态
            dp = new int[M][256];
            // base case
            dp[0][pat.charAt(0)] = 1;
            // 影子状态 X 初始为 0
            int X = 0;
            // 构建状态转移图（稍改的更紧凑了）
            for (int j = 1; j < M; j++) {
                for (int c = 0; c < 256; c++)
                    dp[j][c] = dp[X][c];
                dp[j][pat.charAt(j)] = j + 1;
                // 更新影子状态
                X = dp[X][pat.charAt(j)];
            }
        }
    
        public int search(String txt) {
            int M = pat.length();
            int N = txt.length();
            // pat 的初始态为 0
            int j = 0;
            for (int i = 0; i < N; i++) {
                // 计算 pat 的下一个状态
                j = dp[j][txt.charAt(i)];
                // 到达终止态，返回结果
                if (j == M) return i - M + 1;
            }
            // 没到达终止态，匹配失败
            return -1;
        }
    }

```

经过之前的详细举例讲解，你应该可以理解这段代码的含义了，当然你也可以把 KMP 算法写成一个函数。核心代码也就是两个函数中 for 循环的部分，数一下有超过十行吗？

### 五、最后总结

传统的 KMP 算法是使用一个一维数组 ` next ` 记录前缀信息，而本文是使用一个二维数组 ` dp `以状态转移的角度解决字符匹配问题，但是空间复杂度仍然是 O(256M) = O(M)。

在 ` pat ` 匹配 ` txt `的过程中，只要明确了「当前处在哪个状态」和「遇到的字符是什么」这两个问题，就可以确定应该转移到哪个状态（推进或回退）。

对于一个模式串 ` pat ` ，其总共就有 M 个状态，对于 ASCII 字符，总共不会超过 256 种。所以我们就构造一个数组 ` dp[M][256]
` 来包含所有情况，并且明确 ` dp ` 数组的含义：

` dp[j][c] = next ` 表示，当前是状态 ` j ` ，遇到了字符 ` c ` ，应该转移到状态 ` next ` 。

明确了其含义，就可以很容易写出 search 函数的代码。

对于如何构建这个 ` dp ` 数组，需要一个辅助状态 ` X ` ，它永远比当前状态 ` j ` 落后一个状态，拥有和 ` j `最长的相同前缀，我们给它起了个名字叫「影子状态」。

在构建当前状态 ` j ` 的转移方向时，只有字符 ` pat[j] ` 才能使状态推进（ ` dp[j][pat[j]] = j+1 `）；而对于其他字符只能进行状态回退，应该去请教影子状态 ` X ` 应该回退到哪里（ ` dp[j][other] = dp[X][other] ` ，其中
` other ` 是除了 ` pat[j] ` 之外所有字符）。

对于影子状态 ` X ` ，我们把它初始化为 0，并且随着 ` j ` 的前进进行更新，更新的方式和 search 过程更新 ` j ` 的过程非常相似（
` X = dp[X][pat[j]] ` ）。

KMP 算法也就是动态规划那点事，我们的公众号文章目录有一系列专门讲动态规划的，而且都是按照一套框架来的，无非就是描述问题逻辑，明确 ` dp `数组含义，定义 base case 这点破事。希望这篇文章能让大家对动态规划有更深的理解。



## 构造回文的最小插入次数



读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 1312. 让字符串成为回文串的最少插入次数（困难） ](https://leetcode-cn.com/problems/minimum-
insertion-steps-to-make-a-string-palindrome)

**———–**

回文串就是正着读反着读都一样的字符，在笔试面试中经常出现这类问题。

公众号有好几篇讲解回文问题的文章，是判断回文串或者寻找最长回文串/子序列的：

[ 判断回文链表 ](https://labuladong.gitee.io/algo/2/16/18/)

[ 计算最长回文子串 ](https://labuladong.gitee.io/algo/4/31/134/)

[ 计算最长回文子序列 ](https://labuladong.gitee.io/algo/3/23/78/)

本文就来研究一道构造回文串的问题，难度 Hard 计算让字符串成为回文串的最少插入次数：

输入一个字符串 ` s ` ，你可以在字符串的任意位置插入任意字符。如果要把 ` s ` 变成回文串，请你计算最少要进行多少次插入？

函数签名如下：

```java
    int minInsertions(string s);

```

比如说输入 ` s = "abcea" ` ，算法返回 2，因为可以给 ` s ` 插入 2 个字符变成回文串 ` "abeceba" ` 或者 `"aebcbea" ` 。如果输入 ` s = "aba" ` ，则算法返回 0，因为 ` s ` 已经是回文串，不用插入任何字符。

### 思路解析

首先，要找最少的插入次数，那肯定得穷举喽，如果我们用暴力算法穷举出所有插入方法，时间复杂度是多少？

每次都可以在两个字符的中间插入任意一个字符，外加判断字符串是否为回文字符串，这时间复杂度肯定爆炸，是指数级。

那么无疑，这个问题需要使用动态规划技巧来解决。之前的文章说过，回文问题一般都是从字符串的中间向两端扩散，构造回文串也是类似的。

**我们定义一个二维的` dp ` 数组， ` dp[i][j] ` 的定义如下：对字符串 ` s[i..j] ` ，最少需要进行 ` dp[i][j] `次插入才能变成回文串 ** 。

我们想求整个 ` s ` 的最少插入次数，根据这个定义，也就是想求 ` dp[0][n-1] ` 的大小（ ` n ` 为 ` s ` 的长度）。

同时，base case 也很容易想到，当 ` i == j ` 时 ` dp[i][j] = 0 ` ，因为当 ` i == j ` 时 `s[i..j] ` 就是一个字符，本身就是回文串，所以不需要进行任何插入操作。

接下来就是动态规划的重头戏了，利用数学归纳法思考状态转移方程。

### 状态转移方程

状态转移就是从小规模问题的答案推导更大规模问题的答案，从 base case 向其他状态推导嘛。 **如果我们现在想计算` dp[i][j] `的值，而且假设我们已经计算出了子问题 ` dp[i+1][j-1] ` 的值了，你能不能想办法推出 ` dp[i][j] ` 的值呢 ** ？

![](https://labuladong.gitee.io/algo/images/%e6%8f%92%e5%85%a5%e5%9b%9e%e6%96%87/1.jpeg)

既然已经算出 ` dp[i+1][j-1] ` ，即知道了 ` s[i+1..j-1] ` 成为回文串的最小插入次数， **那么也就可以认为`
s[i+1..j-1] ` 已经是一个回文串了，所以通过 ` dp[i+1][j-1] ` 推导 ` dp[i][j] ` 的关键就在于 ` s[i] `和 ` s[j] ` 这两个字符 ** 。

![](https://labuladong.gitee.io/algo/images/%e6%8f%92%e5%85%a5%e5%9b%9e%e6%96%87/2.jpeg)

这个得分情况讨论， **如果` s[i] == s[j] ` 的话 ** ，我们不需要进行任何插入，只要知道如何把 ` s[i+1..j-1] `变成回文串即可：

![](https://labuladong.gitee.io/algo/images/%e6%8f%92%e5%85%a5%e5%9b%9e%e6%96%87/3.jpeg)

翻译成代码就是这样：

```java
    if (s[i] == s[j]) {
        dp[i][j] = dp[i + 1][j - 1];
    }

```

**如果` s[i] != s[j] ` 的话 ** ，就比较麻烦了，比如下面这种情况：

![](https://labuladong.gitee.io/algo/images/%e6%8f%92%e5%85%a5%e5%9b%9e%e6%96%87/4.jpeg)

最简单的想法就是，先把 ` s[j] ` 插到 ` s[i] ` 右边，同时把 ` s[i] ` 插到 ` s[j] `右边，这样构造出来的字符串一定是回文串：

![](https://labuladong.gitee.io/algo/images/%e6%8f%92%e5%85%a5%e5%9b%9e%e6%96%87/5.jpeg)

> PS：当然，把 ` s[j] ` 插到 ` s[i] ` 左边，然后把 ` s[i] ` 插到 ` s[j] ` 左边也是一样的，后面会分析。

但是，这是不是就意味着代码可以直接这样写呢？

```java
    if (s[i] != s[j]) {
        // 把 s[j] 插到 s[i] 右边，把 s[i] 插到 s[j] 右边
        dp[i][j] = dp[i + 1][j - 1] + 2;
    }

```

不对，比如说如下这两种情况，只需要插入一个字符即可使得 ` s[i..j] ` 变成回文：

![](https://labuladong.gitee.io/algo/images/%e6%8f%92%e5%85%a5%e5%9b%9e%e6%96%87/6.jpeg)

所以说，当 ` s[i] != s[j] ` 时，无脑插入两次肯定是可以让 ` s[i..j] `变成回文串，但是不一定是插入次数最少的，最优的插入方案应该被拆解成如下流程：

**步骤一，做选择，先将` s[i..j-1] ` 或者 ` s[i+1..j] ` 变成回文串 ** 。怎么做选择呢？谁变成回文串的插入次数少，就选谁呗。

比如图二的情况，将 ` s[i+1..j] ` 变成回文串的代价小，因为它本身就是回文串，根本不需要插入；同理，对于图三，将 ` s[i..j-1] `变成回文串的代价更小。

然而，如果 ` s[i+1..j] ` 和 ` s[i..j-1] ` 都不是回文串，都至少需要插入一个字符才能变成回文，所以选择哪一个都一样：

![](https://labuladong.gitee.io/algo/images/%e6%8f%92%e5%85%a5%e5%9b%9e%e6%96%87/7.jpeg)

那我怎么知道 ` s[i+1..j] ` 和 ` s[i..j-1] ` 谁变成回文串的代价更小呢？

回头看看 ` dp ` 数组的定义是什么， ` dp[i+1][j] ` 和 ` dp[i][j-1] ` 不就是它们变成回文串的代价么？

**步骤二，根据步骤一的选择，将` s[i..j] ` 变成回文 ** 。

如果你在步骤一中选择把 ` s[i+1..j] ` 变成回文串，那么在 ` s[i+1..j] ` 右边插入一个字符 ` s[i] ` 一定可以将 `s[i..j] ` 变成回文；同理，如果在步骤一中选择把 ` s[i..j-1] ` 变成回文串，在 ` s[i..j-1] ` 左边插入一个字符 `s[j] ` 一定可以将 ` s[i..j] ` 变成回文。

那么根据刚才对 ` dp ` 数组的定义以及以上的分析， ` s[i] != s[j] ` 时的代码逻辑如下：

```java
    if (s[i] != s[j]) {
        // 步骤一选择代价较小的
        // 步骤二必然要进行一次插入
        dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1;
    }

```

综合起来，状态转移方程如下：

```java
    if (s[i] == s[j]) {
        dp[i][j] = dp[i + 1][j - 1];
    } else {
        dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1;
    }

```

这就是动态规划算法核心，我们可以直接写出解法代码了。

### 代码实现

首先想想 base case 是什么，当 ` i == j ` 时 ` dp[i][j] = 0 ` ，因为这时候 ` s[i..j] `就是单个字符，本身就是回文串，不需要任何插入；最终的答案是 ` dp[0][n-1] ` （ ` n ` 是字符串 ` s ` 的长度）。那么 dp table 长这样：

![](https://labuladong.gitee.io/algo/images/%e6%8f%92%e5%85%a5%e5%9b%9e%e6%96%87/8.jpeg)

又因为状态转移方程中 ` dp[i][j] ` 和 ` dp[i+1][j] ` ， ` dp[i]-1] ` ， ` dp[i+1][j-1] `三个状态有关，为了保证每次计算 ` dp[i][j] ` 时，这三个状态都已经被计算，我们一般选择从下向上，从左到右遍历 ` dp ` 数组：

![](https://labuladong.gitee.io/algo/images/%e6%8f%92%e5%85%a5%e5%9b%9e%e6%96%87/9.jpeg)

完整代码如下：

```java
    int minInsertions(string s) {
        int n = s.size();
        // 定义：对 s[i..j]，最少需要插入 dp[i][j] 次才能变成回文
        vector<vector<int>> dp(n, vector<int>(n, 0));
        // base case：i == j 时 dp[i][j] = 0，单个字符本身就是回文
        // dp 数组已经全部初始化为 0，base case 已初始化
    
        // 从下向上遍历
        for (int i = n - 2; i >= 0; i--) {
            // 从左向右遍历
            for (int j = i + 1; j < n; j++) {
                // 根据 s[i] 和 s[j] 进行状态转移
                if (s[i] == s[j]) {
                    dp[i][j] = dp[i + 1][j - 1];
                } else {
                    dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1;
                }
            }
        }
        // 根据 dp 数组的定义，题目要求的答案
        return dp[0][n - 1];
    }

```

现在这道题就解决了，时间和空间复杂度都是 O(N^2)。还有一个小优化，注意到 ` dp ` 数组的状态之和它相邻的状态有关，所以 ` dp `数组是可以压缩成一维的：

```java
    int minInsertions(string s) {
        int n = s.size();
        vector<int> dp(n, 0);
        
        int temp = 0;
        for (int i = n - 2; i >= 0; i--) {
            // 记录 dp[i+1][j-1]
            int pre = 0;
            for (int j = i + 1; j < n; j++) {
                temp = dp[j];
                
                if (s[i] == s[j]) {
                    // dp[i][j] = dp[i+1][j-1];
                    dp[j] = pre;
                } else {
                    // dp[i][j] = min(dp[i+1][j], dp[i][j-1]) + 1;
                    dp[j] = =min(dp[j], dp[j - 1]) + 1;
                }
                
                pre = temp;
            }
        }
        
        return dp[n - 1];
    }

```

至于这个状态压缩是怎么做的，我们前文 [ 状态压缩技巧 ](https://labuladong.gitee.io/algo/3/22/70/) 详细介绍过，这里就不展开了。



# 贪心类型问题



## 贪心算法之区间调度问题



读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 435. 无重叠区间（中等） ](https://leetcode-cn.com/problems/non-overlapping-
intervals/)

[ 452. 用最少数量的箭引爆气球（中等） ](https://leetcode-cn.com/problems/minimum-number-of-
arrows-to-burst-balloons)

**———–**

什么是贪心算法呢？贪心算法可以认为是动态规划算法的一个特例，相比动态规划，使用贪心算法需要满足更多的条件（贪心选择性质），但是效率比动态规划要高。

比如说一个算法问题使用暴力解法需要指数级时间，如果能使用动态规划消除重叠子问题，就可以降到多项式级别的时间，如果满足贪心选择性质，那么可以进一步降低时间复杂度，达到线性级别的。

什么是贪心选择性质呢，简单说就是：每一步都做出一个局部最优的选择，最终的结果就是全局最优。注意哦，这是一种特殊性质，其实只有一部分问题拥有这个性质。

比如你面前放着 100 张人民币，你只能拿十张，怎么才能拿最多的面额？显然每次选择剩下钞票中面值最大的一张，最后你的选择一定是最优的。

然而，大部分问题明显不具有贪心选择性质。比如打斗地主，对手出对儿三，按照贪心策略，你应该出尽可能小的牌刚好压制住对方，但现实情况我们甚至可能会出王炸。这种情况就不能用贪心算法，而得使用动态规划解决，参见前文
[ 动态规划解决博弈问题 ](https://labuladong.gitee.io/algo/3/25/92/) 。

### 一、问题概述

言归正传，本文解决一个很经典的贪心算法问题 Interval Scheduling（区间调度问题）。给你很多形如 ` [start, end] `的闭区间，请你设计一个算法， **算出这些区间中最多有几个互不相交的区间** 。

```java
    int intervalSchedule(int[][] intvs);

```

举个例子， ` intvs = [[1,3], [2,4], [3,6]] ` ，这些区间最多有 2 个区间互不相交，即 ` [[1,3], [3,6]]
` ，你的算法应该返回 2。注意边界相同并不算相交。

这个问题在生活中的应用广泛，比如你今天有好几个活动，每个活动都可以用区间 ` [start, end] ` 表示开始和结束的时间，请问你今天
**最多能参加几个活动呢** ？显然你一个人不能同时参加两个活动，所以说这个问题就是求这些时间区间的最大不相交子集。

### 二、贪心解法

这个问题有许多看起来不错的贪心思路，却都不能得到正确答案。比如说：

也许我们可以每次选择可选区间中开始最早的那个？但是可能存在某些区间开始很早，但是很长，使得我们错误地错过了一些短的区间。或者我们每次选择可选区间中最短的那个？或者选择出现冲突最少的那个区间？这些方案都能很容易举出反例，不是正确的方案。

正确的思路其实很简单，可以分为以下三步：

1、从区间集合 ` intvs ` 中选择一个区间 ` x ` ，这个 ` x ` 是在当前所有区间中 **结束最早的** （ ` end ` 最小）。

2、把所有与 ` x ` 区间相交的区间从区间集合 ` intvs ` 中删除。

3、重复步骤 1 和 2，直到 ` intvs ` 为空为止。之前选出的那些 ` x ` 就是最大不相交子集。

把这个思路实现成算法的话，可以按每个区间的 ` end ` 数值升序排序，因为这样处理之后实现步骤 1 和步骤 2 都方便很多:

![](https://labuladong.gitee.io/algo/images/interval/1.gif)

现在来实现算法，对于步骤 1，由于我们预先按照 ` end ` 排了序，所以选择 ` x ` 是很容易的。关键在于，如何去除与 ` x `相交的区间，选择下一轮循环的 ` x ` 呢？

**由于我们事先排了序** ，不难发现所有与 ` x ` 相交的区间必然会与 ` x ` 的 ` end ` 相交；如果一个区间不想与 ` x ` 的 `end ` 相交，它的 ` start ` 必须要大于（或等于） ` x ` 的 ` end ` ：

![](https://labuladong.gitee.io/algo/images/interval/2.jpg)

看下代码：

```java
    public int intervalSchedule(int[][] intvs) {
        if (intvs.length == 0) return 0;
        // 按 end 升序排序
        Arrays.sort(intvs, new Comparator<int[]>() {
            public int compare(int[] a, int[] b) {
                return a[1] - b[1];
            }
        });
        // 至少有一个区间不相交
        int count = 1;
        // 排序后，第一个区间就是 x
        int x_end = intvs[0][1];
        for (int[] interval : intvs) {
            int start = interval[0];
            if (start >= x_end) {
                // 找到下一个选择的区间了
                count++;
                x_end = interval[1];
            }
        }
        return count;
    }

```

### 三、应用举例

下面举例几道 LeetCode 题目应用一下区间调度算法。

第 435 题，无重叠区间：

![](https://labuladong.gitee.io/algo/images/interval/title1.png)

我们已经会求最多有几个区间不会重叠了，那么剩下的不就是至少需要去除的区间吗？

```java
    int eraseOverlapIntervals(int[][] intervals) {
        int n = intervals.length;
        return n - intervalSchedule(intervals);
    }

```

第 452 题，用最少的箭头射爆气球：

![](https://labuladong.gitee.io/algo/images/interval/title2.png)

其实稍微思考一下，这个问题和区间调度算法一模一样！如果最多有 ` n ` 个不重叠的区间，那么就至少需要 ` n ` 个箭头穿透所有区间：

![](https://labuladong.gitee.io/algo/images/interval/3.jpg)

只是有一点不一样，在 ` intervalSchedule `算法中，如果两个区间的边界触碰，不算重叠；而按照这道题目的描述，箭头如果碰到气球的边界气球也会爆炸，所以说相当于区间的边界触碰也算重叠：

![](https://labuladong.gitee.io/algo/images/interval/4.jpg)

所以只要将之前的算法稍作修改，就是这道题目的答案：

```java
    int findMinArrowShots(int[][] intvs) {
        // ...
    
        for (int[] interval : intvs) {
            int start = interval[0];
            // 把 >= 改成 > 就行了
            if (start > x_end) {
                count++;
                x_end = interval[1];
            }
        }
        return count;
    }

```

接下来可阅读：

* [ 贪心算法之跳跃游戏 ](https://labuladong.gitee.io/algo/3/26/102/)



## 扫描线技巧：安排会议室



读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 253.会议室 II（中等） ](https://leetcode.com/problems/meeting-rooms-ii/)

**———–**

之前面试，被问到一道非常经典且非常实用的算法题目：会议室安排问题。

力扣上类似的问题是会员题目，你可能没办法做，但对于这种经典的算法题，掌握思路还是必要的。

先说下题目，给你输入若干形如 ` [begin, end] ` 的区间，代表若干会议的开始时间和结束时间，请你计算至少需要申请多少间会议室。

函数签名如下：

```java
    // 返回需要申请的会议室数量
    int minMeetingRooms(int[][] meetings);

```

比如给你输入 ` meetings = [[0,30],[5,10],[15,20]] ` ，算法应该返回 2，因为后两个会议和第一个会议时间是冲突的，至少申请两个会议室才能让所有会议顺利进行。

如果会议之间的时间有重叠，那就得额外申请会议室来开会，想求至少需要多少间会议室，就是让你计算同一时刻最多有多少会议在同时进行。

换句话说， **如果把每个会议的起始时间看做一个线段区间，那么题目就是让你求最多有几个重叠区间** ，仅此而已。

对于这种时间安排的问题，本质上讲就是区间调度问题，十有八九得排序，然后找规律来解决。

### 题目延伸

我们之前写过很多区间调度相关的文章，这里就顺便帮大家梳理一下这类问题的思路：

**第一个场景** ，假设现在只有一个会议室，还有若干会议，你如何将尽可能多的会议安排到这个会议室里？

这个问题需要将这些会议（区间）按结束时间（右端点）排序，然后进行处理，详见前文 [ 贪心算法做时间管理 ](https://labuladong.gitee.io/algo/3/26/99/) 。

**第二个场景** ，给你若干较短的视频片段，和一个较长的视频片段，请你从较短的片段中尽可能少地挑出一些片段，拼接出较长的这个片段。

这个问题需要将这些视频片段（区间）按开始时间（左端点）排序，然后进行处理，详见前文 [ 剪视频剪出一个贪心算法 ](https://labuladong.gitee.io/algo/3/26/101/)
。

**第三个场景** ，给你若干区间，其中可能有些区间比较短，被其他区间完全覆盖住了，请你删除这些被覆盖的区间。

这个问题需要将这些区间按左端点排序，然后就能找到并删除那些被完全覆盖的区间了，详见前文 [ 删除覆盖区间 ](https://labuladong.gitee.io/algo/4/30/126/) 。

**第四个场景** ，给你若干区间，请你将所有有重叠部分的区间进行合并。

这个问题需要将这些区间按左端点排序，方便找出存在重叠的区间，详见前文 [ 合并重叠区间 ](https://labuladong.gitee.io/algo/4/30/126/) 。

**第五个场景** ，有两个部门同时预约了同一个会议室的若干时间段，请你计算会议室的冲突时段。

这个问题就是给你两组区间列表，请你找出这两组区间的交集，这需要你将这些区间按左端点排序，详见前文 [ 区间交集问题

](https://labuladong.gitee.io/algo/4/30/126/) 。

**第六个场景** ，假设现在只有一个会议室，还有若干会议，如何安排会议才能使这个会议室的闲置时间最少？

这个问题需要动动脑筋，说白了这就是个 0-1 背包问题的变形：

会议室可以看做一个背包，每个会议可以看做一个物品，物品的价值就是会议的时长，请问你如何选择物品（会议）才能最大化背包中的价值（会议室的使用时长）？

当然，这里背包的约束不是一个最大重量，而是各个物品（会议）不能互相冲突。把各个会议按照结束时间进行排序，然后参考前文 [ 0-1 背包问题详解

](https://labuladong.gitee.io/algo/3/24/80/) 的思路即可解决，等我以后有机会可以写一写这个问题。

**第七个场景** ，就是本文想讲的场景，给你若干会议，让你合理申请会议室。

好了，举例了这么多，来看看今天的这个问题如何解决。

### 题目分析

重复一下题目的本质：

**给你输入若干时间区间，让你计算同一时刻「最多」有几个区间重叠** 。

题目的关键点在于，给你任意一个时刻，你是否能够说出这个时刻有几个会议？

如果可以做到，那我遍历所有的时刻，找个最大值，就是需要申请的会议室数量。

有没有一种数据结构或者算法，给我输入若干区间，我能知道每个位置有多少个区间重叠？

老读者肯定可以联想到之前说过的一个算法技巧： [ 差分数组技巧 ](https://labuladong.gitee.io/algo/2/20/54/) 。

把时间线想象成一个初始值为 0 的数组，每个时间区间 ` [i, j] ` 就相当于一个子数组，这个时间区间有一个会议，那我就把这个子数组中的元素都加一。

最后，每个时刻有几个会议我不就知道了吗？我遍历整个数组，不就知道至少需要几间会议室了吗？

举例来说，如果输入 ` meetings = [[0,30],[5,10],[15,20]] ` ，那么我们就给数组中 `[0,30],[5,10],[15,20] ` 这几个索引区间分别加一，最后遍历数组，求个最大值就行了。

还记得吗，差分数组技巧可以在 O(1) 时间对整个区间的元素进行加减，所以可以拿来解决这道题。

不过，这个解法的效率不算高，所以我这里不准备具体写差分数组的解法，参照 [ 差分数组技巧 ](https://labuladong.gitee.io/algo/2/20/54/)
的原理，有兴趣的读者可以自己尝试去实现。

**基于差分数组的思路，我们可以推导出一种更高效，更优雅的解法** 。

我们首先把这些会议的时间区间进行投影：

![](https://labuladong.gitee.io/algo/images/%e5%ae%89%e6%8e%92%e4%bc%9a%e8%ae%ae%e5%ae%a4/1.jpeg)

红色的点代表每个会议的开始时间点，绿色的点代表每个会议的结束时间点。

现在假想有一条带着计数器的线，在时间线上从左至右进行扫描，每遇到红色的点，计数器 ` count ` 加一，每遇到绿色的点，计数器 ` count `减一：

![](https://labuladong.gitee.io/algo/images/%e5%ae%89%e6%8e%92%e4%bc%9a%e8%ae%ae%e5%ae%a4/2.jpeg)

**这样一来，每个时刻有多少个会议在同时进行，就是计数器` count ` 的值， ` count ` 的最大值，就是需要申请的会议室数量 ** 。

对差分数组技巧熟悉的读者一眼就能看出来了，这个扫描线其实就是差分数组的遍历过程，所以我们说这是差分数组技巧衍生出来的解法。

### 代码实现

那么，如何写代码实现这个扫描的过程呢？

首先，对区间进行投影，就相当于对每个区间的起点和终点分别进行排序：

![](https://labuladong.gitee.io/algo/images/%e5%ae%89%e6%8e%92%e4%bc%9a%e8%ae%ae%e5%ae%a4/3.jpeg)

```java
    int minMeetingRooms(int[][] meetings) {
        int n = meetings.length;
        int[] begin = new int[n];
        int[] end = new int[n];
        // 把左端点和右端点单独拿出来
        for(int i = 0; i < n; i++) {
            begin[i] = meetings[i][0];
            end[i] = meetings[i][1];
        }
        // 排序后就是图中的红点
        Arrays.sort(begin);
        // 排序后就是图中的绿点
        Arrays.sort(end);
    
        // ...
    }

```

然后就简单了，扫描线从左向右前进，遇到红点就对计数器加一，遇到绿点就对计数器减一，计数器 ` count ` 的最大值就是答案：

```java
    int minMeetingRooms(int[][] meetings) {
        int n = meetings.length;
        int[] begin = new int[n];
        int[] end = new int[n];
        for(int i = 0; i < n; i++) {
            begin[i] = meetings[i][0];
            end[i] = meetings[i][1];
        }
        Arrays.sort(begin);
        Arrays.sort(end);
    
        // 扫描过程中的计数器
        int count = 0;
        // 双指针技巧
        int res = 0, i = 0, j = 0;
        while (i < n && j < n) {
            if (begin[i] < end[j]) {
                // 扫描到一个红点
                count++;
                i++;
            } else {
                // 扫描到一个绿点
                count--;
                j++;
            }
            // 记录扫描过程中的最大值
            res = Math.max(res, count);
        }
        
        return res;
    }

```

这里使用的是 [ 双指针技巧 ](https://labuladong.gitee.io/algo/2/20/55/) ，根据 ` i, j ` 的相对位置模拟扫描线前进的过程。

至此，这道题就做完了。当然，这个题目也可以变形，比如给你若干会议，问你 ` k ` 个会议室够不够用，其实你套用本文的解法代码，也可以很轻松解决。

接下来可阅读：

[ 区间问题系列合集 ](https://labuladong.gitee.io/algo/4/30/126/)



## 剪视频剪出一个贪心算法



读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 1024. 视频拼接（中等） ](https://leetcode-cn.com/problems/video-stitching)

**———–**

前面发过几个视频，也算是对视频剪辑入了个门。像我这种非专业剪辑玩家，不做什么宏大特效电影镜头，只是做个视频教程，其实也没啥难度，只需要把视频剪流畅，所以用到最多的功能就是切割功能，然后删除和拼接视频片接。

没有剪过视频的读者可能不知道，在常用的剪辑软件中视频被切割成若干片段之后，每个片段都可以还原成原始视频。

就比如一个 10 秒的视频，在中间切一刀剪成两个 5 秒的视频，这两个五秒的视频各自都可以还原成 10 秒的原视频。就好像蚯蚓，把自己切成 4 段就能搓麻，把自己切成 11 段就可以凑一个足球队。

![](https://labuladong.gitee.io/algo/images/%e5%89%aa%e8%a7%86%e9%a2%91/1.jpg)

剪视频时，每个视频片段都可以抽象成了一个个区间，时间就是区间的端点，这些区间有的相交，有的不相交……

假设剪辑软件不支持将视频片段还原成原视频，那么如果给我若干视频片段，我怎么将它们还原成原视频呢？

这是个很有意思的区间算法问题，也是力扣第 1024 题「视频拼接」，题目如下：

![](https://labuladong.gitee.io/algo/images/%e5%89%aa%e8%a7%86%e9%a2%91/title.jpg)

函数签名如下：

```java
    int videoStitching(int[][] clips, int T);

```

记得以前写过好几篇区间相关的问题：

[ 区间问题合集 ](https://labuladong.gitee.io/algo/4/30/126/) 写过求区间交集、区间并集、区间覆盖这几个问题。

[ 贪心算法做时间管理 ](https://labuladong.gitee.io/algo/3/26/99/) 写过利用贪心算法求不相交的区间。

算上本文的区间剪辑问题，经典的区间问题也就都讲完了。

### 思路分析

题目并不难理解，给定一个目标区间和若干小区间，如何通过裁剪和组合小区间拼凑出目标区间？最少需要几个小区间？

**前文多次说过，区间问题肯定按照区间的起点或者终点进行排序** 。

因为排序之后更容易找到相邻区间之间的联系，如果是求最值的问题，可以使用贪心算法进行求解。

区间问题特别容易用贪心算法，公众号历史文章除了 [ 贪心算法之区间调度 ](https://labuladong.gitee.io/algo/3/26/99/) ，还有一篇 [ 贪心算法玩跳跃游戏

](https://labuladong.gitee.io/algo/3/26/102/) ，其实这个跳跃游戏就相当于一个将起点排序的区间问题，你细品，你细品。

至于到底如何排序，这个就要因题而异了，我做这道题的思路是先按照起点升序排序，如果起点相同的话按照终点降序排序。

为什么这样排序呢，主要考虑到这道题的以下两个特点：

1、要用若干短视频凑出完成视频 ` [0, T] ` ，至少得有一个短视频的起点是 0。

这个很好理解，如果没有一个短视频是从 0 开始的，那么区间 ` [0, T] ` 肯定是凑不出来的。

2、如果有几个短视频的起点都相同，那么一定应该选择那个最长（终点最大）的视频。

这一条就是贪心的策略，因为题目让我们计算最少需要的短视频个数，如果起点相同，那肯定是越长越好，不要白不要，多出来了大不了剪辑掉嘛。

基于以上两个特点，将 ` clips ` 按照起点升序排序，起点相同的按照终点降序排序，最后得到的区间顺序就像这样：

![](https://labuladong.gitee.io/algo/images/%e5%89%aa%e8%a7%86%e9%a2%91/2.jpeg)

这样我们就可以确定，如果 ` clips[0] ` 是的起点是 0，那么 ` clips[0] ` 这个视频一定会被选择。

![](https://labuladong.gitee.io/algo/images/%e5%89%aa%e8%a7%86%e9%a2%91/3.jpeg)

当我们确定 ` clips[0] ` 一定会被选择之后，就可以选出下一个会被选择的视频：

![](https://labuladong.gitee.io/algo/images/%e5%89%aa%e8%a7%86%e9%a2%91/4.jpeg)

**我们会比较所有起点小于` clips[0][1] ` 的区间，根据贪心策略，它们中终点最大的那个区间就是第二个会被选中的视频 ** 。

然后可以通过第二个视频区间贪心选择出第三个视频，以此类推，直到覆盖区间 ` [0, T] ` ，或者无法覆盖返回 -1。

以上就是这道题的解题思路，仔细想想，这题的核心和前文 [ 贪心算法玩跳跃游戏 ](https://labuladong.gitee.io/algo/3/26/102/)
写的跳跃游戏是相同的，如果你能看出这两者的联系，就可以说理解贪心算法的奥义了。

### 代码实现

实现上述思路需要我们用两个变量 ` curEnd ` 和 ` nextEnd ` 来进行：

![](https://labuladong.gitee.io/algo/images/%e5%89%aa%e8%a7%86%e9%a2%91/5.gif)

最终代码实现如下：

```java
    int videoStitching(int[][] clips, int T) {
        if (T == 0) return 0;
        // 按起点升序排列，起点相同的降序排列
        Arrays.sort(clips, (a, b) -> {
            if (a[0] == b[0]) {
                return b[1] - a[1];
            }
            return a[0] - b[0];
        });
        // 记录选择的短视频个数
        int res = 0;
    
        int curEnd = 0, nextEnd = 0;
        int i = 0, n = clips.length;
        while (i < n && clips[i][0] <= curEnd) {
            // 在第 res 个视频的区间内贪心选择下一个视频
            while (i < n && clips[i][0] <= curEnd) {
                nextEnd = Math.max(nextEnd, clips[i][1]);
                i++;
            }
            // 找到下一个视频，更新 curEnd
            res++;
            curEnd = nextEnd;
            if (curEnd >= T) {
                // 已经可以拼出区间 [0, T]
                return res;
            }
        }
        // 无法连续拼出区间 [0, T]
        return -1;
    }

```

这段代码的时间复杂度是多少呢？虽然代码中有一个嵌套的 while 循环，但这个嵌套 while 循环的时间复杂度是 ` O(N) ` 。因为当 ` i `递增到 ` n ` 时循环就会结束，所以这段代码只会执行 ` O(N) ` 次。

但是别忘了我们对 ` clips ` 数组进行了一次排序，消耗了 ` O(NlogN) ` 的时间，所以本算法的总时间复杂度是 ` O(NlogN) ` 。

最后说一句，我去 B 站做 up 了，B 站搜索同名账号「labuladong」即可关注！



## 如何运用贪心思想玩跳跃游戏



读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 55. 跳跃游戏（中等） ](https://leetcode-cn.com/problems/jump-game)

[ 45. 跳跃游戏 II（中等） ](https://leetcode-cn.com/problems/jump-game-ii)

**———–**

经常有读者在后台问，动态规划和贪心算法到底有啥关系。我们之前的文章 [ 贪心算法之区间调度问题 ](https://labuladong.gitee.io/algo/3/26/99/)
就说过一个常见的时间区间调度的贪心算法问题。

说白了，贪心算法可以理解为一种特殊的动态规划问题，拥有一些更特殊的性质，可以进一步降低动态规划算法的时间复杂度。那么这篇文章，就讲 LeetCode 上两道经典的贪心算法：跳跃游戏 I 和跳跃游戏 II。

我们可以对这两道题分别使用动态规划算法和贪心算法进行求解，通过实践，你就能更深刻地理解贪心和动规的区别和联系了。

### Jump Game I

跳跃游戏 I 是 LeetCode 第 55 题，难度是 Medium，但实际上是比较简单的，看题目：

![](https://labuladong.gitee.io/algo/images/jumpGame/title1.png)

**不知道读者有没有发现，有关动态规划的问题，大多是让你求最值的**
，比如最长子序列，最小编辑距离，最长公共子串等等等。这就是规律，因为动态规划本身就是运筹学里的一种求最值的算法。

那么贪心算法作为特殊的动态规划也是一样，也一定是让你求个最值。这道题表面上不是求最值，但是可以改一改：

**请问通过题目中的跳跃规则，最多能跳多远** ？如果能够越过最后一格，返回 true，否则返回 false。

所以说，这道题肯定可以用动态规划求解的。但是由于它比较简单，下一道题再用动态规划和贪心思路进行对比，现在直接上贪心的思路：

```java
    boolean canJump(int[] nums) {
        int n = nums.length;
        int farthest = 0;
        for (int i = 0; i < n - 1; i++) {
            // 不断计算能跳到的最远距离
            farthest = Math.max(farthest, i + nums[i]);
            // 可能碰到了 0，卡住跳不动了
            if (farthest <= i) {
                return false;
            }
        }
        return farthest >= n - 1;
    }

```

你别说，如果之前没有做过类似的题目，还真不一定能够想出来这个解法。每一步都计算一下从当前位置最远能够跳到哪里，然后和一个全局最优的最远位置 `farthest ` 做对比，通过每一步的最优解，更新全局最优解，这就是贪心。

很简单是吧？记住这一题的思路，看第二题，你就发现事情没有这么简单。。。

### Jump Game II

这是 LeetCode 第 45 题，也是让你在数组上跳，不过难度是 Hard，解法可没上一题那么简单直接：

![](https://labuladong.gitee.io/algo/images/jumpGame/title2.png)

**现在的问题是，保证你一定可以跳到最后一格，请问你最少要跳多少次，才能跳过去** 。

我们先来说说动态规划的思路，采用自顶向下的递归动态规划，可以这样定义一个 ` dp ` 函数：

```java
    // 定义：从索引 p 跳到最后一格，至少需要 dp(nums, p) 步
    int dp(vector<int>& nums, int p);

```

我们想求的结果就是 ` dp(nums, 0) ` ，base case 就是当 ` p ` 超过最后一格时，不需要跳跃：

```java
    if (p >= nums.size() - 1) {
        return 0;
    }

```

根据前文 [ 动态规划套路详解 ](https://labuladong.gitee.io/algo/3/22/66/) 的动规框架，就可以暴力穷举所有可能的跳法，通过备忘录 ` memo `消除重叠子问题，取其中的最小值最为最终答案：

```java
    int[] memo;
    // 主函数
    public int jump(int[] nums) {
        int n = nums.length;
        // 备忘录都初始化为 n，相当于 INT_MAX
        // 因为从 0 跳到 n - 1 最多 n - 1 步
        memo = new int[n];
        Arrays.fill(memo, n);
    
        return dp(nums, 0);
    }
    
    int dp(int[] nums, int p) {
        int n = nums.length;
        // base case
        if (p >= n - 1) {
            return 0;
        }
        // 子问题已经计算过
        if (memo[p] != n) {
            return memo[p];
        }
        int steps = nums[p];
        // 你可以选择跳 1 步，2 步...
        for (int i = 1; i <= steps; i++) {
            // 穷举每一个选择
            // 计算每一个子问题的结果
            int subProblem = dp(nums, p + i);
            // 取其中最小的作为最终结果
            memo[p] = Math.min(memo[p], subProblem + 1);
        }
        return memo[p];
    }

```

这个动态规划应该很明显了，按照前文 [ 动态规划套路详解 ](https://labuladong.gitee.io/algo/3/22/66/) 所说的套路，状态就是当前所站立的索引 ` p `，选择就是可以跳出的步数。

该算法的时间复杂度是 递归深度 × 每次递归需要的时间复杂度，即 O(N^2)，在 LeetCode 上是无法通过所有用例的，会超时。

**贪心算法比动态规划多了一个性质：贪心选择性质** 。我知道大家都不喜欢看严谨但枯燥的数学形式定义，那么我们就来直观地看一看什么样的问题满足贪心选择性质。

刚才的动态规划思路，不是要穷举所有子问题，然后取其中最小的作为结果吗？核心的代码框架是这样：

```java
        int steps = nums[p];
        // 你可以选择跳 1 步，2 步...
        for (int i = 1; i <= steps; i++) {
            // 计算每一个子问题的结果
            int subProblem = dp(nums, p + i);
            res = min(subProblem + 1, res);
        }

```

for 循环中会陷入递归计算子问题，这是动态规划时间复杂度高的根本原因。

但是，真的需要「递归地」计算出每一个子问题的结果，然后求最值吗？ **直观地想一想，似乎不需要递归，只需要判断哪一个选择最具有「潜力」即可** ：

![](https://labuladong.gitee.io/algo/images/jumpGame/1.jpg)

比如上图这种情况，我们站在索引 0 的位置，可以向前跳 1，2 或 3 步，你说应该选择跳多少呢？

**显然应该跳 2 步调到索引 2，因为` nums[2] ` 的可跳跃区域涵盖了索引区间 ` [3..6] ` ，比其他的都大 **
。如果想求最少的跳跃次数，那么往索引 2 跳必然是最优的选择。

你看， **这就是贪心选择性质，我们不需要「递归地」计算出所有选择的具体结果然后比较求最值，而只需要做出那个最有「潜力」，看起来最优的选择即可** 。

绕过这个弯儿来，就可以写代码了：

```java
    int jump(int[] nums) {
        int n = nums.length;
        int end = 0, farthest = 0;
        int jumps = 0;
        for (int i = 0; i < n - 1; i++) {
            farthest = Math.max(nums[i] + i, farthest);
            if (end == i) {
                jumps++;
                end = farthest;
            }
        }
        return jumps;
    }

```

结合刚才那个图，就知道这段短小精悍的代码在干什么了：

![](https://labuladong.gitee.io/algo/images/jumpGame/2.jpg)

` i ` 和 ` end ` 标记了可以选择的跳跃步数， ` farthest ` 标记了所有选择 ` [i..end] ` 中能够跳到的最远距离， `jumps ` 记录了跳跃次数。

本算法的时间复杂度 O(N)，空间复杂度 O(1)，可以说是非常高效，动态规划都被吊起来打了。

至此，两道跳跃问题都使用贪心算法解决了。

其实对于贪心选择性质，是可以有严格的数学证明的，有兴趣的读者可以参看《算法导论》第十六章，专门有一个章节介绍贪心算法。这里限于篇幅和通俗性，就不展开了。

使用贪心算法的实际应用还挺多，比如赫夫曼编码也是一个经典的贪心算法应用。更多时候运用贪心算法可能不是求最优解，而是求次优解以节约时间，比如经典的旅行商问题。

不过我们常见的贪心算法题目，就像本文的题目，大多一眼就能看出来，大不了就先用动态规划求解，如果动态规划都超时，说明该问题存在贪心选择性质无疑了。

接下来可阅读：

* [ 贪心问题之区间调度 ](https://labuladong.gitee.io/algo/3/26/99/)



## 当老司机学会了贪心算法



读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 134. 加油站（中等） ](https://leetcode-cn.com/problems/gas-station/)

**———–**

今天讲一个贪心的老司机的故事，就是力扣第 134 题「加油站」：

![](https://labuladong.gitee.io/algo/images/%e8%80%81%e5%8f%b8%e6%9c%ba/title.jpg)

题目应该不难理解，就是每到达一个站点 ` i ` ，可以加 ` gas[i] ` 升油，但离开站点 ` i ` 需要消耗 ` cost[i] `升油，问你从哪个站点出发，可以兜一圈回来。

要说暴力解法，肯定很容易想到，用一个 for 循环遍历所有站点，假设为起点，然后再套一层 for 循环，判断一下是否能够转一圈回到起点：

```java
    int n = gas.length;
    for (int start = 0; start < n; start++) {
        for (int step = 0; step < n; step++) {
            int i = (start + step) % n;
            tank += gas[i];
            tank -= cost[i];
            // 判断油箱中的油是否耗尽
        }
    }

```

很明显时间复杂度是 ` O(N^2) ` ，这么简单粗暴的解法一定不是最优的，我们试图分析一下是否有优化的余地。

暴力解法是否有重复计算的部分？是否可以抽象出「状态」，是否对同一个「状态」重复计算了多次？

我们前文 [ 动态规划详解 ](https://labuladong.gitee.io/algo/3/22/66/)
说过，变化的量就是「状态」。那么观察这个暴力穷举的过程，变化的量有两个，分别是「起点」和「当前油箱的油量」，但这两个状态的组合肯定有不下 ` O(N^2)
` 种，显然没有任何优化的空间。

**所以说这道题肯定不是通过简单的剪枝来优化暴力解法的效率，而是需要我们发现一些隐藏较深的规律，从而减少一些冗余的计算** 。

下面我们介绍两种方法巧解这道题，分别是数学图像解法和贪心解法。

### 图像解法

汽车进入站点 ` i ` 可以加 ` gas[i] ` 的油，离开站点会损耗 ` cost[i] ` 的油，那么可以把站点和与其相连的路看做一个整体，将 `gas[i] - cost[i] ` 作为经过站点 ` i ` 的油量变化值：

![](https://labuladong.gitee.io/algo/images/%e8%80%81%e5%8f%b8%e6%9c%ba/1.jpeg)

这样，题目描述的场景就被抽象成了一个环形数组，数组中的第 ` i ` 个元素就是 ` gas[i] - cost[i] ` 。

**有了这个环形数组，我们需要判断这个环形数组中是否能够找到一个起点` start ` ，使得从这个起点开始的累加和一直大于等于 0 ** 。

如何判断是否存在这样一个起点 ` start ` ？又如何计算这个起点 ` start ` 的值呢？

我们不妨就把 0 作为起点，计算累加和的代码非常简单：

```java
    int n = gas.length, sum = 0;
    for (int i = 0; i < n; i++) {
        // 计算累加和
        sum += gas[i] - cost[i];
    }

```

` sum ` 就相当于是油箱中油量的变化，上述代码中 ` sum ` 的变化过程可能是这样的：

![](https://labuladong.gitee.io/algo/images/%e8%80%81%e5%8f%b8%e6%9c%ba/2.jpeg)

显然，上图将 0 作为起点肯定是不行的，因为 ` sum ` 在变化的过程中小于 0 了，不符合我们「累加和一直大于等于 0」的要求。

那如果 0 不能作为起点，谁可以作为起点呢？

看图说话，图像的最低点最有可能可以作为起点：

![](https://labuladong.gitee.io/algo/images/%e8%80%81%e5%8f%b8%e6%9c%ba/3.jpeg)

**如果把这个「最低点」作为起点，就是说将这个点作为坐标轴原点，就相当于把图像「最大限度」向上平移了** 。

再加上这个数组是环形数组，最低点左侧的图像可以接到图像的最右侧：

![](https://labuladong.gitee.io/algo/images/%e8%80%81%e5%8f%b8%e6%9c%ba/4.jpeg)

这样，整个图像都保持在 x 轴以上，所以这个最低点 4，就是题目要求我们找的起点。

不过，经过平移后图像一定全部在 x 轴以上吗？不一定，因为还有无解的情况：

**如果` sum(gas[...]) < sum(cost[...]) ` ，总油量小于总的消耗，那肯定是没办法环游所有站点的 ** 。

综上，我们就可以写出代码：

```java
    int canCompleteCircuit(int[] gas, int[] cost) {
        int n = gas.length;
        // 相当于图像中的坐标点和最低点
        int sum = 0, minSum = 0;
        int start = 0;
        for (int i = 0; i < n; i++) {
            sum += gas[i] - cost[i];
            if (sum < minSum) {
                // 经过第 i 个站点后，使 sum 到达新低
                // 所以站点 i + 1 就是最低点（起点）
                start = i + 1;
                minSum = sum;
            }
        }
        if (sum < 0) {
            // 总油量小于总的消耗，无解
            return -1;
        }
        // 环形数组特性
        return start == n ? 0 : start;
    }

```

以上是观察函数图像得出的解法，时间复杂度为 O(N)，比暴力解法的效率高很多。

下面我们介绍一种使用贪心思路写出的解法，和上面这个解法比较相似，不过分析过程不尽相同。

### 贪心解法

用贪心思路解决这道题的关键在于以下这个结论：

**如果选择站点` i ` 作为起点「恰好」无法走到站点 ` j ` ，那么 ` i ` 和 ` j ` 中间的任意站点 ` k ` 都不可能作为起点 **
。

比如说，如果从站点 ` 1 ` 出发，走到站点 ` 5 ` 时油箱中的油量「恰好」减到了负数，那么说明站点 ` 1 ` 「恰好」无法到达站点 ` 5 `；那么你从站点 ` 2,3,4 ` 任意一个站点出发都无法到达 ` 5 ` ，因为到达站点 ` 5 ` 时油箱的油量也必然被减到负数。

如何证明这个结论？

假设 ` tank ` 记录当前油箱中的油量，如果从站点 ` i ` 出发（ ` tank = 0 ` ），走到 ` j ` 时恰好出现 ` tank <
0 ` 的情况，那说明走到 ` i, j ` 之间的任意站点 ` k ` 时都满足 ` tank > 0 ` ，对吧。

如果把 ` k ` 作为起点的话，相当于在站点 ` k ` 时 ` tank = 0 ` ，那走到 ` j ` 时必然有 ` tank < 0 `，也就是说 ` k ` 肯定不能是起点。

拜托，从 ` i ` 出发走到 ` k ` 好歹 ` tank > 0 ` ，都无法达到 ` j ` ，现在你还让 ` tank = 0 `了，那更不可能走到 ` j ` 了对吧。

**综上，这个结论就被证明了** 。

回想一下我们开头说的暴力解法是怎么做的？

如果我发现从 ` i ` 出发无法走到 ` j ` ，那么显然 ` i ` 不可能是起点。

现在，我们发现了一个新规律，可以推导出什么？

如果我发现从 ` i ` 出发无法走到 ` j ` ，那么 ` i ` 以及 ` i, j ` 之间的所有站点都不可能作为起点。

看到冗余计算了吗？看到优化的点了吗？

**这就是贪心思路的本质，如果找不到重复计算，那就通过问题中一些隐藏较深的规律，来减少冗余计算** 。

根据这个结论，就可以写出如下代码：

```java
    int canCompleteCircuit(int[] gas, int[] cost) {
        int n = gas.length;
        int sum = 0;
        for (int i = 0; i < n; i++) {
            sum += gas[i] - cost[i];
        }
        if (sum < 0) {
            // 总油量小于总的消耗，无解
            return -1;
        }
        // 记录油箱中的油量
        int tank = 0;
        // 记录起点
        int start = 0;
        for (int i = 0; i < n; i++) {
            tank += gas[i] - cost[i];
            if (tank < 0) {
                // 无法从 start 走到 i
                // 所以站点 i + 1 应该是起点
                tank = 0;
                start = i + 1;
            }
        }
        return start == n ? 0 : start;
    }

```

这个解法的时间复杂度也是 O(N)，和之前图像法的解题思路有所不同，但代码非常类似。

**其实，你可以把这个解法的思路结合图像来思考，可以发现它们本质上是一样的，只是理解方式不同而已** 。

对于这种贪心算法，没有特别套路化的思维框架，主要还是靠多做题多思考，将题目的场景进行抽象的联想，找出隐藏其中的规律，从而减少计算量，进行效率优化。

好了，这道题就讲到这里，希望对你拓宽思路有帮助。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**



