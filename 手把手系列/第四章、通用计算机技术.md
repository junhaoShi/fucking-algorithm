# 第四章、通用计算机技术

1、《算法秘籍》和《刷题笔记》两本 PDF 下载 [ 点这里

](https://mp.weixin.qq.com/s/X-fE9sR4BLi6T9pn7xP4pg) 。

2、刷题插件下载及使用手册 [ 点这里 ](https://mp.weixin.qq.com/s/wIxflO1dvXzDlibhEcENcQ) 。

3、公众号菜单栏参与 [ 21 天算法挑战活动 ](https://mp.weixin.qq.com/s/eUG2OOzY3k_ZTz-CFvtv5Q) 。

# Linux 文件系统都是什么鬼


**———–**

Linux 系统大家一定不陌生，学习工作中肯定会和 Linux 打交道。不过谈及 Linux，给人的第一印象可能就是黑乎乎的命令行，乱七八糟的文件夹，甚至安装软件都不知道是怎么安装上去的。

其实这些问题都是用惯了 Windows 的后遗症，多用用 Linux 就会发现这玩意还是挺好用的，关键还能 DIY，非常装逼：

![](https://labuladong.gitee.io/algo/images/linux-fs/desktop.png)

言归正传，本文介绍一下 Linux 的文件系统（File System），简单介绍一下这些文件夹都是干什么的。

![](https://labuladong.gitee.io/algo/images/linux-fs/linux-filesystem.png)

上图是 Linux 文件系统的一个整体结构，无论是什么版本的 Linux 发行版，根目录 ` / `
基本上就是这些文件。不要害怕这么多文件夹，大部分都不需要你操心，只要大概了解它们是干啥的就行了。

### /bin 和 /sbin

` bin ` 是 ` Binary ` 的缩写，存放着可执行文件或可执行文件的链接（类似快捷方式），如下图：

![](https://labuladong.gitee.io/algo/images/linux-fs/bin.png)

你可以看到 ` cp ` , ` chmod ` , ` cat ` 等常用命令都在这里。注意不要被图标上的 TXT 字样误导了，Linux 不按后缀识别文件类型， ` /bin ` 目录中的文件都是可执行的二进制文件，而不是文本文件。

与 ` /bin ` 类似的是 ` /sbin ` 目录，System Binary 的缩写，这里存放的命令可以对系统配置进行操作。普通用户可能可以使用这里的命令查看某些系统状态，但是如果想更改配置，就需要 ` sudo `
授权或者切换成超级用户。

![](https://labuladong.gitee.io/algo/images/linux-fs/sbin.png)

可以看到一些熟悉的命令，比如 ` ifconfig ` , ` iptables ` 。普通用户可以使用 ` ifconfig `
查看网卡状态，但是想配置网卡信息，就需要授权了。

### /boot

![](https://labuladong.gitee.io/algo/images/linux-fs/boot.png)

这里是系统启动需要的文件，你可以看到 ` grub ` 文件夹，它是常见的开机引导程序。我们不应该乱动这里的文件。

### /dev

` dev ` 是 ` device ` 的缩写，这里存放这所有的设备文件。在 Linux 中，所有东西都是以文件的形式存在的，包括硬件设备。

比如说， ` sda ` , ` sdb ` 就是我电脑上的两块硬盘，后面的数字是硬盘分区：

![](https://labuladong.gitee.io/algo/images/linux-fs/dev.png)

鼠标、键盘等等设备也都可以在这里找到。

### /etc

这个目录经常使用，存放很多程序的配置信息，比如包管理工具 apt：

![](https://labuladong.gitee.io/algo/images/linux-fs/etc.png)

在 ` /etc/apt ` 中就存放着对应的配置，比如说镜像列表（我配置的阿里云镜像）：

![](https://labuladong.gitee.io/algo/images/linux-fs/apt.png)

如果你要修改一些系统程序的配置，十有八九要到 ` etc ` 目录下寻找。

### /lib

` lib ` 是 Library 的缩写，类似于 Windows 系统中存放 ` dll ` 文件的库，包含 bin 和 sbin 中可执行文件的依赖。

也可能出现 ` lib32 ` 或 ` lib64 ` 这样的目录，和 ` lib ` 差不多，只是操作系统位数不同而已。

### /media

这里会有一个以你用户名命名的文件夹，里面是自动挂载的设备，比如 U 盘，移动硬盘，网络设备等。

比如说我在电脑上插入一个 U 盘，系统会把 U 盘自动给我挂载到 ` /media/fdl ` 这个文件夹里（我的用户名是 fdl），如果我要访问 U 盘的内容，就可以在那里找到。

### /mnt

这也是和设备挂载相关的一个文件夹，一般是空文件夹。 ` media ` 文件夹是系统自动挂载设备的地方，这里是你手动挂载设备的地方。

比如说，刚才我们在 ` dev ` 中看到了一大堆设备，你想打开某些设备看看里面的内容，就可以通过命令把设备挂载到 ` mnt ` 目录进行操作。

不过一般来说，现在的操作系统已经很聪明了，像挂载设备的操作几乎都不用你手动做，都被自动挂载到 ` media ` 目录了。

### /opt

` opt ` 是 Option 的缩写，这个文件夹的使用比较随意，一般来说我们自己在浏览器上下载的软件，安装在这里比较好。当然，包管理工具下载的软件也可能被存放在这里。

![](https://labuladong.gitee.io/algo/images/linux-fs/opt.png)

比如我在这里存放了 Chrome 浏览器（google），网易云音乐（netease），CLion IDE 等等软件的文件夹。

### /proc

` proc ` 是 ` process ` 的缩写，这里存放的是全部正在运行程序的状态信息。

![](https://labuladong.gitee.io/algo/images/linux-fs/proc.png)

你会发现 ` /proc ` 里面有一大堆数字命名的文件夹，这个数字其实是 Process ID（PID），文件夹里又有很多文件。

前面说过，Linux 中一切都以文件形式储存，类似 ` /dev `
，这里的文件也不是真正的文件，而是程序和内核交流的一些信息。比如说我们可以查看当前操作系统的版本，或者查看 CPU 的状态：

![](https://labuladong.gitee.io/algo/images/linux-fs/cpu.png)

如果你需要调试应用程序， ` proc ` 目录中的信息也许会帮上忙。

### /root

这是 root 用户的家目录，普通用户需要授权才能访问。

### /run 和 /sys

用来存储某些程序的运行时信息和系统需要的一些信息。比如说这个文件：

```java
    sudo vim /sys/devices/pci0000:00/0000:00:02.0/drm/card0/card0-eDP-1/intel_backlight/brightness

```

里面存储着一个数字，是你的显卡亮度，你修改这个数字就可以修改屏幕亮度。

需要注意的是，这两个位置的数据都存储在内存中，所以一旦重启， ` /run ` 和 ` /sys ` 目录的信息就会丢失，所以不要试图在这里存放任何文件。

### /srv

` srv ` 是 ` service ` 的缩写，主要用来存放服务数据。

对于桌面版 Linux 系统，这个文件夹一般是空的，但是对于 Linux 服务器，Web 服务或者 FTP 文件服务的资源可以存放在这里。

### /tmp

` tmp ` 是 ` temporary ` 的缩写，存储一些程序的临时文件。

![](https://labuladong.gitee.io/algo/images/linux-fs/tmp.png)

临时文件可能起到很重要的作用。比如经常听说某同学的 Word 文档崩溃了，好不容易写的东西全没了，Linux 的很多文本编辑器都会在 ` /tmp `
放一份当前文本的 copy 作为临时文件，如果你的编辑器意外崩溃，还有机会在 ` /tmp ` 找一找临时文件抢救一下。

比如上图的 ` VSCode Crashes ` 应该就是 VScode 编辑器存放临时文件的地方。

当然， ` tmp ` 文件夹在系统重启之后会自动被清空，如果没有被清空，说明系统删除某些文件失败，也许需要你手动删除一下。

### /usr

` usr ` 是 Universal System Resource 的缩写，这里存放的是一些 **非系统必须的资源** ，比如用户安装的应用程序。

![](https://labuladong.gitee.io/algo/images/linux-fs/usr.png)

` /usr ` 和 ` /usr/local ` 目录中又含有 ` bin ` 和 ` sbin ` 目录，也是存放可执行文件（命令），但和根目录的 `
bin ` 和 ` sbin ` 不同的是，这里大都是用户使用的工具，而非系统必须使用的。

比如说 ` /usr/bin ` 中含有我通过包管理工具安装的应用程序 Chrome 浏览器和 goldendict 字典的可执行文件：

![](https://labuladong.gitee.io/algo/images/linux-fs/usrbin.png)

值得一提的是，如果使用 Linux 桌面版，有时候在桌面找不到应用程序的快捷方式，就需要在 ` /usr/share/applications `
中手动配置桌面图标文件：

![](https://labuladong.gitee.io/algo/images/linux-fs/application.png)

### /var

` var ` 是 ` variable `
的缩写，这个名字是历史遗留的，现在该目录最主要的作用是存储日志（log）信息，比如说程序崩溃，防火墙检测到异常等等信息都会记录在这里。

这是我的 ` /var/log ` 目录：

![](https://labuladong.gitee.io/algo/images/linux-fs/log.png)

日志文件不会自动删除，也就是说随着系统使用时间的增长，你的 ` var ` 目录占用的磁盘空间会越来越大，也许需要适时清理一下。

### /home

最后说 ` home ` 目录，这是普通用户的家目录。在桌面版的 Linux 系统中，用户的家目录会有下载、视频、音乐、桌面等文件夹，这些没啥可说的，我们说一些隐藏的比较重要的文件夹（Linux 中名称以 ` . `
开头就是隐藏文件）。

这是我的家目录的部分文件：

![](https://labuladong.gitee.io/algo/images/linux-fs/home.png)

其中 ` .cache ` 文件夹存储应用缓存数据， ` .config ` 文件夹存储了一部分应用程序的配置，比如说我的 Chrome 浏览器配置就是那里面。但是还有一部分应用程序并不把配置储存在 ` .config `
文件夹，而是自己创建一个隐藏文件夹，存放自己的配置文件等等信息，比如你可以看到 Intellij 的配置文件就不在 ` .config ` 中。

最后说 ` .local ` 文件夹，有点像 ` /usr/local ` ，里面也有 ` bin ` 文件夹，也是存放可执行文件的。比如说我的 python pip 以及 pip 安装的一些工具，都存放在 ` ～/.local/bin `
目录中。 **但是，存在这里的文件，只有该用户才能使用**
。

这就是为什么，有时候普通用户可以使用的命令，用 sudo 或者超级用户却被告知找不到该命令。因为有的命令是特定用户家目录里的，被添加到了该用户的 `
PATH ` 环境变量里，他可以直接用。你超级用户想用当然可以，但是得写全绝对路径才行。

### 最后总结

如果修改系统配置，就去 ` /etc ` 找，如果修改用户的应用程序配置，就在用户家目录的隐藏文件里找。

你在命令行里可以直接输入使用的命令，其可执行文件一般就在以下几个位置：

```java
    /bin    
    /sbin
    /usr/bin
    /usr/sbin
    /usr/local/bin
    /usr/local/sbin
    /home/USER/.local/bin
    /home/USER/.local/sbin

```

如果你写了一个脚本/程序，想在任何时候都能直接调用，可以把这个脚本/程序添加到上述目录中。

如果某个程序崩溃了，可以到 ` /val/log ` 中尝试寻找出错信息，到 ` /tmp ` 中寻找残留的临时文件。

设备文件在 ` /dev ` 目录，但是一般来说系统会自动帮你挂载诸如 U 盘之类的设备，可以到 ` /media ` 文件夹访问设备内容。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**





# Linux 的进程、线程、文件描述符是什么




** ~

**———–**

说到进程，恐怕面试中最常见的问题就是线程和进程的关系了，那么先说一下答案： **在 Linux 系统中，进程和线程几乎没有区别** 。

Linux 中的进程就是一个数据结构，看明白就可以理解文件描述符、重定向、管道命令的底层工作原理，最后我们从操作系统的角度看看为什么说线程和进程基本没有区别。

### 一、进程是什么

首先，抽象地来说，我们的计算机就是这个东西：

![](https://labuladong.gitee.io/algo/images/linuxProcess/1.jpg)

这个大的矩形表示计算机的 **内存空间** ，其中的小矩形代表 **进程** ，左下角的圆形表示 **磁盘** ，右下角的图形表示一些 **输入输出设备**
，比如鼠标键盘显示器等等。另外，注意到内存空间被划分为了两块，上半部分表示 **用户空间** ，下半部分表示 **内核空间** 。

用户空间装着用户进程需要使用的资源，比如你在程序代码里开一个数组，这个数组肯定存在用户空间；内核空间存放内核进程需要加载的系统资源，这一些资源一般是不允许用户访问的。但是注意有的用户进程会共享一些内核空间的资源，比如一些动态链接库等等。

我们用 C 语言写一个 hello 程序，编译后得到一个可执行文件，在命令行运行就可以打印出一句 hello world，然后程序退出。在操作系统层面，就是新建了一个进程，这个进程将我们编译出来的可执行文件读入内存空间，然后执行，最后退出。

**你编译好的那个可执行程序只是一个文件**
，不是进程，可执行文件必须要载入内存，包装成一个进程才能真正跑起来。进程是要依靠操作系统创建的，每个进程都有它的固有属性，比如进程号（PID）、进程状态、打开的文件等等，进程创建好之后，读入你的程序，你的程序才被系统执行。

那么，操作系统是如何创建进程的呢？ **对于操作系统，进程就是一个数据结构** ，我们直接来看 Linux 的源码：

```java
    struct task_struct {
    	// 进程状态
    	long			  state;
    	// 虚拟内存结构体
    	struct mm_struct  *mm;
    	// 进程号
    	pid_t			  pid;
    	// 指向父进程的指针
    	struct task_struct __rcu  *parent;
    	// 子进程列表
    	struct list_head		children;
    	// 存放文件系统信息的指针
    	struct fs_struct		*fs;
    	// 一个数组，包含该进程打开的文件指针
    	struct files_struct		*files;
    };

```

` task_struct ` 就是 Linux 内核对于一个进程的描述，也可以称为「进程描述符」。源码比较复杂，我这里就截取了一小部分比较常见的。

其中比较有意思的是 ` mm ` 指针和 ` files ` 指针。 ` mm ` 指向的是进程的虚拟内存，也就是载入资源和可执行文件的地方； `
files ` 指针指向一个数组，这个数组里装着所有该进程打开的文件的指针。

### 二、文件描述符是什么

先说 ` files ` ，它是一个文件指针数组。一般来说，一个进程会从 ` files[0] ` 读取输入，将输出写入 ` files[1] `
，将错误信息写入 ` files[2] ` 。

举个例子，以我们的角度 C 语言的 ` printf ` 函数是向命令行打印字符，但是从进程的角度来看，就是向 ` files[1] ` 写入数据；同理，
` scanf ` 函数就是进程试图从 ` files[0] ` 这个文件中读取数据。

**每个进程被创建时，` files `
的前三位被填入默认值，分别指向标准输入流、标准输出流、标准错误流。我们常说的「文件描述符」就是指这个文件指针数组的索引 **
，所以程序的文件描述符默认情况下 0 是输入，1 是输出，2 是错误。

我们可以重新画一幅图：

![](https://labuladong.gitee.io/algo/images/linuxProcess/2.jpg)

对于一般的计算机，输入流是键盘，输出流是显示器，错误流也是显示器，所以现在这个进程和内核连了三根线。因为硬件都是由内核管理的，我们的进程需要通过「系统调用」让内核进程访问硬件资源。

> PS：不要忘了，Linux 中一切都被抽象成文件，设备也是文件，可以进行读和写。

如果我们写的程序需要其他资源，比如打开一个文件进行读写，这也很简单，进行系统调用，让内核把文件打开，这个文件就会被放到 ` files ` 的第 4 个位置：

![](https://labuladong.gitee.io/algo/images/linuxProcess/3.jpg)

明白了这个原理， **输入重定向** 就很好理解了，程序想读取数据的时候就会去 ` files[0] ` 读取，所以我们只要把 ` files[0] `
指向一个文件，那么程序就会从这个文件中读取数据，而不是从键盘：

```java
    $ command < file.txt

```

![](https://labuladong.gitee.io/algo/images/linuxProcess/5.jpg)

同理， **输出重定向** 就是把 ` files[1] ` 指向一个文件，那么程序的输出就不会写入到显示器，而是写入到这个文件中：

```java
    $ command > file.txt

```

![](https://labuladong.gitee.io/algo/images/linuxProcess/4.jpg)

错误重定向也是一样的，就不再赘述。

**管道符** 其实也是异曲同工，把一个进程的输出流和另一个进程的输入流接起一条「管道」，数据就在其中传递，不得不说这种设计思想真的很优美：

```java
    $ cmd1 | cmd2 | cmd3

```

![](https://labuladong.gitee.io/algo/images/linuxProcess/6.jpg)

到这里，你可能也看出「Linux 中一切皆文件」设计思路的高明了，不管是设备、另一个进程、socket 套接字还是真正的文件，全部都可以读写，统一装进一个简单的 ` files `
数组，进程通过简单的文件描述符访问相应资源，具体细节交于操作系统，有效解耦，优美高效。

### 三、线程是什么

首先要明确的是，多进程和多线程都是并发，都可以提高处理器的利用效率，所以现在的关键是，多线程和多进程有啥区别。

为什么说 Linux 中线程和进程基本没有区别呢，因为从 Linux 内核的角度来看，并没有把线程和进程区别对待。

我们知道系统调用 ` fork() ` 可以新建一个子进程，函数 ` pthread() ` 可以新建一个线程。 **但无论线程还是进程，都是用`
task_struct ` 结构表示的，唯一的区别就是共享的数据区域不同 ** 。

换句话说，线程看起来跟进程没有区别，只是线程的某些数据区域和其父进程是共享的，而子进程是拷贝副本，而不是共享。就比如说， ` mm ` 结构和 `
files ` 结构在线程中都是共享的，我画两张图你就明白了：

![](https://labuladong.gitee.io/algo/images/linuxProcess/7.jpg) ![](https://labuladong.gitee.io/algo/images/linuxProcess/8.jpg)

所以说，我们的多线程程序要利用锁机制，避免多个线程同时往同一区域写入数据，否则可能造成数据错乱。

那么你可能问， **既然进程和线程差不多，而且多进程数据不共享，即不存在数据错乱的问题，为什么多线程的使用比多进程普遍得多呢** ？

因为现实中数据共享的并发更普遍呀，比如十个人同时从一个账户取十元，我们希望的是这个共享账户的余额正确减少一百元，而不是希望每人获得一个账户的拷贝，每个拷贝账户减少十元。

当然，必须要说明的是，只有 Linux 系统将线程看做共享数据的进程，不对其做特殊看待，其他的很多操作系统是对线程和进程区别对待的，线程有其特有的数据结构，我个人认为不如 Linux 的这种设计简洁，增加了系统的复杂度。

在 Linux 中新建线程和进程的效率都是很高的，对于新建进程时内存区域拷贝的问题，Linux 采用了 copy-on-write 的策略优化，也就是并不真正复制父进程的内存空间，而是等到需要写操作时才去复制。 **所以 Linux
中新建进程和新建线程都是很迅速的** 。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**





# 关于 Linux shell 你必须知道的




** ~

**———–**

我个人很喜欢使用 Linux 系统，虽然说 Windows 的图形化界面做的确实比 Linux 好，但是对脚本的支持太差了。一开始有点不习惯命令行操作，但是熟悉了之后反而发现移动鼠标点点点才是浪费时间的罪魁祸首。。。

**那么对于 Linux 命令行，本文不是介绍某些命令的用法，而是说明一些简单却特别容易让人迷惑的细节问题** 。

1、标准输入和命令参数的区别。

2、在后台运行命令在退出终端后也全部退出了。

3、单引号和双引号表示字符串的区别。

4、有的命令和 ` sudo ` 一起用就 command not found。

### 一、标准输入和参数的区别

这个问题一定是最容易让人迷惑的，具体来说，就是搞不清什么时候用管道符 ` | ` 和文件重定向 ` > ` ， ` < ` ，什么时候用变量 ` $ ` 。

比如说，我现在有个自动连接宽带的 shell 脚本 ` connect.sh ` ，存在我的家目录：

```java
    $ where connect.sh
    /home/fdl/bin/connect.sh

```

如果我想删除这个脚本，而且想少敲几次键盘，应该怎么操作呢？我曾经这样尝试过：

```java
    $ where connect.sh | rm

```

实际上，这样操作是错误的，正确的做法应该是这样的：

```java
    $ rm $(where connect.sh)

```

前者试图将 ` where ` 的结果连接到 ` rm ` 的标准输入，后者试图将结果作为命令行参数传入。

**标准输入就是编程语言中诸如` scanf ` 或者 ` readline ` 这种命令；而参数是指程序的 ` main ` 函数传入的 ` args `
字符数组 ** 。

前文 [ Linux文件描述符 ](https://labuladong.gitee.io/algo/5/34/) 说过，管道符和重定向符是将数据作为程序的标准输入，而 ` $(cmd) ` 是读取 ` cmd
` 命令输出的数据作为参数。

用刚才的例子说， ` rm ` 命令源代码中肯定不接受标准输入，而是接收命令行参数，删除相应的文件。作为对比， ` cat `
命令是既接受标准输入，又接受命令行参数：

```java
    $ cat filename
    ...file text...
    
    $ cat < filename
    ...file text...
    
    $ echo 'hello world' | cat
    hello world

```

**如果命令能够让终端阻塞，说明该命令接收标准输入，反之就是不接受** ，比如你只运行 ` cat `
命令不加任何参数，终端就会阻塞，等待你输入字符串并回显相同的字符串。

### 二、后台运行程序

比如说你远程登录到服务器上，运行一个 Django web 程序：

```java
    $ python manager.py runserver 0.0.0.0
    Listening on 0.0.0.0:8080...

```

现在你可以通过服务器的 IP 地址测试 Django 服务，但是终端此时就阻塞了，你输入什么都不响应，除非输入 Ctrl-C 或者 Ctrl-/ 终止 python 进程。

可以在命令之后加一个 ` & ` 符号，这样命令行不会阻塞，可以响应你后续输入的命令，但是如果你退出服务器的登录，就不能访问该网页了。

如果你想在退出服务器之后仍然能够访问 web 服务，应该这样写命令 ` (cmd &) ` ：

```java
    $ (python manager.py runserver 0.0.0.0 &)
    Listening on 0.0.0.0:8080...
    
    $ logout

```

**底层原理是这样的** ：

每一个命令行终端都是一个 shell 进程，你在这个终端里执行的程序实际上都是这个 shell 进程分出来的子进程。正常情况下，shell 进程会阻塞，等待子进程退出才重新接收你输入的新的命令。加上 ` & ` 号，只是让 shell
进程不再阻塞，可以继续响应你的新命令。但是无论如何，你如果关掉了这个 shell 命令行端口，依附于它的所有子进程都会退出。

而 ` (cmd &) ` 这样运行命令，则是将 ` cmd ` 命令挂到一个 ` systemd ` 系统守护进程名下，认 ` systemd `
做爸爸，这样当你退出当前终端时，对于刚才的 ` cmd ` 命令就完全没有影响了。

类似的，还有一种后台运行常用的做法是这样：

```java
    $ nohup some_cmd &

```

` nohub ` 命令也是类似的原理，不过通过我的测试，还是 ` (cmd &) ` 这种形式更加稳定。

### 三、单引号和双引号的区别

不同的 shell 行为会有细微区别，但有一点是确定的， **对于` $ ` ， ` ( ` ， ` ) `
这几个符号，单引号包围的字符串不会做任何转义，双引号包围的字符串会转义 ** 。

shell 的行为可以测试，使用 ` set -x ` 命令，会开启 shell 的命令回显，你可以通过回显观察 shell 到底在执行什么命令：

![](https://labuladong.gitee.io/algo/images/linuxshell/1.png)

可见 ` echo $(cmd) ` 和 ` echo "$(cmd)" `
，结果差不多，但是仍然有区别。注意观察，双引号转义完成的结果会自动增加单引号，而前者不会。

**也就是说，如果` $ ` 读取出的参数字符串包含空格，应该用双引号括起来，否则就会出错 ** 。

### 四、sudo 找不到命令

有时候我们普通用户可以用的命令，用 ` sudo ` 加权限之后却报错 command not found：

```java
    $ connect.sh
    network-manager: Permission denied
    
    $ sudo connect.sh
    sudo: command not found

```

原因在于， ` connect.sh ` 这个脚本仅存在于该用户的环境变量中：

```java
    $ where connect.sh 
    /home/fdl/bin/connect.sh

```

**当使用` sudo ` 时，系统会使用 ` /etc/sudoers ` 这个文件中规定的该用户的权限和环境变量 ** ，而这个脚本在 `
/etc/sudoers ` 环境变量目录中当然是找不到的。

解决方法是使用脚本文件的路径，而不是仅仅通过脚本名称：

```java
    $ sudo /home/fdl/bin/connect.sh

```

**＿＿＿＿＿＿＿＿＿＿＿＿＿**





# Linux shell 的实用小技巧




** ~

**———–**

前几篇关于 Linux 的文章很受欢迎，很多读者都希望我多写写这方面的文章。我以后会定期分享一些 Linux 的实用小技巧，你用习惯之后可能就会和我一样，使用 Windows 就头疼。。。

先说句题外话，大家总是问能不能装双系统，装什么 Linux 发行版比较好。这里统一回答一下，装双系统很简单的，网上很多教程； **至于发行版，推荐 Ubuntu**
，不要迷恋那些看起来牛逼的小众发行版，我们的评判标准是是否稳定，是否拥有完善的社区支持，这两点 Ubuntu 桌面版无疑是最好的。我之前遇到蓝牙键盘的适配问题，Ubuntu 社区上竟然有大佬直接写了个驱动，完美解决，真是意料之外。

当然，你要是有时间爱折腾，可以随意。或者你有钱，你也不需要纠结 Linux 发行版，玩 MacBook 吧，它也是基于 Linux 的。

回归主题，我认为 Linux 的迷人之处在于完善的社区和许多小而美的工具，加之管道符、重定向等等漂亮的设计理念，可以将很多复杂的工作自动化。本文就介绍一些基本的 Linux shell 技巧，相信可以帮你提高生产力！

### 输入相似文件名太麻烦

用花括号括起来的字符串用逗号连接，可以自动扩展，非常有用，直接看例子：

```java
    $ echo {one,two,three}file
    onefile twofile threefile
    
    $ echo {one,two,three}{1,2,3}
    one1 one2 one3 two1 two2 two3 three1 three2 three3

```

你看，花括号中的每个字符都可以和之后（或之前）的字符串进行组合拼接， **注意花括号和其中的逗号不可以用空格分隔，否则会被认为是普通的字符串对待** 。

这个技巧有什么实际用处呢？最简单有用的就是给 ` cp ` , ` mv ` , ` rm ` 等命令扩展参数：

```java
    $ cp /very/long/path/file{,.bak}
    # 给 file 复制一个叫做 file.bak 的副本
    
    $ rm file{1,3,5}.txt
    # 删除 file1.txt file3.txt file5.txt
    
    $ mv *.{c,cpp} src/
    # 将所有 .c 和 .cpp 为后缀的文件移入 src 文件夹

```

### 输入路径名称太麻烦

**用` cd - ` 返回刚才呆的目录 ** ，直接看例子吧：

```java
    $ pwd
    /very/long/path
    $ cd # 回到家目录瞅瞅
    $ pwd
    /home/labuladong
    $ cd - # 再返回刚才那个目录
    $ pwd
    /very/long/path

```

**特殊命令` !$ ` 会替换成上一次命令最后的路径 ** ，直接看例子：

```java
    # 没有加可执行权限
    $ /usr/bin/script.sh
    zsh: permission denied: /usr/bin/script.sh
    
    $ chmod +x !$
    chmod +x /usr/bin/script.sh

```

**特殊命令` !* ` 会替换成上一次命令输入的所有文件路径 ** ，直接看例子：

```java
    # 创建了三个脚本文件
    $ file script1.sh script2.sh script3.sh
    
    # 给它们全部加上可执行权限
    $ chmod +x !*
    chmod +x script1.sh script2.sh script3.sh

```

**可以在环境变量` CDPATH ` 中加入你常用的工作目录 ** ，当 ` cd ` 命令在当前目录中找不到你指定的文件/目录时，会自动到 `
CDPATH ` 中的目录中寻找。

比如说我常去 ` /var/log ` 目录找日志，可以执行如下命令：

```java
    $ export CDPATH='~:/var/log'
    # cd 命令将会在 ～ 目录和 /var/log 目录扩展搜索
    
    $ pwd
    /home/labuladong/musics
    $ cd mysql
    cd /var/log/mysql
    $ pwd
    /var/log/mysql
    $ cd my_pictures
    cd /home/labuladong/my_pictures

```

这个技巧是十分好用的，这样就免了经常写完整的路径名称，节约不少时间。

需要注意的是，以上操作是 bash 支持的，其他主流 shell 解释器当然都支持扩展 ` cd ` 命令的搜索目录，但可能不是修改 ` CDPATH `
这个变量，具体的设置方法可以自行搜索。

### 输入重复命令太麻烦

**使用特殊命令` !! ` ，可以自动替换成上一次使用的命令 ** ：

```java
    $ apt install net-tools
    E: Could not open lock file - open (13: Permission denied)
    
    $ sudo !!
    sudo apt install net-tools
    [sudo] password for fdl:

```

有的命令很长，一时间想不起来具体参数了怎么办？

**对于 bash 终端，可以使用` Ctrl+R ` 快捷键反向搜索历史命令 ** ，之所以说是反向搜索，就是搜索最近一次输入的命令。

比如按下 ` Ctrl+R ` 之后，输入 ` sudo ` ，bash 就会搜索出最近一次包含 ` sudo ` 的命令，你回车之后就可以运行该命令了：

```java
    (reverse-i-search)`sudo': sudo apt install git

```

但是这个方法有缺点：首先，该功能似乎只有 bash 支持，我用的 zsh 作为 shell 终端，就用不了；第二，只能查找出一个（最近的）命令，如果我想找以前的某个命令，就没办法了。

对于这种情况， **我们最常用的方法是使用` history ` 命令配合管道符和 ` grep ` 命令来寻找某个历史命令 ** ：

```java
    # 过滤出所有包含 config 字段的历史命令
    $ history | grep 'config'
     7352  ./configure
     7434  git config --global --unset https.proxy
     9609  ifconfig
     9985  clip -o | sed -z 's/\n/,\n/g' | clip
    10433  cd ~/.config

```

你使用的所有 shell 命令都会被记录，前面的数字就表示这是第几个命令，找到你想重复使用的命令后，也不需要复制粘贴该命令， **只要使用` ! ` + 你想重用的命令编号即可运行该命令 ** 。

拿上面的例子，我想重新运行 ` git config ` 那条命令，就可以这样：

```java
    $ !7434
    git config --global --unset https.proxy
    # 运行完成

```

我觉得 ` history ` 加管道加 ` grep ` 这样打的字还是太多，可以在 你的 shell 配置文件中（ ` .bashrc ` ， `
.zshrc ` 等） 中写这样一个函数：

```java
    his()
    {
        history | grep "$@"
    }

```

这样就不需要写那么多，只需要 ` his 'some_keyword' ` 即可搜索历史命令。

我一般不使用 bash 作为终端，我给大家推荐一款很好用的 shell 终端叫做 zsh，这也是我自己使用的 shell。这款终端还可以扩展各种插件，非常好用，具体配置方法可自行搜索。

### 其他小技巧

**1、` yes ` 命令自动输入字符 ` y ` 进行确认 ** ：

我们安装某些软件的时候，可能有交互式的提问：

```java
    $ sudo apt install XXX
    ...
    XXX will use 996 MB disk space, continue? [y/n]

```

一般情况下我们都是一路 y 到底，但如果我们想自动化一些软件的安装就很烦，遇到这种交互式提问就卡住了，还得手动处理。

` yes ` 命令可以帮助我们：

```java
    $ yes | your_cmd

```

这样就会一路自动 ` y ` 下去，不会停下让我们输入了。

如果你读过前文 [ Linux 文件描述符 ](https://labuladong.gitee.io/algo/5/34/) ，就知道其原理很简单：

你单独运行一下 ` yes ` 命令，发现它就是打印出一大堆字符 y，通过管道把输出和 ` your_cmd ` 的标准输入相连接，如果 `
your_cmd ` 又提出无聊的问题，就会从标准输入读取数据，也就会读取到一个 y 和换行符，和你手动输入 y 确认是一个效果。

**2、特殊变量` $? ` 记录上一次命令的返回值 ** 。

在 Linux shell 中，遵循 C 语言的习惯，返回值为 0 的话就是程序正常退出，非 0 值就是异常退出出。读取上一次命令的返回值在平时使用命令行时感觉没什么用，但是如果你想编写一些 shell 脚本，知道返回值非常有用。

**举个实际的例子** ，比如我的 Github 仓库 fucking-algorithm ，我需要给其中所有 markdown 文件最下方添加上一篇、下一篇、目录三个页脚链接，有的文章已经有了页脚，大部分都没有。

为了防止重复添加，我必须知道一个 md 文件下方是否已添加，这时候就可以使用 ` $? ` 变量配合 ` grep ` 命令做到：

```java
    #!/bin/bash
    filename=$1
    # 查看文件尾部是否包含关键词
    tail | grep '下一篇' $filename
    # grep 查找到匹配会返回 0，找不到则返回非 0 值
    [ $? -ne 0 ] && { 添加页脚; }

```

**3、特殊变量` $$ ` 记录当前进程的 PID ** 。

这个功能可能在平时使用时也不怎么用，但是在写 shell 脚本时也非常有用，比如说你要在 ` /tmp `
创建临时文件，给文件起名字一直都是非常让人费脑子的，这时候可以使用 ` $$ ` 变量扩展出当前进程的 PID 作为临时文件名，PID 在计算机中都是唯一的，所以绝不会重复，也不需要你记住临时文件的名字。

好了，今天就分享这些技巧吧，如果大家对 Linux 有兴趣，可以点在看分享，数据不错的话下次再写点。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**





# Linux 管道符原理大揭秘




** ~

**———–**

我很喜欢 Linux 系统，尤其是 Linux 的一些设计很漂亮，比如可以将一些复杂的问题分解成若干小问题，通过管道符和重定向机制灵活地用现成的工具解决，写成 shell 脚本就很高效。

前文写过好几篇 Linux 相关的文章：

* [ Linux 文件系统都是什么鬼 ](https://labuladong.gitee.io/algo/5/33/)
* [ Linux shell 小技巧（一） ](https://labuladong.gitee.io/algo/5/35/)
* [ Linux shell 小技巧（二） ](https://labuladong.gitee.io/algo/5/36/)
* [ Linux 进程/管道/重定向/文件描述符 ](https://labuladong.gitee.io/algo/5/34/)

本文就分享一下我在实践中使用重定向和管道符遇到的一些坑，搞明白一些底层原理，写脚本的效率能提升不少。

### > 和 » 重定向符的坑

先说第一个问题，执行如下命令会发生什么？

```java
    $ cat file.txt > file.txt

```

读取再写入同一个文件，感觉什么也不会发生对吧？

**实际上，上述命令运行的结果是清空` file.txt ` 文件中的内容 ** 。

> PS：有的 Linux 发行版可能会直接报错，可以执行 ` cat < file.txt > file.txt ` 绕开这个检测。

前文 [ Linux 进程和文件描述符 ](https://labuladong.gitee.io/algo/5/34/) 说过，程序本身没有必要关心自己的标准输入/输出指向哪里，是 shell 通过管道符和重定向符号修改了程序的标准输入/输出的位置。

所以执行 ` cat file.txt > file.txt ` 这个命令时，shell 会先打开 ` file.txt ` ，由于重定向符号是 ` > `
，所以文件中的内容会被清空，然后 shell 将 ` cat ` 命令的标准输出设置为 ` file.txt ` ，这时候 ` cat ` 命令才开始执行。

也就是如下过程：

1、shell 打开 ` file.txt ` 并清空其内容。

2、shell 将 ` cat ` 命令的标准输出指向 ` file.txt ` 文件。

3、shell 执行 ` cat ` 命令，读了一个空文件。

4、 ` cat ` 命令将空字符串写入标准输出（ ` file.txt ` 文件）。

所以，最后的结果就是 ` file.txt ` 变成了空文件。

我们知道， ` > ` 会清空目标文件， ` >> ` 会在目标文件尾部追加内容， **那么如果将重定向符` > ` 改成 ` >> ` 会怎样呢 ** ？

```java
    $ echo hello world > file.txt # 文件中只有一行内容
    $ cat file.txt >> file.txt # 这个命令会死循环

```

` file.txt ` 中首先被写入一行内容，执行 ` cat file.txt >> file.txt ` 后预期的结果应该是两行内容。

但是很遗憾，运行结果并不符合预期，而是会死循环不断向 ` file.txt ` 中写入 hello world，文件很快就会变得很大，只能用 Control+C 停止命令。

这就有意思了，为什么会死循环呢？其实稍加分析就可以想到原因：

首先要回忆 ` cat ` 命令的行为，如果只执行 ` cat ` 命令，就会从命令行读取键盘输入的内容，每次按下回车， ` cat `
命令就会回显输入，也就是说， ` cat ` 命令是逐行读取数据然后输出数据的。

那么， ` cat file.txt >> file.txt ` 命令的执行过程如下：

1、打开 ` file.txt ` ，准备在文件尾部追加内容。

2、将 ` cat ` 命令的标准输出指向 ` file.txt ` 文件。

3、 ` cat ` 命令读取 ` file.txt ` 中的一行内容并写入标准输出（追加到 ` file.txt ` 文件中）。

4、由于刚写入了一行数据， ` cat ` 命令发现 ` file.txt ` 中还有可以读取的内容，就会重复步骤 3。

**以上过程，就好比一边遍历列表，一遍往列表里追加元素一样，永远遍历不完，所以导致我们的命令死循环** 。

### > 重定向符和 | 管道符配合

我们经常会遇到这样的需求：截取文件的前 XX 行，其余的都删除。

在 Linux 中， ` head ` 命令可以完成截取文件前几行的功能：

```java
    $ cat file.txt # file.txt 中有五行内容
    1
    2
    3
    4
    5
    $ head -n 2 file.txt # head 命令读取前两行
    1
    2
    $ cat file.txt | head -n 2 # head 也可以读取标准输入
    1
    2

```

如果我们想保留文件的前 2 行，其他的都删除，可能会用如下命令：

```java
    $ head -n 2 file.txt > file.txt

```

但是这就犯了前文说的错误，最后 ` file.txt ` 会被清空，不能实现我们的需求。

那我们是这样写命令是否可以避坑呢：

```java
    $ cat file.txt | head -n 2 > file.txt

```

**结论是不行，因为管道符连接的多个命令是并行执行的** 。

前文 [ Linux 进程和文件描述符 ](https://labuladong.gitee.io/algo/5/34/)
也说过管道符的实现原理，本质上就是将两个命令的标准输入和输出连接起来，让前一个命令的标准输出作为下一个命令的标准输入。

但是，如果你认为这样写命令可以得到预期的结果，那可能是因为你认为管道符连接的命令是串行执行的，这是一个常见的错误。

你可能以为，shell 会先执行 ` cat file.txt ` 命令，正常读取 ` file.txt ` 中的所有内容，然后把这些内容通过管道传递给 `
head -n 2 > file.txt ` 命令。

虽然这时候 ` file.txt ` 中的内容会被清空，但是 ` head ` 并没有从文件中读取数据，而是从管道读取数据，所以应该可以向 `
file.txt ` 正确写入两行数据。

但实际上，上述理解是错误的，shell 会并行执行管道符连接的命令，比如说执行如下命令：

```java
    $ sleep 5 | sleep 5

```

shell 会同时启动两个 ` sleep ` 进程，所以执行结果是睡眠 5 秒，而不是 10 秒。

这是有点违背直觉的，比如这种常见的命令：

```java
    $ cat filename | grep 'pattern'

```

直觉好像是先执行 ` cat ` 命令一次性读取了 ` filename ` 中所有的内容，然后传递给 ` grep ` 命令进行搜索。

但实际上是 ` cat ` 和 ` grep ` 命令是同时执行的，之所以能得到预期的结果，是因为 ` grep 'pattern' `
会阻塞等待标准输入，而 ` cat ` 通过 Linux 管道向 ` grep ` 的标准输入写入数据。

执行下面这个命令能直观感受到 ` cat ` 和 ` grep ` 是在同时执行的， ` grep ` 在实时处理我们用键盘输入的数据：

```java
    $ cat | grep 'pattern'

```

说了这么多，再回顾一开始的问题：

```java
    $ cat file.txt | head -n 2 > file.txt

```

**` cat ` 命令和 ` head ` 会并行执行，谁先谁后不确定，执行结果也就不确定 ** 。

如果 ` head ` 命令先于 ` cat ` 执行，那么 ` file.txt ` 就会被先清空， ` cat ` 也就读取不到任何内容；反之，如果 `
cat ` 先把文件的内容读取出来，那么可以得到预期的结果。

不过，通过我的实验（将这种并发情况重复 1w 次）发现， ` file.txt `
被清空这种错误情况出现的概率远大于预期结果出现的概率，这个暂时还不清楚是为什么，应该和 Linux 内核实现进程和管道的逻辑有关。

### 解决方案

说了这么多管道符和重定向符的特点，如何才能避免这个文件被清空的坑呢？

**最靠谱的办法就是不要同时对同一个文件进行读写，而是通过临时文件的方式做一个中转** 。

比如说只保留 ` file.txt ` 文件中的头两行，可以这样写代码：

```java
    # 先把数据写入临时文件，然后覆盖原始文件
    $ cat file.txt | head -n 2 > temp.txt && mv temp.txt file.txt

```

**这是最简单，最可靠，万无一失的方法** 。

你如果嫌这段命令太长，也可以通过 ` apt/brew/yum ` 等包管理工具安装 ` moreutils ` 包，就会多出一个 ` sponge `
命令，像这样使用：

```java
    # 先把数据传给 sponge，然后由 sponge 写入原始文件
    $ cat file.txt | head -n 2 | sponge file.txt

```

` sponge ` 这个单词的意思是海绵，挺形象的，它会先把输入的数据「吸收」起来，最后再写入 ` file.txt `
，核心思路和我们使用临时文件时类似的，这个「海绵」就好比一个临时文件，就可以避免同时打开同一个文件进行读写的问题。

以上就是重定向和管道符的一些坑，希望能帮到你。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**





# 一文看懂 session 和 cookie




** ~

**———–**

cookie 大家应该都熟悉，比如说登录某些网站一段时间后，就要求你重新登录；再比如有的同学很喜欢玩爬虫技术，有时候网站就是可以拦截住你的爬虫，这些都和 cookie 有关。如果你明白了服务器后端对于 cookie 和 session
的处理逻辑，就可以解释这些现象，甚至钻一些空子无限白嫖，待我慢慢道来。

### 一、session 和 cookie 简介

cookie 的出现是因为 HTTP 是无状态的一种协议，换句话说，服务器记不住你，可能你每刷新一次网页，就要重新输入一次账号密码进行登录。这显然是让人无法接受的，cookie
的作用就好比服务器给你贴个标签，然后你每次向服务器再发请求时，服务器就能够 cookie 认出你。

抽象地概括一下： **一个 cookie 可以认为是一个「变量」，形如` name=value ` ，存储在浏览器；一个 session 可以理解为一种数据结构，多数情况是「映射」（键值对），存储在服务器上 ** 。

注意，我说的是「一个」cookie 可以认为是一个变量，但是服务器可以一次设置多个 cookie，所以有时候说 cookie 是「一组」键值对儿，这也可以说得通。

cookie 可以在服务器端通过 HTTP 的 SetCookie 字段设置 cookie，比如我用 Go 语言写的一个简单服务：

```java
    func cookie(w http.ResponseWriter, r *http.Request) {
        // 设置了两个 cookie 
    	http.SetCookie(w, &http.Cookie{
    		Name:       "name1",
    		Value:      "value1",
    	})
    
    	http.SetCookie(w, &http.Cookie{
    		Name:  "name2",
    		Value: "value2",
    	})
        // 将字符串写入网页
    	fmt.Fprintln(w, "页面内容")
    }

```

当浏览器访问对应网址时，通过浏览器的开发者工具查看此次 HTTP 通信的细节，可以看见服务器的回应发出了两次 ` SetCookie ` 命令：

![](https://labuladong.gitee.io/algo/images/session/1.png)

在这之后，浏览器的请求中的 ` Cookie ` 字段就带上了这两个 cookie：

![](https://labuladong.gitee.io/algo/images/session/2.png)

**cookie 的作用其实就是这么简单，无非就是服务器给每个客户端（浏览器）打的标签** ，方便服务器辨认而已。当然，HTTP 还有很多参数可以设置 cookie，比如过期时间，或者让某个 cookie 只有某个特定路径才能使用等等。

但问题是，我们也知道现在的很多网站功能很复杂，而且涉及很多的数据交互，比如说电商网站的购物车功能，信息量大，而且结构也比较复杂，无法通过简单的 cookie 机制传递这么多信息，而且要知道 cookie 字段是存储在 HTTP header
中的，就算能够承载这些信息，也会消耗很多的带宽，比较消耗网络资源。

session 就可以配合 cookie 解决这一问题，比如说一个 cookie 存储这样一个变量 ` sessionID=xxxx ` ，仅仅把这一个 cookie 传给服务器，然后服务器通过这个 ID 找到对应的 session，这个
session 是一个数据结构，里面存储着该用户的购物车等详细信息，服务器可以通过这些信息返回该用户的定制化网页，有效解决了追踪用户的问题。

**session 是一个数据结构，由网站的开发者设计，所以可以承载各种数据** ，只要客户端的 cookie 传来一个唯一的 session ID，服务器就可以找到对应的 session，认出这个客户。

当然，由于 session 存储在服务器中，肯定会消耗服务器的资源，所以 session 一般都会有一个过期时间，服务器一般会定期检查并删除过期的
session，如果后来该用户再次访问服务器，可能就会面临重新登录等等措施，然后服务器新建一个 session，将 session ID 通过 cookie 的形式传送给客户端。

那么，我们知道 cookie 和 session 的原理，有什么切实的好处呢？ **除了应对面试，我给你说一个鸡贼的用处，就是可以白嫖某些服务** 。

有些网站，你第一次使用它的服务，它直接免费让你试用，但是用一次之后，就让你登录然后付费继续使用该服务。而且你发现网站似乎通过某些手段记住了你的电脑，除非你换个电脑或者换个浏览器才能再白嫖一次。

那么问题来了，你试用的时候没有登录，网站服务器是怎么记住你的呢？这就很显然了，服务器一定是给你的浏览器打了 cookie，后台建立了对应的 session 记录你的状态。你的浏览器在每次访问该网站的时候都会听话地带着
cookie，服务器一查 session 就知道这个浏览器已经免费使用过了，得让它登录付费，不能让它继续白嫖了。

那如果我不让浏览器发送 cookie，每次都伪装成一个第一次来试用的小萌新，不就可以不断白嫖了么？浏览器会把网站的 cookie 以文件的形式存在某些地方（不同的浏览器配置不同），你把他们找到然后删除就行了。但是对于 Firefox 和
Chrome 浏览器，有很多插件可以直接编辑 cookie，比如我的 Chrome 浏览器就用的一款叫做 EditThisCookie 的插件，这是他们官网：

![](https://labuladong.gitee.io/algo/images/session/3.png)

这类插件可以读取浏览器在当前网页的 cookie，点开插件可以任意编辑和删除 cookie。
**当然，偶尔白嫖一两次还行，不鼓励高频率白嫖，想常用还是掏钱吧，否则网站赚不到钱，就只能取消免费试用这个机制了** 。

以上就是关于 cookie 和 session 的简单介绍，cookie 是 HTTP 协议的一部分，不算复杂，而 session 是可以定制的，所以下面详细看一下实现 session 管理的代码架构吧。

### 二、session 的实现

session 的原理不难，但是具体实现它可是很有技巧的，一般需要三个组件配合完成，它们分别是 ` Manager ` 、 ` Provider ` 和 `
Session ` 三个类（接口）。

![](https://labuladong.gitee.io/algo/images/session/4.jpg)

1、浏览器通过 HTTP 协议向服务器请求路径 ` /content ` 的网页资源，对应路径上有一个 Handler 函数接收请求，解析 HTTP header 中的 cookie，得到其中存储的 sessionID，然后把这个 ID
发给 ` Manager ` 。

2、 ` Manager ` 充当一个 session 管理器的角色，主要存储一些配置信息，比如 session 的存活时间，cookie 的名字等等。而所有的 session 存在 ` Manager `
内部的一个 ` Provider ` 中。所以 ` Manager ` 会把 ` sid
` （sessionID）传递给 ` Provider ` ，让它去找这个 ID 对应的具体是哪个 session。

3、 ` Provider ` 就是一个容器，最常见的应该就是一个散列表，将每个 ` sid ` 和对应的 session 一一映射起来。收到 `
Manager ` 传递的 ` sid ` 之后，它就找到 ` sid ` 对应的 session 结构，也就是 ` Session ` 结构，然后返回它。

4、 ` Session ` 中存储着用户的具体信息，由 Handler 函数中的逻辑拿出这些信息，生成该用户的 HTML 网页，返回给客户端。

那么你也许会问，为什么搞这么麻烦，直接在 Handler 函数中搞一个哈希表，然后存储 ` sid ` 和 ` Session ` 结构的映射不就完事儿了？

**这就是设计层面的技巧了** ，下面就来说说，为什么分成 ` Manager ` 、 ` Provider ` 和 ` Session ` 。

先从最底层的 ` Session ` 说。既然 session 就是键值对，为啥不直接用哈希表，而是要抽象出这么一个数据结构呢？

第一，因为 ` Session ` 结构可能不止存储了一个哈希表，还可以存储一些辅助数据，比如 ` sid `
，访问次数，过期时间或者最后一次的访问时间，这样便于实现想 LRU、LFU 这样的算法。

第二，因为 session 可以有不同的存储方式。如果用编程语言内置的哈希表，那么 session 数据就是存储在内存中，如果数据量大，很容易造成程序崩溃，而且一旦程序结束，所有 session 数据都会丢失。所以可以有很多种
session 的存储方式，比如存入缓存数据库 Redis，或者存入 MySQL 等等。

因此， ` Session ` 结构提供一层抽象，屏蔽不同存储方式的差异，只要提供一组通用接口操纵键值对：

```java
    type Session interface {
        // 设置键值对
        Set(key, val interface{})
        // 获取 key 对应的值
        Get(key interface{}) interface{}
        // 删除键 key
    	Delete(key interface{})
    }

```

再说 ` Provider ` 为啥要抽象出来。我们上面那个图的 ` Provider ` 就是一个散列表，保存 ` sid ` 到 ` Session `
的映射，但是实际中肯定会更加复杂。我们不是要时不时删除一些 session 吗，除了设置存活时间之外，还可以采用一些其他策略，比如 LRU 缓存淘汰算法，这样就需要 ` Provider ` 内部使用哈希链表这种数据结构来存储
session。

> PS：关于 LRU 算法的奥妙，参见前文 [ LRU 算法详解 ](https://labuladong.gitee.io/algo/2/19/43/) 。

因此， ` Provider ` 作为一个容器，就是要屏蔽算法细节，以合理的数据结构和算法组织 ` sid ` 和 ` Session `
的映射关系，只需要实现下面这几个方法实现对 session 的增删查改：

```java
    type Provider interface {
        // 新增并返回一个 session
        SessionCreate(sid string) (Session, error)
        // 删除一个 session
        SessionDestroy(sid string)
        // 查找一个 session
        SessionRead(sid string) (Session, error)
        // 修改一个session
        SessionUpdate(sid string)
        // 通过类似 LRU 的算法回收过期的 session
    	SessionGC(maxLifeTime int64)
    }

```

最后说 ` Manager ` ，大部分具体工作都委托给 ` Session ` 和 ` Provider ` 承担了， ` Manager `
主要就是一个参数集合，比如 session 的存活时间，清理过期 session 的策略，以及 session 的可用存储方式。 ` Manager `
屏蔽了操作的具体细节，我们可以通过 ` Manager ` 灵活地配置 session 机制。

综上，session 机制分成几部分的最主要原因就是解耦，实现定制化。我在 Github 上看过几个 Go 语言实现的 session 服务，源码都很简单，有兴趣的朋友可以学习学习：

[ https://github.com/alexedwards/scs ](https://github.com/alexedwards/scs)

[ https://github.com/astaxie/build-web-application-with-golang

](https://github.com/astaxie/build-web-application-with-golang)

**＿＿＿＿＿＿＿＿＿＿＿＿＿**





# 加密算法的前身今世




** ~

**———–**

说到密码，我们第一个想到的就是登陆账户的密码，但是从密码学的角度来看，这种根本就不算合格的密码。

为什么呢，因为我们的账户密码，是依靠隐蔽性来达到加密作用：密码藏在我心里，你不知道，所以你登不上我的账户。

然而密码技术认为，「保密」信息总有一天会被扒出来，所以加密算法不应该依靠「保密」来保证机密性，而应该做到：即便知道了加密算法，依然无计可施。说的魔幻一点就是，告诉你我的密码，你依然不知道我的密码。

最玄学的就是 Diffie-Hellman 密钥交换算法，我当初就觉得很惊奇，两个人当着你的面互相报几个数字，他们就可以拥有一个共同的秘密，而你却根本不可能算出来这个秘密。下文会着重介绍一下这个算法。

本文讨论的密码技术要解决的主要是信息传输中的加密和解密问题。要假设数据传输过程是不安全的，所有信息都在被窃听的，所以发送端要把信息加密，接收方收到信息之后，肯定得知道如何解密。有意思的是，如果你能够让接收者知道如何解密，那么窃听者不是也能够知道如何解密了吗？

下面， **我们会介绍对称加密算法、密钥交换算法、非对称加密算法、数字签名、公钥证书** ，看看解决安全传输问题的一路坎坷波折。

### 一、对称性加密

对称性密码，也叫共享密钥密码，顾名思义，这种加密方式用相同的密钥进行加密和解密。

比如我说一种最简单的对称加密的方法。首先我们知道信息都可以表示成 0/1 比特序列，也知道相同的两个比特序列做异或运算的结果为 0。

那么我们就可以生成一个长度和原始信息一样的随机比特序列作为密钥，然后用它对原始信息做异或运算，就生成了密文。反之，再用该密钥对密文做一次异或运算，就可以恢复原始信息。

这是一个简单例子，不过有些过于简单，有很多问题。比如密钥的长度和原始信息完全一致，如果原始信息很大，密钥也会一样大，而且生成大量真随机比特序列的计算开销也比较大。

当然，有很多更复杂优秀的对称加密算法解决了这些问题，比如 Rijndael 算法、三重 DES 算法等等。
**它们从算法上是无懈可击的，也就是拥有巨大的密钥空间，基本无法暴力破解，而且加密过程相对快速** 。

**但是，一切对称加密算法的软肋在于密钥的配送**
。加密和解密用同一个密钥，发送方必须设法把密钥发送给接收方。如果窃听者有能力窃取密文，肯定也可以窃取密钥，那么再无懈可击的算法依然不攻自破。

所以，下面介绍两种解决密钥配送问题最常见的算法，分别是 Diffie-Hellman 密钥交换算法和非对称加密算法。

### 二、密钥交换算法

我们所说的密钥一般就是一个很大的数字，算法用这个数加密、解密。问题在于，信道是不安全的，所有发出的数据都会被窃取。换句话说，有没有一种办法，能够让两个人在众目睽睽之下，光明正大地交换一个秘密，把对称性密钥安全地送到接收方的手中？

Diffie-Hellman 密钥交换算法可以做到。
**准确的说，该算法并不是把一个秘密安全地「送给」对方，而是通过一些共享的数字，双方「心中」各自「生成」了一个相同的秘密，而且双方的这个秘密，是第三方窃听者无法生成的**
。

也许这就是传说中的心有灵犀一点通吧。

这个算法规则不算复杂，你甚至都可以找个朋友尝试一下共享秘密，等会我会简单画出它的基本流程。在此之前，需要明确一个问题： **并不是所有运算都有逆运算** 。

最简单的例子就是我们熟知的单向散列函数，给一个数字 ` a ` 和一个散列函数 ` f ` ，你可以很快计算出 ` f(a) ` ，但是如果给你 `
f(a) ` 和 ` f ` ，推出 ` a ` 是一件基本做不到的事。密钥交换算法之所以看起来如此玄幻，就是利用了这种不可逆的性质。

下面，看下密钥交换算法的流程是什么，按照命名惯例，准备执行密钥交换算法的双方称为 Alice 和 Bob，在网络中企图窃取他俩通信内容的坏人称为 Hack 吧。

首先，Alice 和 Bob 协商出两个数字 ` N ` 和 ` G ` 作为生成元，当然协商过程可以被窃听者 Hack 窃取，所以我把这两个数画到中间，代表三方都知道：

![](https://labuladong.gitee.io/algo/images/%e5%af%86%e7%a0%81%e6%8a%80%e6%9c%af/1.jpg)

现在 Alice 和 Bob **心中** 各自想一个数字出来，分别称为 ` A ` 和 ` B ` 吧：

![](https://labuladong.gitee.io/algo/images/%e5%af%86%e7%a0%81%e6%8a%80%e6%9c%af/2.jpg)

现在 Alice 将自己心里的这个数字 ` A ` 和 ` G ` 通过某些运算得出一个数 ` AG ` ，然后发给 Bob；Bob 将自己心里的数 ` B
` 和 ` G ` 通过相同的运算得出一个数 ` BG ` ，然后发给 Alice：

![](https://labuladong.gitee.io/algo/images/%e5%af%86%e7%a0%81%e6%8a%80%e6%9c%af/3.jpg)

现在的情况变成这样了：

![](https://labuladong.gitee.io/algo/images/%e5%af%86%e7%a0%81%e6%8a%80%e6%9c%af/4.jpg)

注意，类似刚才举的散列函数的例子，知道 ` AG ` 和 ` G ` ，并不能反推出 ` A ` 是多少， ` BG ` 同理。

那么，Alice 可以通过 ` BG ` 和自己的 ` A ` 通过某些运算得到一个数 ` ABG ` ，Bob 也可以通过 ` AG ` 和自己的 ` B
` 通过某些运算得到 ` ABG ` ，这个数就是 Alice 和 Bob 共有的秘密。

而对于 Hack，可以窃取传输过程中的 ` G ` ， ` AG ` ， ` BG ` ，但是由于计算不可逆，怎么都无法结合出 ` ABG ` 这个数字。

![](https://labuladong.gitee.io/algo/images/%e5%af%86%e7%a0%81%e6%8a%80%e6%9c%af/5.jpg)

以上就是基本流程，至于具体的数字取值是有讲究的，运算方法在百度上很容易找到，限于篇幅我就不具体写了。

该算法可以在第三者窃听的前提下，算出一个别人无法算出的秘密作为对称性加密算法的密钥，开始对称加密的通信。

对于该算法，Hack 又想到一种破解方法，不是窃听 Alice 和 Bob 的通信数据，而是直接同时冒充 Alice 和 Bob 的身份，也就是我们说的「
**中间人攻击** 」：

![](https://labuladong.gitee.io/algo/images/%e5%af%86%e7%a0%81%e6%8a%80%e6%9c%af/6.jpg)

这样，双方根本无法察觉在和 Hack 共享秘密，后果就是 Hack 可以解密甚至修改数据。

**可见，密钥交换算法也不算完全解决了密钥配送问题，缺陷在于无法核实对方身份** 。所以密钥交换算法之前一般要核实对方身份，比如使用数字签名。

### 三、非对称加密

非对称加密的思路就是，干脆别偷偷摸摸传输密钥了，我把加密密钥和解密密钥分开，公钥用于加密，私钥用于解密。只把公钥传送给对方，然后对方开始给我发送加密的数据，我用私钥就可以解密。至于窃听者，拿到公钥和加密数据也没用，因为只有我手上的私钥才能解密。

可以这样想， **私钥是钥匙，而公钥是锁，可以把锁公开出去，让别人把数据锁起来发给我；而钥匙一定要留在自己手里，用于解锁** 。我们常见的 RSA 算法就是典型的非对称加密算法，具体实现比较复杂，我就不写了，网上很多资料。

在实际应用中，非对称性加密的运算速度要比对称性加密慢很多的，所以传输大量数据时，一般不会用公钥直接加密数据，而是加密对称性加密的密钥，传输给对方，然后双方使用对称性加密算法传输数据。

需要注意的是，类似 Diffie-Hellman 算法， **非对称加密算法也无法确定通信双方的身份，依然会遭到中间人攻击** 。比如 Hack 拦截 Bob 发出的公钥，然后冒充 Bob 的身份给 Alice 发送自己的公钥，那么不知情的
Alice 就会把私密数据用 Hack 的公钥加密，Hack 可以通过私钥解密窃取。

那么，Diffie-Hellman 算法和 RSA 非对称加密算法都可以一定程度上解决密钥配送的问题，也具有相同的缺陷，二者的应用场景有什么区别呢？

简单来说，根据两种算法的基本原理就可以看出来：

如果双方有一个对称加密方案，希望加密通信，而且不能让别人得到钥匙，那么可以使用 Diffie-Hellman 算法交换密钥。

如果你希望任何人都可以对信息加密，而只有你能够解密，那么就使用 RSA 非对称加密算法，公布公钥。

下面，我们尝试着解决认证发送方身份的问题。

### 四、数字签名

刚才说非对称加密，把公钥公开用于他人对数据加密然后发给你，只有用你手上对应的私钥才能将密文解密。其实， **私钥也可用用来加密数据的，对于 RSA 算法，私钥加密的数据只有公钥才能解开** 。

数字签名也是利用了非对称性密钥的特性，但是和公钥加密完全颠倒过来： **仍然公布公钥，但是用你的私钥加密数据，然后把加密的数据公布出去，这就是数字签名**
。

你可能问，这有什么用，公钥可以解开私钥加密，我还加密发出去，不是多此一举吗？

是的，但是 **数字签名的作用本来就不是保证数据的机密性，而是证明你的身份** ，证明这些数据确实是由你本人发出的。

你想想，你的私钥加密的数据，只有你的公钥才能解开，那么如果一份加密数据能够被你的公钥解开，不就说明这份数据是你（私钥持有者）本人发布的吗？

当然，加密数据仅仅是一个签名，签名应该和数据一同发出，具体流程应该是：

1、Bob 生成公钥和私钥，然后把公钥公布出去，私钥自己保留。

2、 **用私钥加密数据作为签名，然后将数据附带着签名一同发布出去** 。

3、Alice 收到数据和签名，需要检查此份数据是否是 Bob 所发出，于是用 Bob 之前发出的公钥尝试解密签名，将收到的数据和签名解密后的结果作对比，如果完全相同，说明数据没被篡改，且确实由 Bob 发出。

为什么 Alice 这么肯定呢，毕竟数据和签名是两部分，都可以被掉包呀？原因如下：

1、如果有人修改了数据，那么 Alice 解密签名之后，对比发现二者不一致，察觉出异常。

2、如果有人替换了签名，那么 Alice 用 Bob 的公钥只能解出一串乱码，显然和数据不一致。

3、也许有人企图修改数据，然后将修改之后的数据制成签名，使得 Alice 的对比无法发现不一致；但是一旦解开签名，就不可能再重新生成 Bob 的签名了，因为没有 Bob 的私钥。

综上， **数字签名可以一定程度上认证数据的来源**
。之所以说是一定程度上，是因为这种方式依然可能受到中间人攻击。一旦涉及公钥的发布，接收方就可能收到中间人的假公钥，进行错误的认证，这个问题始终避免不了。

说来可笑，数字签名就是验证对方身份的一种方式，但是前提是对方的身份必须是真的… 这似乎陷入一个先有鸡还是先有蛋的死循环，
**要想确定对方的身份，必须有一个信任的源头，否则的话，再多的流程也只是在转移问题，而不是真正解决问题** 。

### 五、公钥证书

**证书其实就是公钥 + 签名，由第三方认证机构颁发** 。引入可信任的第三方，是终结信任循环的一种可行方案。

证书认证的流程大致如下：

1、Bob 去可信任的认证机构证实本人真实身份，并提供自己的公钥。

2、Alice 想跟 Bob 通信，首先向认证机构请求 Bob 的公钥，认证机构会把一张证书（Bob 的公钥以及自己对其公钥的签名）发送给 Alice。

3、Alice 检查签名，确定该公钥确实由这家认证机构发送，中途未被篡改。

4、Alice 通过这个公钥加密数据，开始和 Bob 通信。

![](https://labuladong.gitee.io/algo/images/%e5%af%86%e7%a0%81%e6%8a%80%e6%9c%af/7.jpg)

> PS：以上只是为了说明，证书只需要安装一次，并不需要每次都向认证机构请求；一般是服务器直接给客户端发送证书，而不是认证机构。

也许有人问，Alice 要想通过数字签名确定证书的有效性，前提是要有该机构的（认证）公钥，这不是又回到刚才的死循环了吗？

我们安装的正规浏览器中都预存了正规认证机构的证书（包含其公钥），用于确认机构身份，所以说证书的认证是可信的。

Bob 向机构提供公钥的过程中，需要提供很多个人信息进行身份验证，比较严格，所以说也算是可靠的。

获得了 Bob 的可信公钥，Alice 和 Bob 之间的通信基于加密算法的保护，是完全无懈可击的。

现在的正规网站，大都使用 HTTPS 协议，就是在 HTTP 协议和 TCP 协议之间加了一个 SSL/TLS 安全层。在你的浏览器和网站服务器完成 TCP 握手后，SSL 协议层也会进行 SSL
握手交换安全参数，其中就包含该网站的证书，以便浏览器验证站点身份。SSL 安全层验证完成之后，上层的 HTTP 协议内容都会被加密，保证数据的安全传输。

这样一来，传统的中间人攻击就几乎没有了生存空间，攻击手段只能由技术缺陷转变为坑蒙拐骗。事实上，这种手段的效果反而更高效，比如我就发现
**网上不少下载网站发布的浏览器，不仅包含乱七八糟的导航和收藏网址，还包含一些不正规的认证机构证书。任何人都可以申请证书，这些不正规证书很可能造成安全隐患**
。

### 六、最后总结

对称性加密算法使用同一个密钥加密和解密，难以破解，加密速度较快，但是存在密钥配送问题。

Diffie-Hellman 密钥交换算法可以让双方「心有灵犀一点通」，一定程度解决密钥配送问题，但是无法验证通信方的身份，所以可能受到中间人攻击。

非对称性加密算法生成一对儿密钥，把加密和解密的工作分开了。

RSA
算法作为经典的非对称加密算法，有两种用途：如果用于加密，可以把公钥发布出去用于加密，只有自己的私钥可以解密，保证了数据的机密性；如果用于数字签名，把公钥发布出去后，用私钥加密数据作为签名，以证明该数据由私钥持有者所发送。但是无论那种用法，涉及公钥的发布，都无法避免中间人攻击。

公钥证书就是公钥 + 签名，由可信任的第三方认证机构颁发。由于正规浏览器都预装了可信的认证机构的公钥，所以可以有效防止中间人攻击。

HTTPS 协议中的 SSL/TLS 安全层会组合使用以上几种加密方式， **所以说不要安装非正规的浏览器，不要乱安装未知来源的证书** 。

密码技术只是安全的一小部分，即便是通过正规机构认证的 HTTPS 站点，也不意味着可信任，只能说明其数据传输是安全的。技术永远不可能真正保护你，最重要的还是得提高个人的安全防范意识，多留心眼儿，谨慎处理敏感数据。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**





# 我用四个命令概括了 Git 的所有套路




** ~

**———–**

我先开一会儿吐槽大会，Git 这东西我用了两年，根本尼玛用不明白。

我搞不明白的一个重要原因就是，命令的功能太杂，有时候一个需求可以用好几种命令解决，而且有的命令还 tm
有别名。这导致什么问题呢，我在网上找到的答案五花八门，竟然都能达成目的，难以找到规律，毫无套路可言。对于我这种不喜欢动脑子，只喜欢玩套路的人来说，简直不能接受。

以前我用 Git，就知道 ` add . ` ，然后 ` commit -m ` ，最后 ` push origin master ` 一套带走，或者就是把 Git 作为下载器，去 ` clone `
别人的项目。但是在工作中呢，和别人一起开发代码，就需要处理一些复杂情况，比如解决冲突，比如手残恢复，等等等实用场景，这些我在后文都会列举。

对于工具的学习，我认为应该多做减法，只捡最有用的学，那些奇技淫巧不学也罢，应该把时间投入更有价值的事情中。

**所以本文不是一个大而全 Git 命令的使用手册，而是根据实际工作中最常见问题，提供小而美的解决方案，仅仅涉及四个命令：` add ` ， `
commit ` ， ` reset ` ， ` checkout ` ** 。

### 一、前言

首先，在进入 Git 的各种神仙操作之前， **一定要明白 git 的三个「分区」是什么，否则的话你一定没办法真正理解 Git 的原理** 。

Git 的三个分区分别是： ` working directory ` ， ` stage/index area ` ， ` commit history
` 。

![](https://labuladong.gitee.io/algo/images/git/trees.png)

**` working directory ` 是「工作目录」，也就是我们肉眼能够看到的文件 ** ，后文我们称其为 ` work dir ` 区。

当我们在 ` work dir ` 中 **执行` git add ` 相关命令后，就会把 ` work dir ` 中的修改添加到「暂存区」 `
stage area ` （或者叫 ` index area ` ）中去 ** ，后文我们称暂存区为 ` stage ` 区。

当 ` stage ` 中存在修改时，我们 **使用` git commit ` 相关命令之后，就会把 ` stage ` 中的修改保存到「提交历史」 `
commit history ` 中 ** ，也就是 ` HEAD ` 指针指向的位置。后文我们称「提交历史」为 ` history ` 区。

关于 ` commit history ` 我们多说几句，任何修改只要进入 ` commit history ` ，基本可以认为永远不会丢失了。每个 `
commit ` 都有一个唯一的 Hash 值，我们经常说的 ` HEAD ` 或者 ` master ` 分支，都可以理解为一个指向某个 ` commit
` 的指针。

` work dir ` 和 ` stage ` 区域的状态，可以通过命令 ` git status ` 来查看， ` history `
区域的提交历史可以通过 ` git log ` 命令来查看。

好的，如果上面的内容你都能够理解，那么本文就完全围绕这三个概念展开，下面就是一个「状态转移图」：

![](https://labuladong.gitee.io/algo/images/git/1.jpeg)

### 二、本地 Git 极简教程

**需求一，如何把` work dir ` 中的修改加入 ` stage ` ** 。

![](https://labuladong.gitee.io/algo/images/git/2.jpeg)

这个是最简单，使用 **` git add ` ** 相关的命令就行了。顺便一提， ` add ` 有个别名叫做 ` stage ` ，也就是说你可能见到
` git stage ` 相关的命令，这个命令和 ` git add ` 命令是完全一样的。

风险等级：无风险。

理由：不会改变任或撤销任何已作出的修改，而且还会将 ` work dir ` 中未追踪的修改（Untracked file）添加到暂存区 ` stage `
中进行追踪。

**需求二，如何把` stage ` 中的修改还原到 ` work dir ` 中 ** 。

![](https://labuladong.gitee.io/algo/images/git/3.jpeg)

这个需求很常见，也很重要，比如我先将当前 ` work dir ` 中的修改添加到 ` stage ` 中，然后又对 ` work dir `
中的文件进行了修改，但是又后悔了，如何把 ` work dir ` 中的全部或部分文件还原成 ` stage ` 中的样子呢？

来个实际场景，我先新建两个文件，然后把他们都加到 ` stage ` ：

```java
    $ touch a.txt b.txt
    $ git add .
    $ git status
    On branch master
    Changes to be committed:
    	new file:   a.txt
    	new file:   b.txt

```

然后我又修改了 ` a.txt ` 文件：

```java
    $ echo hello world >> a.txt
    $ git status
    On branch master
    Changes to be committed:
    	new file:   a.txt
    	new file:   b.txt
    
    Changes not staged for commit:
    	modified:   a.txt

```

现在，我后悔了，我认为不应该修改 ` a.txt ` ，我想把它还原成 ` stage ` 中的空文件，怎么办？

答案是，使用 **` checkout ` ** 命令：

```java
    $ git checkout a.txt
    Updated 1 path from the index
    
    $ git status
    On branch master
    Changes to be committed:
    	new file:   a.txt
    	new file:   b.txt

```

看到了么，输出显示从 ` index ` 区（也就是 ` stage ` 区）更新了一个文件，也就是把 ` work dir ` 中 ` a.txt `
文件还原成了 ` stage ` 中的状态（一个空文件）。

当然，如果 ` work dir ` 中被修改的文件很多，可以使用通配符全部恢复成 ` stage ` ：

```java
    $ git checkout .

```

有一点需要指出的是， ` checkout ` 命令只会把被「修改」的文件恢复成 ` stage ` 的状态，如果 ` work dir `
中新增了新文件，你使用 ` git checkout . ` 是不会删除新文件的。

风险等级：中风险。

理由：在 ` work dir ` 做出的「修改」会被 ` stage ` 覆盖，无法恢复。所以使用该命令你应该确定 ` work dir `
中的修改可以抛弃。

**需求三，将` stage ` 区的文件添加到 ` history ` 区 ** 。

![](https://labuladong.gitee.io/algo/images/git/4.jpeg)

很简单，就是 **` git commit ` ** 相关的命令，一般我们就是这样用的：

```java
    $ git commit -m '一些描述'

```

再简单提一些常见场景， 比如说 ` commit ` 完之后，突然发现一些错别字需要修改，又不想为改几个错别字而新开一个 ` commit ` 到 `
history ` 区，那么就可以使用下面这个命令：

```java
    $ git commit --amend

```

这样就是把错别字的修改和之前的那个 ` commit ` 中的修改合并，作为一个 ` commit ` 提交到 ` history ` 区。

风险等级：无风险。

理由：不会改变任或撤销任何已作出的修改，而且还会将 ` stage ` 区的修改加入 ` history ` 区并分配一个 Hash 值。只要不乱动本地的
` .git ` 文件夹，进入 ` history ` 的修改就永远不会丢失。

**需求四，将` history ` 区的文件还原到 ` stage ` 区 ** 。

![](https://labuladong.gitee.io/algo/images/git/5.jpeg)

这个需求很常见，比如说我用了一个 ` git add . ` 一股脑把所有修改加入 ` stage ` ，但是突然想起来文件 ` a.txt `
中的代码我还没写完，不应该把它 ` commit ` 到 ` history ` 区，所以我得把它从 ` stage ` 中撤销，等后面我写完了再提交。

```java
    $ echo aaa >> a.txt; echo bbb >> b.txt;
    $ git add .
    $ git status
    On branch master
    Changes to be committed:
    	modified:   a.txt
    	modified:   b.txt

```

如何把 ` a.txt ` 从 ` stage ` 区还原出来呢？可以使用 **` git reset ` ** 命令：

```java
    $ git reset a.txt
    
    $ git status
    On branch master
    Changes to be committed:
    	modified:   b.txt
    
    Changes not staged for commit:
    	modified:   a.txt

```

你看，这样就可以把 ` a.txt ` 文件从 ` stage ` 区移出，这时候进行 ` git commit ` 相关的操作就不会把这个文件一起提交到
` history ` 区了。

上面的这个命令是一个简写，实际上 ` reset ` 命令的完整写法如下：

```java
    $ git reset --mixed HEAD a.txt

```

其中， ` mixed ` 是一个模式（mode）参数，如果 ` reset ` 省略这个选项的话默认是 ` mixed ` 模式； ` HEAD `
指定了一个历史提交的 hash 值； ` a.txt ` 指定了一个或者多个文件。

**该命令的自然语言描述是：不改变` work dir ` 中的任何数据，将 ` stage ` 区域中的 ` a.txt ` 文件还原成 ` HEAD `
指向的 ` commit history ` 中的样子 ** 。就相当于把对 ` a.txt ` 的修改从 ` stage ` 区撤销，但依然保存在 `
work dir ` 中，变为 ` unstage ` 的状态。

风险等级：低风险。

理由：不会改变 ` work dir ` 中的数据，会改变 ` stage ` 区的数据，所以应确保 ` stage ` 中被改动数据是可以抛弃的。

**需求五，将` work dir ` 的修改提交到 ` history ` 区 ** 。

![](https://labuladong.gitee.io/algo/images/git/6.jpeg)

这个需求很简单啦，先 ` git add ` 然后 ` git commit ` 就行了，或者一个快捷方法是使用命令 ` git commit -a ` 。

风险等级：无风险。

理由：显而易见。

**需求六，将` history ` 区的历史提交还原到 ` work dir ` 中 ** 。

![](https://labuladong.gitee.io/algo/images/git/7.jpeg)

这个场景，我说一个极端一点的例子：比如我从 GitHub 上 ` clone `
了一个项目，然后乱改了一通代码，结果发现我写的代码根本跑不通，于是后悔了，干脆不改了，我想恢复成最初的模样，怎么办？

依然是使用 ` checkout ` 命令，但是和之前的使用方式有一些不同：

```java
    $ git checkout HEAD .
    Updated 12 paths from d480c4f

```

这样， ` work dir ` 和 ` stage ` 中所有的「修改」都会被撤销，恢复成 ` HEAD ` 指向的那个 ` history commit
` 。

注意，类似之前通过 ` stage ` 恢复 ` work dir ` 的 ` checkout ` 命令，这里撤销的也只是修改，新增的文件不会被撤销。

当然，只要找到任意一个 ` commit ` 的 HASH 值， ` checkout ` 命令可就以将文件恢复成任一个 ` history commit
` 中的样子：

```java
    $ git checkout 2bdf04a some_test.go
    Updated 1 path from 2bdf04a
    # 前文的用法显示 update from index

```

比如，我改了某个测试文件，结果发现测试跑不过了，所以就把该文件恢复到了它能跑过的那个历史版本……

风险等级：高风险。

理由：这个操作会将指定文件在 ` work dir ` 的数据恢复成指定 ` commit ` 的样子，且会删除该文件在 ` stage `
中的数据，都无法恢复，所以应该慎重使用。

### 三、其他技巧

**需求一，合并多个` commit ` ** 。

比如说我本地从 ` 17bd20c ` 到 ` HEAD ` 有多个 ` commit ` ，但我希望把他们合并成一个 ` commit `
推到远程仓库，这时候就可以使用 ` reset ` 命令：

```java
    $ git reset 17bd20c
    $ git add .
    $ git commit -m 'balabala'

```

回顾一下刚才说的 ` reset ` 命令的作用，相当于把 HEAD 移到了 ` 17bd20c ` 这个 ` commit ` ，而且不会修改 `
work dir ` 中的数据，所以只要 ` add ` 再 ` commit ` ，就相当于把中间的多个 ` commit ` 合并到一个了。

**需求二，由于` HEAD ` 指针的回退，导致有的 ` commit ` 在 ` git log ` 命令中无法看到，怎么得到它们的 Hash 值呢

** ？

再重复一遍，只要你不乱动本地的 ` .git ` 文件夹，任何修改只要提交到 ` commit history ` 中，都永远不会丢失，看不到某些 `
commit ` 只是因为它们不是我们当前 ` HEAD ` 位置的「历史」提交，我们可以使用如下命令查看操作记录：

```java
    $ git reflog

```

比如 ` reset ` ， ` checkout ` 等等关键操作都会在这里留下记录，所有 ` commit ` 的 Hash 值都能在这里找到，所以如果你发现有哪个 ` commit ` 突然找不到了，一定都可以在这里找到。

**需求三，怎么解决冲突** ？

记住，Git 虽然高大上，但也不要迷恋，一定要懂得借助先进的工具。

比较流行的代码编辑器或者 IDE 都会集成方便的可视化 Git 工具，至于解决冲突，可视化的表现方式不是比你在命令行里 ` git diff `
看半天要清晰明了得多？只需要点点点就行了。

所以说，只要明白本文讲的这些基本操作，够你用的了，平时能用图形化工具就多用图形化工具，毕竟工具都是为人服务的。

前文 [ Git/SQL/正则表达式的在线练习平台 ](https://labuladong.gitee.io/algo/5/41/) 介绍了一个优秀的 Git 在线练习平台，值得一刷。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**





# Git/SQL/正则表达式的在线练习平台




** ~

**———–**

虽说我没事就喜欢喷应试教育，但我也从应试教育中发现了一个窍门：如果能够以刷题的形式学习某项技能，效率和效果是最佳的。对于技术的学习，我经常面临的困境是，
**理论知识知道的不少，但是有的场景实在无法模拟，缺少亲自动手实践的机会** ，如果能有一本带标准答案的习题册让我刷刷就好了。

所以在学习新技术时，我首先会去搜索是否有在线刷题平台，你还别说，有的大神真就做了很不错的在线练习平台，下面就介绍几个平台，分别是学习 Git、SQL、正则表达式的在线练习平台。

### 一、练习 Git

这是个叫做 Learning Git Branching 的项目，是我一定要推荐的：

![](https://labuladong.gitee.io/algo/images/online/1.png)

正如对话框中的自我介绍，这确实也是我至今发现的 **最好** 的 Git 动画教程，没有之一。

想当年我用 Git 就会 ` add . ` ， ` clone ` ， ` push ` ， ` pull ` ， ` commit `
几个命令，其他的命令完全不会，Git 就是一个下载器，Github 就是个资源网站加免费图床，命令能不能达成目的都是靠运气。什么版本控制，我根本搞不懂，也懒得去看那一堆乱七八糟的文档。

这个网站的教程不是给你举那种修改文件的细节例子，而是将每次 ` commit ` 都抽象成树的节点， **用动画闯关的形式** ，让你自由使用 Git 命令完成目标：

![](https://labuladong.gitee.io/algo/images/online/2.png)

所有 Git 分支都被可视化了，你只要在左侧的命令行输入 Git 命令，分支会进行相应的变化，只要达成任务目标，你就过关啦！网站还会记录你的命令数，试试能不能以最少的命令数过关！

![](https://labuladong.gitee.io/algo/images/online/3.png)

我一开始以为这个教程只包含本地 Git 仓库的版本管理， **后来我惊奇地发现它还有远程仓库的操作教程** ！

![](https://labuladong.gitee.io/algo/images/online/4.png) ![](https://labuladong.gitee.io/algo/images/online/5.png)

真的跟玩游戏一样，难度设计合理，流畅度很好，我一玩都停不下来了，几小时就打通了，哈哈哈！

![](https://labuladong.gitee.io/algo/images/online/6.png)

总之，这个教程很适合初学和进阶，如果你觉得自己对 Git 的掌握还不太好，用 Git 命令还是靠碰运气，就可以玩玩这个教程，相信能够让你更熟练地使用 Git。

它是一个开源项目，Github 项目地址：

[ https://github.com/pcottle/learnGitBranching

](https://github.com/pcottle/learnGitBranching)

教程网站地址：

[ https://learngitbranching.js.org ](https://learngitbranching.js.org)

### 二、练习正则表达式

**正则表达式是个非常强有力的工具** ，可以说计算机中的一切数据都是字符，借助正则表达式这种模式匹配工具，操作计算机可以说是如虎添翼。

我这里要推荐两个网站，一个是练习平台，一个是测试正则表达式的平台。

先说练习平台，叫做 RegexOne：

![](https://labuladong.gitee.io/algo/images/online/9.png)

前面有基本教程，后面有一些常见的正则表达式题目，比如判断邮箱、URL、电话号，或者抽取日志的关键信息等等。

只要写出符合要求的正则表达式，就可以进入下一个问题，关键是每道题还有标准答案，可以点击下面的 solution 按钮查看：

![](https://labuladong.gitee.io/algo/images/online/10.png)

RegexOne 网址：

[ https://regexone.com/ ](https://regexone.com/)

再说测试工具，是个叫做 RegExr 的 Github 项目，这是它的网站：

![](https://labuladong.gitee.io/algo/images/online/11.png)

可以看见，输入文本和正则模式串后，
**网站会给正则表达式添加好看且容易辨认的样式，自动在文本中搜索模式串，高亮显示匹配的字符串，并且还会显示每个分组捕获的字符串** 。

这个网站可以配合前面的正则练习平台使用，在这里尝试各种表达式，成功匹配之后粘贴过去。

RegExr 网址：

[ https://regexr.com/ ](https://regexr.com/)

### 三、练习 SQL

这是一个叫做 SQLZOO 的网站，左侧是所有的练习内容：

![](https://labuladong.gitee.io/algo/images/online/7.png)

SQLZOO 是一款很好用的 SQL 练习平台，英文不难理解，可以直接看英文版，但是也可以切换繁体中文，比较友好。

这里都是比较常用的 SQL 命令，给你一个需求，你写 SQL 语句实现正确的查询结果。
**最重要的是，这里不仅对每个命令的用法有详细解释，每个专题后面还有选择题（quiz），而且有判题系统，甚至有的比较难的题目还有视频讲解** ：

![](https://labuladong.gitee.io/algo/images/online/8.png)

至于难度，循序渐进，即便对新手也很友好，靠后的问题确实比较有技巧性，相信这是热爱思维挑战的人喜欢的！LeetCode 也有 SQL 相关的题目，不过难度一般比较大，我觉得 SQLZOO 刷完基础 SQL 命令再去 LeetCode
刷比较合适。

网站地址：

[ https://sqlzoo.net/ ](