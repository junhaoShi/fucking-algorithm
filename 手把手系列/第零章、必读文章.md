# 第零章、必读文章

1、《算法秘籍》和《刷题笔记》两本 PDF 下载 [ 点这里](https://mp.weixin.qq.com/s/X-fE9sR4BLi6T9pn7xP4pg) 。

2、刷题插件下载及使用手册 [ 点这里 ](https://mp.weixin.qq.com/s/wIxflO1dvXzDlibhEcENcQ) 。

3、公众号菜单栏参与 [ 21 天算法挑战活动 ](https://mp.weixin.qq.com/s/eUG2OOzY3k_ZTz-CFvtv5Q) 。

# 学习算法和刷题的框架思维



这是好久之前的一篇文章 [ 学习数据结构和算法的框架思维

](https://mp.weixin.qq.com/s/gE-5KMi4bBvJovdsQXIKgw)
的修订版。之前那篇文章收到广泛好评，没看过也没关系，这篇文章会涵盖之前的所有内容，并且会举很多代码的实例，教你如何使用框架思维。

首先，这里讲的都是普通的数据结构，咱不是搞算法竞赛的，野路子出生，我只会解决常规的问题。另外，以下是我个人的经验的总结，没有哪本算法书会写这些东西，所以请读者试着理解我的角度，别纠结于细节问题，因为这篇文章就是希望对数据结构和算法建立一个框架性的认识。

从整体到细节，自顶向下，从抽象到具体的框架思维是通用的，不只是学习数据结构和算法，学习其他任何知识都是高效的。

## 一、数据结构的存储方式

**数据结构的存储方式只有两种：数组（顺序存储）和链表（链式存储）** 。

这句话怎么理解，不是还有散列表、栈、队列、堆、树、图等等各种数据结构吗？

我们分析问题，一定要有递归的思想，自顶向下，从抽象到具体。你上来就列出这么多，那些都属于「上层建筑」，而数组和链表才是「结构基础」。因为那些多样化的数据结构，究其源头，都是在链表或者数组上的特殊操作，API 不同而已。

比如说「队列」、「栈」这两种数据结构既可以使用链表也可以使用数组实现。用数组实现，就要处理扩容缩容的问题；用链表实现，没有这个问题，但需要更多的内存空间存储节点指针。

「图」的两种表示方法，邻接表就是链表，邻接矩阵就是二维数组。邻接矩阵判断连通性迅速，并可以进行矩阵运算解决一些问题，但是如果图比较稀疏的话很耗费空间。邻接表比较节省空间，但是很多操作的效率上肯定比不过邻接矩阵。

「散列表」就是通过散列函数把键映射到一个大数组里。而且对于解决散列冲突的方法，拉链法需要链表特性，操作简单，但需要额外的空间存储指针；线性探查法就需要数组特性，以便连续寻址，不需要指针的存储空间，但操作稍微复杂些。

「树」，用数组实现就是「堆」，因为「堆」是一个完全二叉树，用数组存储不需要节点指针，操作也比较简单；用链表实现就是很常见的那种「树」，因为不一定是完全二叉树，所以不适合用数组存储。为此，在这种链表「树」结构之上，又衍生出各种巧妙的设计，比如二叉搜索树、AVL
树、红黑树、区间树、B 树等等，以应对不同的问题。

了解 Redis 数据库的朋友可能也知道，Redis 提供列表、字符串、集合等等几种常用数据结构，但是对于每种数据结构，底层的存储方式都至少有两种，以便于根据存储数据的实际情况使用合适的存储方式。

综上，数据结构种类很多，甚至你也可以发明自己的数据结构，但是底层存储无非数组或者链表， **二者的优缺点如下** ：

**数组**
由于是紧凑连续存储,可以随机访问，通过索引快速找到对应元素，而且相对节约存储空间。但正因为连续存储，内存空间必须一次性分配够，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)
；而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)。

**链表**
因为元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组的扩容问题；如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度 O(1)
。但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问；而且由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。

## 二、数据结构的基本操作

对于任何数据结构，其基本操作无非遍历 + 访问，再具体一点就是：增删查改。

**数据结构种类很多，但它们存在的目的都是在不同的应用场景，尽可能高效地增删查改** 。话说这不就是数据结构的使命么？

如何遍历 + 访问？我们仍然从最高层来看，各种数据结构的遍历 + 访问无非两种形式：线性的和非线性的。

线性就是 for/while 迭代为代表，非线性就是递归为代表。再具体一步，无非以下几种框架：

数组遍历框架，典型的线性迭代结构：

```java
    void traverse(int[] arr) {
        for (int i = 0; i < arr.length; i++) {
            // 迭代访问 arr[i]
        }
    }

```

链表遍历框架，兼具迭代和递归结构：

```java
    /* 基本的单链表节点 */
    class ListNode {
        int val;
        ListNode next;
    }
    
    void traverse(ListNode head) {
        for (ListNode p = head; p != null; p = p.next) {
            // 迭代访问 p.val
        }
    }
    
    void traverse(ListNode head) {
        // 递归访问 head.val
        traverse(head.next);
    }

```

二叉树遍历框架，典型的非线性递归遍历结构：

```java
    /* 基本的二叉树节点 */
    class TreeNode {
        int val;
        TreeNode left, right;
    }
    
    void traverse(TreeNode root) {
        traverse(root.left);
        traverse(root.right);
    }

```

你看二叉树的递归遍历方式和链表的递归遍历方式，相似不？再看看二叉树结构和单链表结构，相似不？如果再多几条叉，N 叉树你会不会遍历？

二叉树框架可以扩展为 N 叉树的遍历框架：

```java
    /* 基本的 N 叉树节点 */
    class TreeNode {
        int val;
        TreeNode[] children;
    }
    
    void traverse(TreeNode root) {
        for (TreeNode child : root.children)
            traverse(child);
    }

```

` N ` 叉树的遍历又可以扩展为图的遍历，因为图就是好几 ` N ` 叉棵树的结合体。你说图是可能出现环的？这个很好办，用个布尔数组 ` visited
` 做标记就行了，这里就不写代码了。

**所谓框架，就是套路。不管增删查改，这些代码都是永远无法脱离的结构，你可以把这个结构作为大纲，根据具体问题在框架上添加代码就行了，下面会具体举例** 。

## 三、算法刷题指南

首先要明确的是， **数据结构是工具，算法是通过合适的工具解决特定问题的方法**
。也就是说，学习算法之前，最起码得了解那些常用的数据结构，了解它们的特性和缺陷。

那么该如何在 LeetCode 刷题呢？之前的文章写过一些，什么按标签刷，坚持下去云云。现在距那篇文章已经过去将近一年了，我不说那些不痛不痒的话，直接说具体的建议：

**先刷二叉树，先刷二叉树，先刷二叉树** ！

这是我这刷题一年的亲身体会，下图是去年十月份的提交截图：

![](https://labuladong.gitee.io/algo/images/others/leetcode.jpeg)

公众号文章的阅读数据显示，大部分人对数据结构相关的算法文章不感兴趣，而是更关心动规回溯分治等等技巧。为什么要先刷二叉树呢，
**因为二叉树是最容易培养框架思维的，而且大部分算法技巧，本质上都是树的遍历问题** 。

刷二叉树看到题目没思路？根据很多读者的问题，其实大家不是没思路，只是没有理解我们说的「框架」是什么。

**不要小看这几行破代码，几乎所有二叉树的题目都是一套这个框架就出来了** ：

```java
    void traverse(TreeNode root) {
        // 前序遍历代码位置
        traverse(root.left);
        // 中序遍历代码位置
        traverse(root.right);
        // 后序遍历代码位置
    }

```

比如说我随便拿几道题的解法出来，不用管具体的代码逻辑，只要看看框架在其中是如何发挥作用的就行。

LeetCode 124 题，难度 Hard，让你求二叉树中最大路径和，主要代码如下：

```java
    int ans = INT_MIN;
    int oneSideMax(TreeNode* root) {
        if (root == nullptr) return 0;
        int left = max(0, oneSideMax(root->left));
        int right = max(0, oneSideMax(root->right));
        // 后序遍历代码位置
        ans = max(ans, left + right + root->val);
        return max(left, right) + root->val;
    }

```

注意递归函数的位置，这就是个后序遍历嘛，无非就是把 ` traverse ` 函数名字改成 ` oneSideMax ` 了。

LeetCode 105 题，难度 Medium，让你根据前序遍历和中序遍历的结果还原一棵二叉树，很经典的问题吧，主要代码如下：

```java
    TreeNode buildTree(int[] preorder, int preStart, int preEnd, 
        int[] inorder, int inStart, int inEnd, Map<Integer, Integer> inMap) {
    
        if(preStart > preEnd || inStart > inEnd) return null;
    
        TreeNode root = new TreeNode(preorder[preStart]);
        int inRoot = inMap.get(root.val);
        int numsLeft = inRoot - inStart;
    
        root.left = buildTree(preorder, preStart + 1, preStart + numsLeft, 
                              inorder, inStart, inRoot - 1, inMap);
        root.right = buildTree(preorder, preStart + numsLeft + 1, preEnd, 
                              inorder, inRoot + 1, inEnd, inMap);
        return root;
    }

```

不要看这个函数的参数很多，只是为了控制数组索引而已。注意找递归函数的位置，本质上该算法也就是一个前序遍历，因为它在前序遍历的位置加了一坨代码。

LeetCode 99 题，难度 Hard，恢复一棵 BST，主要代码如下：

```java
    void traverse(TreeNode node) {
        if (node == null) return;
        traverse(node.left);
        if (node.val < prev.val) {
            s = (s == null) ? prev : s;
            t = node;
        }
        prev = node;
        traverse(node.right);
    }

```

这不就是个中序遍历嘛，对于一棵 BST 中序遍历意味着什么，应该不需要解释了吧。

你看，Hard 难度的题目不过如此，而且还这么有规律可循，只要把框架写出来，然后往相应的位置加东西就行了，这不就是思路吗。

对于一个理解二叉树的人来说，刷一道二叉树的题目花不了多长时间。那么如果你对刷题无从下手或者有畏惧心理，不妨从二叉树下手，前 10 道也许有点难受；结合框架再做 20 道，也许你就有点自己的理解了；刷完整个专题，再去做什么回溯动规分治专题，
**你就会发现只要涉及递归的问题，都是树的问题** 。

PS： [ 刷题插件 ](https://mp.weixin.qq.com/s/OE1zPVPj0V2o82N4HtLQbw)
集成了手把手刷二叉树功能，按照公式和套路讲解了 150 道二叉树题目，可手把手带你刷完二叉树分类的题目，迅速掌握递归思维。

再举例吧，说几道我们之前文章写过的问题。

[ 动态规划详解 ](https://labuladong.gitee.io/algo/3/22/66/) 说过凑零钱问题，暴力解法就是遍历一棵 N 叉树：

![](https://labuladong.gitee.io/algo/images/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%e8%af%a6%e8%a7%a3%e8%bf%9b%e9%98%b6/5.jpg)

```java
    int dp(int[] coins, int amount) {
        // base case
        if (amount == 0) return 0;
        if (amount < 0) return -1;
    
        int res = Integer.MAX_VALUE;
        for (int coin : coins) {
            int subProblem = dp(coins, amount - coin);
            // 子问题无解则跳过
            if (subProblem == -1) continue;
            // 在子问题中选择最优解，然后加一
            res = Math.min(res, subProblem + 1);
        }
        return res == Integer.MAX_VALUE ? -1 : res;
    }

```

这么多代码看不懂咋办？直接提取出框架，就能看出核心思路了：

```java
    # 不过是一个 N 叉树的遍历问题而已
    int dp(int amount) {
        for (int coin : coins) {
            dp(amount - coin);
        }
    }

```

其实很多动态规划问题就是在遍历一棵树，你如果对树的遍历操作烂熟于心，起码知道怎么把思路转化成代码，也知道如何提取别人解法的核心思路。

再看看回溯算法，前文 [ 回溯算法详解 ](https://labuladong.gitee.io/algo/4/28/105/) 干脆直接说了，回溯算法就是个 N 叉树的前后序遍历问题，没有例外。

比如全排列问题吧，本质上全排列就是在遍历下面这棵树，到叶子节点的路径就是一个全排列：

![](https://labuladong.gitee.io/algo/images/backtracking/1.jpg)

全排列算法的主要代码如下：

```java
    void backtrack(int[] nums, LinkedList<Integer> track) {
        if (track.size() == nums.length) {
            res.add(new LinkedList(track));
            return;
        }
        
        for (int i = 0; i < nums.length; i++) {
            if (track.contains(nums[i]))
                continue;
            track.add(nums[i]);
            // 进入下一层决策树
            backtrack(nums, track);
            track.removeLast();
        }
    
    /* 提取出 N 叉树遍历框架 */
    void backtrack(int[] nums, LinkedList<Integer> track) {
        for (int i = 0; i < nums.length; i++) {
            backtrack(nums, track);
    }

```

N 叉树的遍历框架，找出来了吧？你说，树这种结构重不重要？

**综上，对于畏惧算法的同学来说，可以先刷树的相关题目，试着从框架上看问题，而不要纠结于细节问题** 。

纠结细节问题，就比如纠结 ` i ` 到底应该加到 ` n ` 还是加到 ` n - 1 ` ，这个数组的大小到底应该开 ` n ` 还是 ` n + 1
` ？

从框架上看问题，就是像我们这样基于框架进行抽取和扩展，既可以在看别人解法时快速理解核心逻辑，也有助于找到我们自己写解法时的思路方向。

当然，如果细节出错，你得不到正确的答案，但是只要有框架，你再错也错不到哪去，因为你的方向是对的。

但是，你要是心中没有框架，那么你根本无法解题，给了你答案，你也不会发现这就是个树的遍历问题。

这种思维是很重要的， [ 动态规划详解 ](https://labuladong.gitee.io/algo/3/22/66/)
中总结的找状态转移方程的几步流程，有时候按照流程写出解法，说实话我自己都不知道为啥是对的，反正它就是对了。。。

**这就是框架的力量，能够保证你在快睡着的时候，依然能写出正确的程序；就算你啥都不会，都能比别人高一个级别** 。

## 四、总结几句

数据结构的基本存储方式就是链式和顺序两种，基本操作就是增删查改，遍历方式无非迭代和递归。

**刷算法题建议从「树」分类开始刷**
，结合框架思维，把这几十道题刷完，对于树结构的理解应该就到位了。这时候去看回溯、动规、分治等算法专题，对思路的理解可能会更加深刻一些。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**





# 我的刷题心得


两年前刚开这个公众号的时候，我写了一篇 [ 学习数据结构和算法的框架思维 ](https://labuladong.gitee.io/algo/1/2/) ，现在已经 5w 多阅读了，这对于一篇纯技术文来说是很牛逼的数据。

这两年在我自己不断刷题，思考和写公众号的过程中，我对算法的理解也是在逐渐加深，所以今天再写一篇，把我这两年的经验和思考浓缩成 4000 字，分享给大家。

本文主要有两部分，一是谈我对算法本质的理解，二是概括各种常用的算法。全文没有什么硬核的代码，都是我的经验之谈，也许没有多么高大上，但肯定能帮你少走弯路，更透彻地理解和掌握算法。

另外，本文包含大量历史文章链接，结合本文阅读历史文章也许可以更快培养出学习算法的框架思维和知识体系。

## 算法的本质

**如果要让我一句话总结，我想说算法的本质就是「穷举」** 。

这么说肯定有人要反驳了，真的所有算法问题的本质都是穷举吗？没有一个例外吗？

例外肯定是有的，比如前几天我还发了 [ 一行代码就能解决的算法题 ](https://labuladong.gitee.io/algo/4/29/121/) ，这些题目都是通过观察，发现规律，然后找到最优解法。

再比如数学相关的算法，很多都是数学推论，然后用编程的形式表现出来了，所以它本质是数学，不是计算机算法。

从计算机算法的角度，结合我们大多数人的需求，这种秀智商的纯技巧题目绝对占少数，虽然很容易让人大呼精妙，但不能提炼出思考算法题的通用思维，真正通用的思维反而大道至简，就是穷举。

我记得自己一开始学习算法的时候，也觉得算法是一个很高大上的东西，每见到一道题，就想着能不能推导出一个什么数学公式，啪的一下就能把答案算出来。

比如你和一个没学过（计算机）算法的人说你写了个计算排列组合的算法，他大概以为你发明了一个公式，可以直接算出所有排列组合。但实际上呢？没什么高大上的公式，前文
[ 回溯算法秒杀排列组合子集问题 ](https://labuladong.gitee.io/algo/4/28/107/) 写了，还是得用回溯算法暴力穷举。

对计算机算法的误解也许是以前学数学留下的「后遗症」，数学题一般都是你仔细观察，找几何关系，列方程，然后算出答案。如果说你需要进行大规模穷举来寻找答案，那大概率是你的解题思路出问题了。

而计算机解决问题的思维恰恰相反，有没有什么数学公式就交给你们人类去推导吧，但如果推导不出来，那就穷举呗，反正只要复杂度允许，没有什么答案是穷举不出来的。

技术岗笔试面试考的那些算法题，求个最大值最小值什么的，你怎么求？必须得把所有可行解穷举出来才能找到最值对吧，说白了不就这么点事儿么。

**「穷举」具体来说可以分为两点，看到一道算法题，可以从这两个维度去思考** ：

**1、如何穷举** ？

**2、如何聪明地穷举** ？

不同类型的题目，难点是不同的，有的题目难在「如何穷举」，有的题目难在「如何聪明地穷举」。

**什么算法的难点在「如何穷举」呢？一般是递归类问题，最典型的就是动态规划系列问题** 。

前文 [ 动态规划核心套路 ](https://labuladong.gitee.io/algo/3/22/66/)
阐述了动态规划系列问题的核心原理，无非就是先写出暴力穷举解法（状态转移方程），加个备忘录就成自顶向下的动态规划解法了，再改一改就成自底向上的迭代解法了， [
动态规划的降维打击 ](https://labuladong.gitee.io/algo/3/22/70/) 里也讲过如何分析优化动态规划算法的空间复杂度。

上述过程就是在不断优化算法的时间、空间复杂度，也就是所谓「如何聪明地穷举」，这些技巧一听就会了。但很多读者留言说明白了这些原理，遇到动态规划题目还是不会做，因为第一步的暴力解法都写不出来。

这很正常，因为动态规划类型的题目可以千奇百怪，找状态转移方程才是难点，所以才有了 [ 动态规划设计方法：最长递增子序列 ](https://labuladong.gitee.io/algo/3/23/74/)
这篇文章，告诉你递归穷举的核心是数学归纳法，明确函数的定义，然后利用这个定义写递归函数，就可以穷举出所有可行解。

**什么算法的难点在「如何聪明地穷举」呢？一些耳熟能详的非递归算法技巧，都可以归在这一类** 。

比如前文 [ Union Find 并查集算法详解 ](https://labuladong.gitee.io/algo/2/18/37/)
告诉你一种高效计算连通分量的技巧，理论上说，想判断两个节点是否连通，我用 DFS/BFS 暴力搜索（穷举）肯定可以做到，但人家 Union Find 算法硬是用数组模拟树结构，给你把连通性相关的操作复杂度给干到 ` O(1) ` 了。

这就属于聪明地穷举，你学过就会用，没学过恐怕很难想出这种思路。

再比如贪心算法技巧，前文 [ 当老司机学会贪心算法 ](https://labuladong.gitee.io/algo/3/26/103/)
就告诉你，所谓贪心算法就是在题目中发现一些规律（专业点叫贪心选择性质），使得你不用完整穷举所有解就可以得出答案。

人家动态规划好歹是无冗余地穷举所有解，然后找一个最值，你贪心算法可好，都不用穷举所有解就可以找到答案，所以前文 [ 贪心算法解决跳跃游戏

](https://labuladong.gitee.io/algo/3/26/102/) 中贪心算法的效率比动态规划还高。

再比如大名鼎鼎的 KMP 算法，你写个字符串暴力匹配算法很容易，但你发明个 KMP 算法试试？KMP 算法的本质是聪明地缓存并复用一些信息，减少了冗余计算，前文 [ KMP 字符匹配算法 ](https://labuladong.gitee.io/algo/3/25/96/)
就是使用状态机的思路实现的 KMP 算法。

下面我概括性地列举一些常见的算法技巧，供大家学习参考。

## 数组/单链表系列算法

**单链表常考的技巧就是双指针** ，前文 [ 单链表六大技巧 ](https://labuladong.gitee.io/algo/2/16/15/) 全给你总结好了，这些技巧就是会者不难，难者不会。

比如判断单链表是否成环，拍脑袋的暴力解是什么？就是用一个 ` HashSet `
之类的数据结构来缓存走过的节点，遇到重复的就说明有环对吧。但我们用快慢指针可以避免使用额外的空间，这就是聪明地穷举嘛。

当然，对于找链表中点这种问题，使用双指针技巧只是显示你学过这个技巧，和遍历两次链表的常规解法从时间空间复杂度的角度来说都是差不多的。

**数组常用的技巧有很大一部分还是双指针相关的技巧，说白了是教你如何聪明地进行穷举** 。

**首先说二分搜索技巧** ，可以归为两端向中心的双指针。如果让你在数组中搜索元素，一个 for 循环穷举肯定能搞定对吧，但如果数组是有序的，二分搜索不就是一种更聪明的搜索方式么。

前文 [ 二分搜索框架详解 ](https://labuladong.gitee.io/algo/2/20/57/) 给你总结了二分搜索代码模板，保证不会出现搜索边界的问题。前文 [ 二分搜索算法运用

](https://labuladong.gitee.io/algo/2/20/58/) 给你总结了二分搜索相关题目的共性以及如何将二分搜索思想运用到实际算法中。

类似的两端向中心的双指针技巧还有力扣上的 N 数之和系列问题，前文 [ 一个函数秒杀所有 nSum 问题 ](https://labuladong.gitee.io/algo/1/13/)
讲了这些题目的共性，甭管几数之和，解法肯定要穷举所有的数字组合，然后看看那个数字组合的和等于目标和嘛。比较聪明的方式是先排序，利用双指针技巧快速计算结果。

**再说说[ 滑动窗口算法技巧 ](https://labuladong.gitee.io/algo/2/20/56/) ** ，典型的快慢双指针，快慢指针中间就是滑动的「窗口」，主要用于解决子串问题。

文中最小覆盖子串这道题，让你寻找包含特定字符的最短子串，常规拍脑袋解法是什么？那肯定是类似字符串暴力匹配算法，用嵌套 for 循环穷举呗，平方级的复杂度。

而滑动窗口技巧告诉你不用这么麻烦，可以用快慢指针遍历一次就求出答案，这就是教你聪明的穷举技巧。

但是，就好像二分搜索只能运用在有序数组上一样，滑动窗口也是有其限制的，就是你必须明确的知道什么时候应该扩大窗口，什么时候该收缩窗口。

比如前文 [ 最大子数组问题 ](https://labuladong.gitee.io/algo/3/23/76/)
面对的问题就没办法用滑动窗口，因为数组中的元素存在负数，扩大或缩小窗口并不能保证窗口中的元素之和就会随着增大和减小，所以无法使用滑动窗口技巧，只能用动态规划技巧穷举了。

**还有回文串相关技巧** ，如果判断一个串是否是回文串，使用双指针从两端向中心检查，如果寻找回文子串，就从中心向两端扩散。前文 [ 最长回文子串

](https://labuladong.gitee.io/algo/4/31/134/) 使用了一种技巧同时处理了回文串长度为奇数或偶数的情况。

当然，寻找最长回文子串可以有更精妙的马拉车算法（Manacher 算法），不过，学习这个算法的性价比不高，没什么必要掌握。

**最后说说[ 前缀和技巧 ](https://labuladong.gitee.io/algo/2/20/53/) 和 [ 差分数组技巧 ](https://labuladong.gitee.io/algo/2/20/54/) ** 。

如果频繁地让你计算子数组的和，每次用 for 循环去遍历肯定没问题，但前缀和技巧预计算一个 ` preSum ` 数组，就可以避免循环。

类似的，如果频繁地让你对子数组进行增减操作，也可以每次用 for 循环去操作，但差分数组技巧维护一个 ` diff ` 数组，也可以避免循环。

数组链表的技巧差不多就这些了，都比较固定，只要你都见过，运用出来的难度不算大，下面来说一说稍微有些难度的算法。

## 二叉树系列算法

老读者都知道，二叉树的重要性我之前说了无数次，因为二叉树模型几乎是所有高级算法的基础，尤其是那么多人说对递归的理解不到位，更应该好好刷二叉树相关题目。

PS： [ 刷题插件 ](https://mp.weixin.qq.com/s/OE1zPVPj0V2o82N4HtLQbw)
集成了手把手刷二叉树功能，按照公式和套路讲解了 150 道二叉树题目，可手把手带你刷完二叉树分类的题目，迅速掌握递归思维。

**我之前说过，二叉树题目的递归解法可以分两类思路，第一类是遍历一遍二叉树得出答案，第二类是通过分解问题计算出答案，这两类思路分别对应着[ 回溯算法核心框架

](https://labuladong.gitee.io/algo/4/28/105/) 和 [ 动态规划核心框架 ](https://labuladong.gitee.io/algo/3/22/66/) ** 。

**什么叫通过遍历一遍二叉树得出答案** ？

就比如说计算二叉树最大深度这个问题让你实现 ` maxDepth ` 这个函数，你这样写代码完全没问题：

```java
    // 记录最大深度
    int res = 0;
    int depth = 0;
    
    // 主函数
    int maxDepth(TreeNode root) {
    	traverse(root);
    	return res;
    }
    
    // 二叉树遍历框架
    void traverse(TreeNode root) {
    	if (root == null) {
    		// 到达叶子节点
    		res = Math.max(res, depth);
    		return;
    	}
    	// 前序遍历位置
    	depth++;
    	traverse(root.left);
    	traverse(root.right);
    	// 后序遍历位置
    	depth--;
    }

```

这个逻辑就是用 ` traverse ` 函数遍历了一遍二叉树的所有节点，维护 ` depth ` 变量，在叶子节点的时候更新最大深度。

你看这段代码，有没有觉得很熟悉？能不能和回溯算法的代码模板对应上？

不信你照着 [ 回溯算法核心框架 ](https://labuladong.gitee.io/algo/4/28/105/) 中全排列问题的代码对比下：

```java
    // 记录所有全排列
    List<List<Integer>> res = new LinkedList<>();
    LinkedList<Integer> track = new LinkedList<>();
    
    /* 主函数，输入一组不重复的数字，返回它们的全排列 */
    List<List<Integer>> permute(int[] nums) {
        backtrack(nums);
        return res;
    }
    
    // 回溯算法框架
    void backtrack(int[] nums) {
        if (track.size() == nums.length) {
    		// 穷举完一个全排列
            res.add(new LinkedList(track));
            return;
        }
        
        for (int i = 0; i < nums.length; i++) {
            if (track.contains(nums[i]))
                continue;
    		// 前序遍历位置做选择
            track.add(nums[i]);
            backtrack(nums);
            // 后序遍历位置取消选择
            track.removeLast();
        }
    }

```

前文讲回溯算法的时候就告诉你回溯算法本质就是遍历一棵多叉树，连代码实现都如出一辙有没有？

而且我之前经常说，回溯算法虽然简单粗暴效率低，但特别有用，因为如果你对一道题无计可施，回溯算法起码能帮你写一个暴力解捞点分对吧。

**那什么叫通过分解问题计算答案** ？

同样是计算二叉树最大深度这个问题，你也可以写出下面这样的解法：

```java
    // 定义：输入根节点，返回这棵二叉树的最大深度
    int maxDepth(TreeNode root) {
    	if (root == null) {
    		return 0;
    	}
    	// 递归计算左右子树的最大深度
    	int leftMax = maxDepth(root.left);
    	int rightMax = maxDepth(root.right);
    	// 整棵树的最大深度
    	int res = Math.max(leftMax, rightMax) + 1;
    
    	return res;
    }

```

你看这段代码，有没有觉得很熟悉？有没有觉得有点动态规划解法代码的形式？

不信你看 [ 动态规划核心框架 ](https://labuladong.gitee.io/algo/3/22/66/) 中凑零钱问题的暴力穷举解法：

```java
    // 定义：输入金额 amount，返回凑出 amount 的最少硬币个数
    int coinChange(int[] coins, int amount) {
        // base case
        if (amount == 0) return 0;
        if (amount < 0) return -1;
    
        int res = Integer.MAX_VALUE;
        for (int coin : coins) {
            // 递归计算凑出 amount - coin 的最少硬币个数
            int subProblem = coinChange(coins, amount - coin);
            if (subProblem == -1) continue;
            // 凑出 amount 的最少硬币个数
            res = Math.min(res, subProblem + 1);
        }
    
        return res == Integer.MAX_VALUE ? -1 : res;
    }

```

这个暴力解法加个 ` memo ` 备忘录就是自顶向下的动态规划解法，你对照二叉树最大深度的解法代码，有没有发现很像？

**如果你感受到最大深度这个问题两种解法的区别，那就趁热打铁，我问你，二叉树的前序遍历怎么写** ？

我相信大家都会对这个问题嗤之以鼻，毫不犹豫就可以写出下面这段代码：

```java
    List<Integer> res = new LinkedList<>();
    
    // 返回前序遍历结果
    List<Integer> preorder(TreeNode root) {
        traverse(root);
        return res;
    }
    
    // 二叉树遍历函数
    void traverse(TreeNode root) {
        if (root == null) {
            return;
        }
        // 前序遍历位置
        res.add(root.val);
        traverse(root.left);
        traverse(root.right);
    }

```

但是，你结合上面说到的两种不同的思维模式，二叉树的遍历是否也可以通过分解问题的思路解决呢？

我们前文 [ 手把手刷二叉树（第二期） ](https://labuladong.gitee.io/algo/2/17/22/) 说过前中后序遍历结果的特点：

![](https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e7%b3%bb%e5%88%972/1.jpeg)

**你注意前序遍历的结果，根节点的值在第一位，后面接着左子树的前序遍历结果，最后接着右子树的前序遍历结果** 。

有没有体会出点什么来？其实完全可以重写前序遍历代码，用分解问题的形式写出来，避免外部变量和辅助函数：

```java
    // 定义：输入一棵二叉树的根节点，返回这棵树的前序遍历结果
    List<Integer> preorder(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        if (root == null) {
            return res;
        }
        // 前序遍历的结果，root.val 在第一个
        res.add(root.val);
        // 后面接着左子树的前序遍历结果
        res.addAll(preorder(root.left));
        // 最后接着右子树的前序遍历结果
        res.addAll(preorder(root.right));
    }

```

你看，这就是用分解问题的思维模式写二叉树的前序遍历，如果写中序和后序遍历也是类似的。

当然，动态规划系列问题有「最优子结构」和「重叠子问题」两个特性，而且大多是让你求最值的。很多算法虽然不属于动态规划，但也符合分解问题的思维模式。

比如 [ 分治算法详解 ](https://labuladong.gitee.io/algo/4/30/125/)
中说到的运算表达式优先级问题，其核心依然是大问题分解成子问题，只不过没有重叠子问题，不能用备忘录去优化效率罢了。

当然，除了动归、回溯（DFS）、分治，还有一个常用算法就是 BFS 了，前文 [ BFS 算法核心框架 ](https://labuladong.gitee.io/algo/4/28/110/)
就是根据下面这段二叉树的层序遍历代码改装出来的：

```java
    // 输入一棵二叉树的根节点，层序遍历这棵二叉树
    void levelTraverse(TreeNode root) {
        if (root == null) return 0;
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);
    
        int depth = 1;
        // 从上到下遍历二叉树的每一层
        while (!q.isEmpty()) {
            int sz = q.size();
            // 从左到右遍历每一层的每个节点
            for (int i = 0; i < sz; i++) {
                TreeNode cur = q.poll();
    
                if (cur.left != null) {
                    q.offer(cur.left);
                }
                if (cur.right != null) {
                    q.offer(cur.right);
                }
            }
            depth++;
        }
    }

```

**更进一步，图论相关的算法也是二叉树算法的延续** 。

比如 [ 图论基础 ](https://labuladong.gitee.io/algo/2/18/34/) 和 [ 环判断和拓扑排序 ](https://labuladong.gitee.io/algo/2/18/35/) 就用到了 DFS 算法；再比如 [
Dijkstra 算法模板 ](https://labuladong.gitee.io/algo/2/18/41/) ，就是改造版 BFS 算法加上一个类似 dp table 的数组。

好了，说的差不多了，上述这些算法的本质都是穷举二（多）叉树，有机会的话通过剪枝或者备忘录的方式减少冗余计算，提高效率，就这么点事儿。

## 最后总结

上周在视频号直播的时候，有读者问我什么刷题方式是正确的，我说正确的刷题方式应该是刷一道题能获得刷十道题的效果，不然力扣现在 2000 道题目，你都打算刷完么？

那么怎么做到呢？ [ 学习数据结构和算法的框架思维 ](https://labuladong.gitee.io/algo/1/2/)
说了，要有框架思维，学会提炼重点，一个算法技巧可以包装出一百道题，如果你能一眼看穿它的本质，那就没必要浪费时间刷了嘛。

同时，在做题的时候要思考，联想，进而培养举一反三的能力。

前文 [ Dijkstra 算法模板 ](https://labuladong.gitee.io/algo/2/18/41/)
并不是真的是让你去背代码模板，不然的话直接甩出来那一段代码不就行了，我从层序遍历讲到 BFS 讲到 Dijkstra，说这么多废话干什么？

说到底我还是希望爱思考的读者能培养出成体系的算法思维，最好能爱上算法，而不是单纯地看题解去做题，授人以鱼不如授人以渔嘛。

本文就到这里吧， **算法真的没啥难的，只要有心，谁都可以学好** 。分享是一种美德，如果本文对你有启发，欢迎分享给需要的朋友。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**





# 动态规划解题套路框架




** ~

读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 509. 斐波那契数（简单） ](https://leetcode-cn.com/problems/fibonacci-number)

[ 322. 零钱兑换（中等） ](https://leetcode-cn.com/problems/coin-change)

**———–**

本文有视频版： [ 动态规划框架套路详解 ](https://www.bilibili.com/video/BV1XV411Y7oE)

这篇文章是我们公众号半年前一篇 200 多赞赏的成名之作 [ 动态规划详解

](https://mp.weixin.qq.com/s/1V3aHVonWBEXlNUvK3S28w)
的进阶版。由于账号迁移的原因，旧文无法被搜索到，所以我润色了本文，并添加了更多干货内容，希望本文成为解决动态规划的一部「指导方针」。

动态规划问题（Dynamic Programming）应该是很多读者头疼的，不过这类问题也是最具有技巧性，最有意思的。本书使用了整整一个章节专门来写这个算法，动态规划的重要性也可见一斑。

本文解决几个问题：

动态规划是什么？解决动态规划问题有什么技巧？如何学习动态规划？

刷题刷多了就会发现，算法技巧就那几个套路， **我们后续的动态规划系列章节，都在使用本文的解题框架思维**
，如果你心里有数，就会轻松很多。所以本文放在第一章，来扒一扒动态规划的裤子，形成一套解决这类问题的思维框架，希望能够成为解决动态规划问题的一部指导方针。本文就来讲解该算法的基本套路框架，下面上干货。

**首先，动态规划问题的一般形式就是求最值** 。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求 **最长**
递增子序列呀， **最小** 编辑距离呀等等。

既然是要求最值，核心问题是什么呢？ **求解动态规划的核心问题是穷举** 。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值呗。

动态规划这么简单，就是穷举就完事了？我看到的动态规划问题都很难啊！

首先，动态规划的穷举有点特别，因为这类问题 **存在「重叠子问题」** ，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。

而且，动态规划问题一定会 **具备「最优子结构」** ，才能通过子问题的最值得到原问题的最值。

另外，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出 **正确的「状态转移方程」**
，才能正确地穷举。

以上提到的重叠子问题、最优子结构、状态转移方程就是动态规划三要素。具体什么意思等会会举例详解，但是在实际的算法问题中， **写出状态转移方程是最困难的**
，这也就是为什么很多朋友觉得动态规划问题困难的原因，我来提供我研究出来的一个思维框架，辅助你思考状态转移方程：

**明确 base case - > 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义 ** 。

按上面的套路走，最后的结果就可以套这个框架：

```java
    # 初始化 base case
    dp[0][0][...] = base
    # 进行状态转移
    for 状态1 in 状态1的所有取值：
        for 状态2 in 状态2的所有取值：
            for ...
                dp[状态1][状态2][...] = 求最值(选择1，选择2...)

```

下面通过斐波那契数列问题和凑零钱问题来详解动态规划的基本原理。前者主要是让你明白什么是重叠子问题（斐波那契数列没有求最值，所以严格来说不是动态规划问题），后者主要举集中于如何列出状态转移方程。

## 一、斐波那契数列

请读者不要嫌弃这个例子简单， **只有简单的例子才能让你把精力充分集中在算法背后的通用思想和技巧上，而不会被那些隐晦的细节问题搞的莫名其妙**
。想要困难的例子，历史文章里有的是。

**1、暴力递归**

斐波那契数列的数学形式就是递归的，写成代码就是这样：

```java
    int fib(int N) {
        if (N == 1 || N == 2) return 1;
        return fib(N - 1) + fib(N - 2);
    }

```

这个不用多说了，学校老师讲递归的时候似乎都是拿这个举例。我们也知道这样写代码虽然简洁易懂，但是十分低效，低效在哪里？假设 n = 20，请画出递归树：

![](https://labuladong.gitee.io/algo/images/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%e8%af%a6%e8%a7%a3%e8%bf%9b%e9%98%b6/1.jpg)

> PS：但凡遇到需要递归的问题，最好都画出递归树，这对你分析算法的复杂度，寻找算法低效的原因都有巨大帮助。

这个递归树怎么理解？就是说想要计算原问题 ` f(20) ` ，我就得先计算出子问题 ` f(19) ` 和 ` f(18) ` ，然后要计算 `
f(19) ` ，我就要先算出子问题 ` f(18) ` 和 ` f(17) ` ，以此类推。最后遇到 ` f(1) ` 或者 ` f(2) `
的时候，结果已知，就能直接返回结果，递归树不再向下生长了。

**递归算法的时间复杂度怎么计算？就是用子问题个数乘以解决一个子问题需要的时间** 。

首先计算子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 O(2^n)。

然后计算解决一个子问题的时间，在本算法中，没有循环，只有 ` f(n - 1) + f(n - 2) ` 一个加法操作，时间为 O(1)。

所以，这个算法的时间复杂度为二者相乘，即 O(2^n)，指数级别，爆炸。

观察递归树，很明显发现了算法低效的原因：存在大量重复计算，比如 ` f(18) ` 被计算了两次，而且你可以看到，以 ` f(18) `
为根的这个递归树体量巨大，多算一遍，会耗费巨大的时间。更何况，还不止 ` f(18) ` 这一个节点被重复计算，所以这个算法及其低效。

这就是动态规划问题的第一个性质： **重叠子问题** 。下面，我们想办法解决这个问题。

**2、带备忘录的递归解法**

明确了问题，其实就已经把问题解决了一半。即然耗时的原因是重复计算，那么我们可以造一个「备忘录」，每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。

一般使用一个数组充当这个「备忘录」，当然你也可以使用哈希表（字典），思想都是一样的。

```java
    int fib(int N) {
        // 备忘录全初始化为 0
        int[] memo = new int[N + 1];
        // 进行带备忘录的递归
        return helper(memo, N);
    }
    
    int helper(int[] memo, int n) {
        // base case
        if (n == 0 || n == 1) return n;
        // 已经计算过，不用再计算了
        if (memo[n] != 0) return memo[n];
        memo[n] = helper(memo, n - 1) + helper(memo, n - 2);
        return memo[n];
    }

```

现在，画出递归树，你就知道「备忘录」到底做了什么。

![](https://labuladong.gitee.io/algo/images/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%e8%af%a6%e8%a7%a3%e8%bf%9b%e9%98%b6/2.jpg)

实际上，带「备忘录」的递归算法，把一棵存在巨量冗余的递归树通过「剪枝」，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数。

![](https://labuladong.gitee.io/algo/images/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%e8%af%a6%e8%a7%a3%e8%bf%9b%e9%98%b6/3.jpg)

**递归算法的时间复杂度怎么计算？就是用子问题个数乘以解决一个子问题需要的时间** 。

子问题个数，即图中节点的总数，由于本算法不存在冗余计算，子问题就是 ` f(1) ` , ` f(2) ` , ` f(3) ` … ` f(20) `
，数量和输入规模 n = 20 成正比，所以子问题个数为 O(n)。

解决一个子问题的时间，同上，没有什么循环，时间为 O(1)。

所以，本算法的时间复杂度是 O(n)。比起暴力算法，是降维打击。

至此，带备忘录的递归解法的效率已经和迭代的动态规划解法一样了。实际上，这种解法和迭代的动态规划已经差不多了，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」。

啥叫「自顶向下」？注意我们刚才画的递归树（或者说图），是从上向下延伸，都是从一个规模较大的原问题比如说 ` f(20) ` ，向下逐渐分解规模，直到 `
f(1) ` 和 ` f(2) ` 这两个 base case，然后逐层返回答案，这就叫「自顶向下」。

啥叫「自底向上」？反过来，我们直接从最底下，最简单，问题规模最小的 ` f(1) ` 和 ` f(2) ` 开始往上推，直到推到我们想要的答案 `
f(20) ` ，这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。

**3、dp 数组的迭代解法**

有了上一步「备忘录」的启发，我们可以把这个「备忘录」独立出来成为一张表，就叫做 DP table 吧，在这张表上完成「自底向上」的推算岂不美哉！

```java
    int fib(int N) {
        if (N == 0) return 0;
        int[] dp = new int[N + 1];
        // base case
        dp[0] = 0; dp[1] = 1;
        // 状态转移
        for (int i = 2; i <= N; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
    
        return dp[N];
    }

```

![](https://labuladong.gitee.io/algo/images/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%e8%af%a6%e8%a7%a3%e8%bf%9b%e9%98%b6/4.jpg)

画个图就很好理解了，而且你发现这个 DP table 特别像之前那个「剪枝」后的结果，只是反过来算而已。实际上，带备忘录的递归解法中的「备忘录」，最终完成后就是这个 DP
table，所以说这两种解法其实是差不多的，大部分情况下，效率也基本相同。

这里，引出「状态转移方程」这个名词，实际上就是描述问题结构的数学形式：

![](https://labuladong.gitee.io/algo/images/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%e8%af%a6%e8%a7%a3%e8%bf%9b%e9%98%b6/fib.png)

为啥叫「状态转移方程」？其实就是为了听起来高端。你把 ` f(n) ` 想做一个状态 ` n ` ，这个状态 ` n ` 是由状态 ` n - 1 `
和状态 ` n - 2 ` 相加转移而来，这就叫状态转移，仅此而已。

你会发现，上面的几种解法中的所有操作，例如 ` return f(n - 1) + f(n - 2) ` ， ` dp[i] = dp[i - 1] + dp[i - 2] ` ，以及对备忘录或 DP table
的初始化操作，都是围绕这个方程式的不同表现形式。可见列出「状态转移方程」的重要性，它是解决问题的核心。而且很容易发现，其实状态转移方程直接代表着暴力解法。

**千万不要看不起暴力解，动态规划问题最困难的就是写出这个暴力解，即状态转移方程** 。只要写出暴力解，优化方法无非是用备忘录或者 DP table，再无奥妙可言。

这个例子的最后，讲一个细节优化。细心的读者会发现，根据斐波那契数列的状态转移方程，当前状态只和之前的两个状态有关，其实并不需要那么长的一个 DP table
来存储所有的状态，只要想办法存储之前的两个状态就行了。所以，可以进一步优化，把空间复杂度降为 O(1)：

```java
    int fib(int n) {
        if (n < 1) return 0;
        if (n == 2 || n == 1) 
            return 1;
        int prev = 1, curr = 1;
        for (int i = 3; i <= n; i++) {
            int sum = prev + curr;
            prev = curr;
            curr = sum;
        }
        return curr;
    }

```

这个技巧就是所谓的「 **状态压缩** 」，如果我们发现每次状态转移只需要 DP table 中的一部分，那么可以尝试用状态压缩来缩小 DP table 的大小，只记录必要的数据，上述例子就相当于把DP table 的大小从 ` n `
缩小到 2。后续的动态规划章节中我们还会看到这样的例子，一般来说是把一个二维的 DP table 压缩成一维，即把空间复杂度从 O(n^2) 压缩到 O(n)。

有人会问，动态规划的另一个重要特性「最优子结构」，怎么没有涉及？下面会涉及。斐波那契数列的例子严格来说不算动态规划，因为没有涉及求最值，以上旨在说明重叠子问题的消除方法，演示得到最优解法逐步求精的过程。下面，看第二个例子，凑零钱问题。

## 二、凑零钱问题

先看下题目：给你 ` k ` 种面值的硬币，面值分别为 ` c1, c2 ... ck ` ，每种硬币的数量无限，再给一个总金额 ` amount `
，问你 **最少** 需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。算法的函数签名如下：

```java
    // coins 中是可选硬币面值，amount 是目标金额
    int coinChange(int[] coins, int amount);

```

比如说 ` k = 3 ` ，面值分别为 1，2，5，总金额 ` amount = 11 ` 。那么最少需要 3 枚硬币凑出，即 11 = 5 + 5 + 1。

你认为计算机应该如何解决这个问题？显然，就是把所有可能的凑硬币方法都穷举出来，然后找找看最少需要多少枚硬币。

**1、暴力递归**

首先，这个问题是动态规划问题，因为它具有「最优子结构」的。 **要符合「最优子结构」，子问题间必须互相独立**
。啥叫相互独立？你肯定不想看数学证明，我用一个直观的例子来讲解。

比如说，假设你考试，每门科目的成绩都是互相独立的。你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高…… 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高……
当然，最终就是你每门课都是满分，这就是最高的总成绩。

得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，“每门科目考到最高”这些子问题是互相独立，互不干扰的。

但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，数学分数高，语文分数就会降低，反之亦然。这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为子问题并不独立，语文数学成绩无法同时最优，所以最优子结构被破坏。

回到凑零钱问题，为什么说它符合最优子结构呢？比如你想求 ` amount = 11 ` 时的最少硬币数（原问题），如果你知道凑出 ` amount = 10
` 的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 1 的硬币）就是原问题的答案。因为硬币的数量是没有限制的，所以子问题之间没有相互制，是互相独立的。

> PS：关于最优子结构的问题，后文 [ 动态规划答疑篇 ](https://labuladong.gitee.io/algo/3/22/68/) 还会再举例探讨。

那么，既然知道了这是个动态规划问题，就要思考 **如何列出正确的状态转移方程** ？

1、 **确定 base case** ，这个很简单，显然目标金额 ` amount ` 为 0 时算法返回 0，因为不需要任何硬币就已经凑出目标金额了。

2、 **确定「状态」，也就是原问题和子问题中会变化的变量** 。由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的「状态」就是目标金额 ` amount ` 。

3、 **确定「选择」，也就是导致「状态」产生变化的行为**
。目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的「选择」。

4、 **明确` dp ` 函数/数组的定义 ** 。我们这里讲的是自顶向下的解法，所以会有一个递归的 ` dp `
函数，一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是题目要求我们计算的量。就本题来说，状态只有一个，即「目标金额」，题目要求我们计算凑出目标金额所需的最少硬币数量。所以我们可以这样定义
` dp ` 函数：

` dp(n) ` 的定义：输入一个目标金额 ` n ` ，返回凑出目标金额 ` n ` 的最少硬币数量。

搞清楚上面这几个关键点，解法的伪码就可以写出来了：

```java
    // 伪码框架
    int coinChange(int[] coins, int amount) {
        // 题目要求的最终结果是 dp(amount)
        return dp(coins, amount)
    }
    
    // 定义：要凑出金额 n，至少要 dp(coins, n) 个硬币
    int dp(int[] coins, int n) {
        // 做选择，选择需要硬币最少的那个结果
        for (int coin : coins) {
            res = min(res, 1 + dp(n - coin))
        }
        return res
    }

```

根据伪码，我们加上 base case 即可得到最终的答案。显然目标金额为 0 时，所需硬币数量为 0；当目标金额小于 0 时，无解，返回 -1：

```java
    int coinChange(int[] coins, int amount) {
        // 题目要求的最终结果是 dp(amount)
        return dp(coins, amount)
    }
    
    int dp(int[] coins, int amount) {
        // base case
        if (amount == 0) return 0;
        if (amount < 0) return -1;
    
        int res = Integer.MAX_VALUE;
        for (int coin : coins) {
            // 计算子问题的结果
            int subProblem = dp(coins, amount - coin);
            // 子问题无解则跳过
            if (subProblem == -1) continue;
            // 在子问题中选择最优解，然后加一
            res = Math.min(res, subProblem + 1);
        }
    
        return res == Integer.MAX_VALUE ? -1 : res;
    }

```

> PS：这里 ` coinChange ` 和 ` dp ` 函数的签名完全一样，所以理论上不需要额外写一个 ` dp `
> 函数。但为了后文讲解方便，这里还是另写一个 ` dp ` 函数来实现主要逻辑。

至此，状态转移方程其实已经完成了，以上算法已经是暴力解法了，以上代码的数学形式就是状态转移方程：

![](https://labuladong.gitee.io/algo/images/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%e8%af%a6%e8%a7%a3%e8%bf%9b%e9%98%b6/coin.png)

至此，这个问题其实就解决了，只不过需要消除一下重叠子问题，比如 ` amount = 11, coins = {1,2,5} ` 时画出递归树看看：

![](https://labuladong.gitee.io/algo/images/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%e8%af%a6%e8%a7%a3%e8%bf%9b%e9%98%b6/5.jpg)

**递归算法的时间复杂度分析：子问题总数 x 每个子问题的时间** 。

子问题总数为递归树节点个数，这个比较难看出来，是 O(n^k)，总之是指数级别的。每个子问题中含有一个 for 循环，复杂度为 O(k)。所以总时间复杂度为 O(k * n^k)，指数级别。

**2、带备忘录的递归**

类似之前斐波那契数列的例子，只需要稍加修改，就可以通过备忘录消除子问题：

```java
    int[] memo;
    
    int coinChange(int[] coins, int amount) {
        memo = new int[amount + 1];
        // dp 数组全都初始化为特殊值
        Arrays.fill(memo, -666);
    
        return dp(coins, amount);
    }
    
    int dp(int[] coins, int amount) {
        if (amount == 0) return 0;
        if (amount < 0) return -1;
        // 查备忘录，防止重复计算
        if (memo[amount] != -666)
            return memo[amount];
    
        int res = Integer.MAX_VALUE;
        for (int coin : coins) {
            // 计算子问题的结果
            int subProblem = dp(coins, amount - coin);
            // 子问题无解则跳过
            if (subProblem == -1) continue;
            // 在子问题中选择最优解，然后加一
            res = Math.min(res, subProblem + 1);
        }
        // 把计算结果存入备忘录
        memo[amount] = (res == Integer.MAX_VALUE) ? -1 : res;
        return memo[amount];
    }

```

不画图了，很显然「备忘录」大大减小了子问题数目，完全消除了子问题的冗余，所以子问题总数不会超过金额数 ` n ` ，即子问题数目为 O(n)。处理一个子问题的时间不变，仍是 O(k)，所以总的时间复杂度是 O(kn)。

**3、dp 数组的迭代解法**

当然，我们也可以自底向上使用 dp table 来消除重叠子问题，关于「状态」「选择」和 base case 与之前没有区别， ` dp `
数组的定义和刚才 ` dp ` 函数类似，也是把「状态」，也就是目标金额作为变量。不过 ` dp ` 函数体现在函数参数，而 ` dp `
数组体现在数组索引：

**` dp ` 数组的定义：当目标金额为 ` i ` 时，至少需要 ` dp[i] ` 枚硬币凑出 ** 。

根据我们文章开头给出的动态规划代码框架可以写出如下解法：

```java
    int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        // 数组大小为 amount + 1，初始值也为 amount + 1
        Arrays.fill(dp, amount + 1);
    
        // base case
        dp[0] = 0;
        // 外层 for 循环在遍历所有状态的所有取值
        for (int i = 0; i < dp.length; i++) {
            // 内层 for 循环在求所有选择的最小值
            for (int coin : coins) {
                // 子问题无解，跳过
                if (i - coin < 0) {
                    continue;
                }
                dp[i] = Math.min(dp[i], 1 + dp[i - coin]);
            }
        }
        return (dp[amount] == amount + 1) ? -1 : dp[amount];
    }

```

![](https://labuladong.gitee.io/algo/images/%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%e8%af%a6%e8%a7%a3%e8%bf%9b%e9%98%b6/6.jpg)

> PS：为啥 ` dp ` 数组初始化为 ` amount + 1 ` 呢，因为凑成 ` amount ` 金额的硬币数最多只可能等于 ` amount
> ` （全用 1 元面值的硬币），所以初始化为 ` amount + 1 ` 就相当于初始化为正无穷，便于后续取最小值。为啥不直接初始化为 int
> 型的最大值 ` Integer.MAX_VALUE ` 呢？因为后面有 ` dp[i - coin] + 1 ` ，这就会导致整型溢出。

## 三、最后总结

第一个斐波那契数列的问题，解释了如何通过「备忘录」或者「dp table」的方法来优化递归树，并且明确了这两种方法本质上是一样的，只是自顶向下和自底向上的不同而已。

第二个凑零钱的问题，展示了如何流程化确定「状态转移方程」，只要通过状态转移方程写出暴力递归解，剩下的也就是优化递归树，消除重叠子问题而已。

如果你不太了解动态规划，还能看到这里，真得给你鼓掌，相信你已经掌握了这个算法的设计技巧。

**计算机解决问题其实没有任何奇技淫巧，它唯一的解决办法就是穷举** ，穷举所有可能性。算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。

列出状态转移方程，就是在解决“如何穷举”的问题。之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。

备忘录、DP table 就是在追求“如何聪明地穷举”。用空间换时间的思路，是降低时间复杂度的不二法门，除此之外，试问，还能玩出啥花活？

之后我们会有一章专门讲解动态规划问题，如果有任何问题都可以随时回来重读本文，希望读者在阅读每个题目和解法时，多往「状态」和「选择」上靠，才能对这套框架产生自己的理解，运用自如。

接下来可阅读：

* [ 动态规划设计：最长递增子序列 ](https://labuladong.gitee.io/algo/3/23/74/)

**＿＿＿＿＿＿＿＿＿＿＿＿＿**





# 回溯算法解题套路框架




** ~

读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 46. 全排列（中等） ](https://leetcode-cn.com/problems/permutations)

[ 51. N皇后（困难） ](https://leetcode-cn.com/problems/n-queens)

**———–**

本文有视频版： [ 回溯算法框架套路详解 ](https://www.bilibili.com/video/BV1P5411N7Xc)

这篇文章是很久之前的一篇 [ 回溯算法详解 ](https://mp.weixin.qq.com/s/trILKSiN9EoS58pXmvUtUQ)
的进阶版，之前那篇不够清楚，就不必看了，看这篇就行。把框架给你讲清楚，你会发现回溯算法问题都是一个套路。

本文解决几个问题：

回溯算法是什么？解决回溯算法相关的问题有什么技巧？如何学习回溯算法？回溯算法代码是否有规律可循？

其实回溯算法其实就是我们常说的 DFS 算法，本质上就是一种暴力穷举算法。

废话不多说，直接上回溯算法框架。 **解决一个回溯问题，实际上就是一个决策树的遍历过程** 。你只需要思考 3 个问题：

1、路径：也就是已经做出的选择。

2、选择列表：也就是你当前可以做的选择。

3、结束条件：也就是到达决策树底层，无法再做选择的条件。

如果你不理解这三个词语的解释，没关系，我们后面会用「全排列」和「N 皇后问题」这两个经典的回溯算法问题来帮你理解这些词语是什么意思，现在你先留着印象。

代码方面，回溯算法的框架：

```java
    result = []
    def backtrack(路径, 选择列表):
        if 满足结束条件:
            result.add(路径)
            return
        
        for 选择 in 选择列表:
            做选择
            backtrack(路径, 选择列表)
            撤销选择

```

**其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」** ，特别简单。

什么叫做选择和撤销选择呢，这个框架的底层原理是什么呢？下面我们就通过「全排列」这个问题来解开之前的疑惑，详细探究一下其中的奥妙！

## 一、全排列问题

我们在高中的时候就做过排列组合的数学题，我们也知道 ` n ` 个不重复的数，全排列共有 ` n! ` 个。

> PS： **为了简单清晰起见，我们这次讨论的全排列问题不包含重复的数字** 。

那么我们当时是怎么穷举全排列的呢？比方说给三个数 ` [1,2,3] ` ，你肯定不会无规律地乱穷举，一般是这样：

先固定第一位为 1，然后第二位可以是 2，那么第三位只能是 3；然后可以把第二位变成 3，第三位就只能是 2 了；然后就只能变化第一位，变成 2，然后再穷举后两位……

其实这就是回溯算法，我们高中无师自通就会用，或者有的同学直接画出如下这棵回溯树：

![](https://labuladong.gitee.io/algo/images/backtracking/1.jpg)

只要从根遍历这棵树，记录路径上的数字，其实就是所有的全排列。 **我们不妨把这棵树称为回溯算法的「决策树」** 。

**为啥说这是决策树呢，因为你在每个节点上其实都在做决策** 。比如说你站在下图的红色节点上：

![](https://labuladong.gitee.io/algo/images/backtracking/2.jpg)

你现在就在做决策，可以选择 1 那条树枝，也可以选择 3 那条树枝。为啥只能在 1 和 3 之中选择呢？因为 2 这个树枝在你身后，这个选择你之前做过了，而全排列是不允许重复使用数字的。

**现在可以解答开头的几个名词：` [2] ` 就是「路径」，记录你已经做过的选择； ` [1,3] `
就是「选择列表」，表示你当前可以做出的选择；「结束条件」就是遍历到树的底层，在这里就是选择列表为空的时候 ** 。

如果明白了这几个名词， **可以把「路径」和「选择」列表作为决策树上每个节点的属性** ，比如下图列出了几个节点的属性：

![](https://labuladong.gitee.io/algo/images/backtracking/3.jpg)

**我们定义的` backtrack ` 函数其实就像一个指针，在这棵树上游走，同时要正确维护每个节点的属性，每当走到树的底层，其「路径」就是一个全排列

** 。

再进一步，如何遍历一棵树？这个应该不难吧。回忆一下之前 [ 学习数据结构的框架思维 ](https://labuladong.gitee.io/algo/1/2/)
写过，各种搜索问题其实都是树的遍历问题，而多叉树的遍历框架就是这样：

```java
    void traverse(TreeNode root) {
        for (TreeNode child : root.childern)
            // 前序遍历需要的操作
            traverse(child);
            // 后序遍历需要的操作
    }

```

而所谓的前序遍历和后序遍历，他们只是两个很有用的时间点，我给你画张图你就明白了：

![](https://labuladong.gitee.io/algo/images/backtracking/4.jpg)

**前序遍历的代码在进入某一个节点之前的那个时间点执行，后序遍历代码在离开某个节点之后的那个时间点执行** 。

回想我们刚才说的，「路径」和「选择」是每个节点的属性，函数在树上游走要正确维护节点的属性，那么就要在这两个特殊时间点搞点动作：

![](https://labuladong.gitee.io/algo/images/backtracking/5.jpg)

现在，你是否理解了回溯算法的这段核心框架？

```java
    for 选择 in 选择列表:
        # 做选择
        将该选择从选择列表移除
        路径.add(选择)
        backtrack(路径, 选择列表)
        # 撤销选择
        路径.remove(选择)
        将该选择再加入选择列表

```

**我们只要在递归之前做出选择，在递归之后撤销刚才的选择** ，就能正确得到每个节点的选择列表和路径。

下面，直接看全排列代码：

```java
    List<List<Integer>> res = new LinkedList<>();
    
    /* 主函数，输入一组不重复的数字，返回它们的全排列 */
    List<List<Integer>> permute(int[] nums) {
        // 记录「路径」
        LinkedList<Integer> track = new LinkedList<>();
        backtrack(nums, track);
        return res;
    }
    
    // 路径：记录在 track 中
    // 选择列表：nums 中不存在于 track 的那些元素
    // 结束条件：nums 中的元素全都在 track 中出现
    void backtrack(int[] nums, LinkedList<Integer> track) {
        // 触发结束条件
        if (track.size() == nums.length) {
            res.add(new LinkedList(track));
            return;
        }
        
        for (int i = 0; i < nums.length; i++) {
            // 排除不合法的选择
            if (track.contains(nums[i]))
                continue;
            // 做选择
            track.add(nums[i]);
            // 进入下一层决策树
            backtrack(nums, track);
            // 取消选择
            track.removeLast();
        }
    }

```

我们这里稍微做了些变通，没有显式记录「选择列表」，而是通过 ` nums ` 和 ` track ` 推导出当前的选择列表：

![](https://labuladong.gitee.io/algo/images/backtracking/6.jpg)

至此，我们就通过全排列问题详解了回溯算法的底层原理。当然，这个算法解决全排列不是很高效，应为对链表使用 ` contains ` 方法需要 O(N)
的时间复杂度。有更好的方法通过交换元素达到目的，但是难理解一些，这里就不写了，有兴趣可以自行搜索一下。

但是必须说明的是，不管怎么优化，都符合回溯框架，而且时间复杂度都不可能低于 O(N!)，因为穷举整棵决策树是无法避免的。
**这也是回溯算法的一个特点，不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高** 。

明白了全排列问题，就可以直接套回溯算法框架了，下面简单看看 N 皇后问题。

## 二、N 皇后问题

这个问题很经典了，简单解释一下：给你一个 N×N 的棋盘，让你放置 N 个皇后，使得它们不能互相攻击。

> PS：皇后可以攻击同一行、同一列、左上左下右上右下四个方向的任意单位。

这个问题本质上跟全排列问题差不多，决策树的每一层表示棋盘上的每一行；每个节点可以做出的选择是，在该行的任意一列放置一个皇后。

因为 C++ 代码对字符串的操作方便一些，所以这道题我用 C++ 来写解法，直接套用回溯算法框架:

```java
    vector<vector<string>> res;
    
    /* 输入棋盘边长 n，返回所有合法的放置 */
    vector<vector<string>> solveNQueens(int n) {
        // '.' 表示空，'Q' 表示皇后，初始化空棋盘。
        vector<string> board(n, string(n, '.'));
        backtrack(board, 0);
        return res;
    }
    
    // 路径：board 中小于 row 的那些行都已经成功放置了皇后
    // 选择列表：第 row 行的所有列都是放置皇后的选择
    // 结束条件：row 超过 board 的最后一行
    void backtrack(vector<string>& board, int row) {
        // 触发结束条件
        if (row == board.size()) {
            res.push_back(board);
            return;
        }
        
        int n = board[row].size();
        for (int col = 0; col < n; col++) {
            // 排除不合法选择
            if (!isValid(board, row, col)) 
                continue;
            // 做选择
            board[row][col] = 'Q';
            // 进入下一行决策
            backtrack(board, row + 1);
            // 撤销选择
            board[row][col] = '.';
        }
    }

```

这部分主要代码，其实跟全排列问题差不多， ` isValid ` 函数的实现也很简单：

```java
    /* 是否可以在 board[row][col] 放置皇后？ */
    bool isValid(vector<string>& board, int row, int col) {
        int n = board.size();
        // 检查列是否有皇后互相冲突
        for (int i = 0; i < n; i++) {
            if (board[i][col] == 'Q')
                return false;
        }
        // 检查右上方是否有皇后互相冲突
        for (int i = row - 1, j = col + 1; 
                i >= 0 && j < n; i--, j++) {
            if (board[i][j] == 'Q')
                return false;
        }
        // 检查左上方是否有皇后互相冲突
        for (int i = row - 1, j = col - 1;
                i >= 0 && j >= 0; i--, j--) {
            if (board[i][j] == 'Q')
                return false;
        }
        return true;
    }

```

> PS：肯定有读者问，按照 N 皇后问题的描述，我们为什么不检查左下角，右下角和下方的格子，只检查了左上角，右上角和上方的格子呢？

因为皇后是一行一行从上往下放的，所以左下方，右下方和正下方不用检查（还没放皇后）；因为一行只会放一个皇后，所以每行不用检查。也就是最后只用检查上面，左上，右上三个方向。

函数 ` backtrack ` 依然像个在决策树上游走的指针，通过 ` row ` 和 ` col ` 就可以表示函数遍历到的位置，通过 `
isValid ` 函数可以将不符合条件的情况剪枝：

![](https://labuladong.gitee.io/algo/images/backtracking/7.jpg)

如果直接给你这么一大段解法代码，可能是懵逼的。但是现在明白了回溯算法的框架套路，还有啥难理解的呢？无非是改改做选择的方式，排除不合法选择的方式而已，只要框架存于心，你面对的只剩下小问题了。

当 ` N = 8 `
时，就是八皇后问题，数学大佬高斯穷尽一生都没有数清楚八皇后问题到底有几种可能的放置方法，但是我们的算法只需要一秒就可以算出来所有可能的结果。

不过真的不怪高斯。这个问题的复杂度确实非常高，看看我们的决策树，虽然有 ` isValid ` 函数剪枝，但是最坏时间复杂度仍然是 O(N^(N+1))，而且无法优化。如果 ` N = 10 ` 的时候，计算就已经很耗时了。

**有的时候，我们并不想得到所有合法的答案，只想要一个答案，怎么办呢** ？比如解数独的算法，找所有解法复杂度太高，只要找到一种解法就可以。

其实特别简单，只要稍微修改一下回溯算法的代码即可：

```java
    // 函数找到一个答案后就返回 true
    bool backtrack(vector<string>& board, int row) {
        // 触发结束条件
        if (row == board.size()) {
            res.push_back(board);
            return true;
        }
        ...
        for (int col = 0; col < n; col++) {
            ...
            board[row][col] = 'Q';
    
            if (backtrack(board, row + 1))
                return true;
            
            board[row][col] = '.';
        }
    
        return false;
    }

```

这样修改后，只要找到一个答案，for 循环的后续递归穷举都会被阻断。也许你可以在 N 皇后问题的代码框架上，稍加修改，写一个解数独的算法？

## 三、最后总结

回溯算法就是个多叉树的遍历问题，关键就是在前序遍历和后序遍历的位置做一些操作，算法框架如下：

```java
    def backtrack(...):
        for 选择 in 选择列表:
            做选择
            backtrack(...)
            撤销选择

```

**写` backtrack ` 函数时，需要维护走过的「路径」和当前可以做的「选择列表」，当触发「结束条件」时，将「路径」记入结果集 ** 。

其实想想看，回溯算法和动态规划是不是有点像呢？我们在动态规划系列文章中多次强调，动态规划的三个需要明确的点就是「状态」「选择」和「base case」，是不是就对应着走过的「路径」，当前的「选择列表」和「结束条件」？

某种程度上说，动态规划的暴力求解阶段就是回溯算法。只是有的问题具有重叠子问题性质，可以用 dp table
或者备忘录优化，将递归树大幅剪枝，这就变成了动态规划。而今天的两个问题，都没有重叠子问题，也就是回溯算法问题了，复杂度非常高是不可避免的。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**





# BFS 算法解题套路框架




** ~

读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 111. 二叉树的最小深度（简单） ](https://leetcode-cn.com/problems/minimum-depth-of-
binary-tree)

[ 752. 打开转盘锁（中等） ](https://leetcode-cn.com/problems/open-the-lock)

**———–**

后台有很多人问起 BFS 和 DFS 的框架，今天就来说说吧。

首先，你要说我没写过 BFS 框架，这话没错，今天写个框架你背住就完事儿了。但要是说没写过 DFS 框架，那你还真是说错了， **其实 DFS 算法就是回溯算法** ，我们前文 [ 回溯算法框架套路详解 ](https://labuladong.gitee.io/algo/4/28/105/)
就写过了，而且写得不是一般得好，建议好好复习，嘿嘿嘿~

BFS 的核心思想应该不难理解的，就是把一些问题抽象成图，从一个点开始，向四周开始扩散。一般来说，我们写 BFS 算法都是用「队列」这种数据结构，每次将一个节点周围的所有节点加入队列。

BFS 相对 DFS 的最主要的区别是： **BFS 找到的路径一定是最短的，但代价就是空间复杂度可能比 DFS 大很多**
，至于为什么，我们后面介绍了框架就很容易看出来了。

本文就由浅入深写两道 BFS 的典型题目，分别是「二叉树的最小高度」和「打开密码锁的最少步数」，手把手教你怎么写 BFS 算法。

## 一、算法框架

要说框架的话，我们先举例一下 BFS 出现的常见场景好吧， **问题的本质就是让你在一幅「图」中找到从起点` start ` 到终点 ` target `
的最近距离，这个例子听起来很枯燥，但是 BFS 算法问题其实都是在干这个事儿 ** ，把枯燥的本质搞清楚了，再去欣赏各种问题的包装才能胸有成竹嘛。

这个广义的描述可以有各种变体，比如走迷宫，有的格子是围墙不能走，从起点到终点的最短距离是多少？如果这个迷宫带「传送门」可以瞬间传送呢？

再比如说两个单词，要求你通过某些替换，把其中一个变成另一个，每次只能替换一个字符，最少要替换几次？

再比如说连连看游戏，两个方块消除的条件不仅仅是图案相同，还得保证两个方块之间的最短连线不能多于两个拐点。你玩连连看，点击两个坐标，游戏是如何判断它俩的最短连线有几个拐点的？

再比如……

净整些花里胡哨的，这些问题都没啥奇技淫巧，本质上就是一幅「图」，让你从一个起点，走到终点，问最短路径。这就是 BFS 的本质，框架搞清楚了直接默写就好。

![](https://labuladong.gitee.io/algo/images/BFS/0.jpeg)

记住下面这个框架就 OK 了：

```java
    // 计算从起点 start 到终点 target 的最近距离
    int BFS(Node start, Node target) {
        Queue<Node> q; // 核心数据结构
        Set<Node> visited; // 避免走回头路
        
        q.offer(start); // 将起点加入队列
        visited.add(start);
        int step = 0; // 记录扩散的步数
    
        while (q not empty) {
            int sz = q.size();
            /* 将当前队列中的所有节点向四周扩散 */
            for (int i = 0; i < sz; i++) {
                Node cur = q.poll();
                /* 划重点：这里判断是否到达终点 */
                if (cur is target)
                    return step;
                /* 将 cur 的相邻节点加入队列 */
                for (Node x : cur.adj()) {
                    if (x not in visited) {
                        q.offer(x);
                        visited.add(x);
                    }
                }
            }
            /* 划重点：更新步数在这里 */
            step++;
        }
    }

```

队列 ` q ` 就不说了，BFS 的核心数据结构； ` cur.adj() ` 泛指 ` cur ` 相邻的节点，比如说二维数组中， ` cur `
上下左右四面的位置就是相邻节点； ` visited `
的主要作用是防止走回头路，大部分时候都是必须的，但是像一般的二叉树结构，没有子节点到父节点的指针，不会走回头路就不需要 ` visited ` 。

## 二、二叉树的最小高度

先来个简单的问题实践一下 BFS 框架吧，判断一棵二叉树的 **最小** 高度，这也是 LeetCode 第 111 题，看一下题目：

![](https://labuladong.gitee.io/algo/images/BFS/title1.jpg)

怎么套到 BFS 的框架里呢？首先明确一下起点 ` start ` 和终点 ` target ` 是什么，怎么判断到达了终点？

**显然起点就是` root ` 根节点，终点就是最靠近根节点的那个「叶子节点」嘛 ** ，叶子节点就是两个子节点都是 ` null ` 的节点：

```java
    if (cur.left == null && cur.right == null) 
        // 到达叶子节点

```

那么，按照我们上述的框架稍加改造来写解法即可：

```java
    int minDepth(TreeNode root) {
        if (root == null) return 0;
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);
        // root 本身就是一层，depth 初始化为 1
        int depth = 1;
        
        while (!q.isEmpty()) {
            int sz = q.size();
            /* 将当前队列中的所有节点向四周扩散 */
            for (int i = 0; i < sz; i++) {
                TreeNode cur = q.poll();
                /* 判断是否到达终点 */
                if (cur.left == null && cur.right == null) 
                    return depth;
                /* 将 cur 的相邻节点加入队列 */
                if (cur.left != null)
                    q.offer(cur.left);
                if (cur.right != null) 
                    q.offer(cur.right);
            }
            /* 这里增加步数 */
            depth++;
        }
        return depth;
    }

```

这里注意这个 ` while ` 循环和 ` for ` 循环的配合， **` while ` 循环控制一层一层往下走， ` for ` 循环利用 ` sz
` 变量控制从左到右遍历每一层二叉树节点 ** ：

![](https://labuladong.gitee.io/algo/images/dijkstra/1.jpeg)

这一点很重要，这个形式在普通 BFS 问题中都很常见，但是在 [ Dijkstra 算法模板框架 ](https://labuladong.gitee.io/algo/2/18/41/)
中我们修改了这种代码模式，读完并理解本文后你可以去看看 BFS 算法是如何演变成 Dijkstra 算法在加权图中寻找最短路径的。

话说回来，二叉树本身是很简单的数据结构，我想上述代码你应该可以理解的，其实其他复杂问题都是这个框架的变形，再探讨复杂问题之前，我们解答两个问题：

**1、为什么 BFS 可以找到最短距离，DFS 不行吗** ？

首先，你看 BFS 的逻辑， ` depth ` 每增加一次，队列中的所有节点都向前迈一步，这保证了第一次到达终点的时候，走的步数是最少的。

DFS 不能找最短路径吗？其实也是可以的，但是时间复杂度相对高很多。你想啊，DFS 实际上是靠递归的堆栈记录走过的路径，你要找到最短路径，肯定得把二叉树中所有树杈都探索完才能对比出最短的路径有多长对不对？而 BFS
借助队列做到一次一步「齐头并进」，是可以在不遍历完整棵树的条件下找到最短距离的。

形象点说，DFS 是线，BFS 是面；DFS 是单打独斗，BFS 是集体行动。这个应该比较容易理解吧。

**2、既然 BFS 那么好，为啥 DFS 还要存在** ？

BFS 可以找到最短距离，但是空间复杂度高，而 DFS 的空间复杂度较低。

还是拿刚才我们处理二叉树问题的例子，假设给你的这个二叉树是满二叉树，节点数为 ` N ` ，对于 DFS 算法来说，空间复杂度无非就是递归堆栈，最坏情况下顶多就是树的高度，也就是 ` O(logN) ` 。

但是你想想 BFS 算法，队列中每次都会储存着二叉树一层的节点，这样的话最坏情况下空间复杂度应该是树的最底层节点的数量，也就是 ` N/2 ` ，用 Big O 表示的话也就是 ` O(N) ` 。

由此观之，BFS 还是有代价的，一般来说在找最短路径的时候使用 BFS，其他时候还是 DFS 使用得多一些（主要是递归代码好写）。

好了，现在你对 BFS 了解得足够多了，下面来一道难一点的题目，深化一下框架的理解吧。

## 三、解开密码锁的最少次数

这道 LeetCode 题目是第 752 题，比较有意思：

![](https://labuladong.gitee.io/algo/images/BFS/title2.jpg)

题目中描述的就是我们生活中常见的那种密码锁，若果没有任何约束，最少的拨动次数很好算，就像我们平时开密码锁那样直奔密码拨就行了。

但现在的难点就在于，不能出现 ` deadends ` ，应该如何计算出最少的转动次数呢？

**第一步，我们不管所有的限制条件，不管` deadends ` 和 ` target `
的限制，就思考一个问题：如果让你设计一个算法，穷举所有可能的密码组合，你怎么做 ** ？

穷举呗，再简单一点，如果你只转一下锁，有几种可能？总共有 4 个位置，每个位置可以向上转，也可以向下转，也就是有 8 种可能对吧。

比如说从 ` "0000" ` 开始，转一次，可以穷举出 ` "1000", "9000", "0100", "0900"... ` 共 8 种密码。然后，再以这 8 种密码作为基础，对每个密码再转一下，穷举出所有可能…

**仔细想想，这就可以抽象成一幅图，每个节点有 8 个相邻的节点** ，又让你求最短距离，这不就是典型的 BFS 嘛，框架就可以派上用场了，先写出一个「简陋」的 BFS 框架代码再说别的：

```java
    // 将 s[j] 向上拨动一次
    String plusOne(String s, int j) {
        char[] ch = s.toCharArray();
        if (ch[j] == '9')
            ch[j] = '0';
        else
            ch[j] += 1;
        return new String(ch);
    }
    // 将 s[i] 向下拨动一次
    String minusOne(String s, int j) {
        char[] ch = s.toCharArray();
        if (ch[j] == '0')
            ch[j] = '9';
        else
            ch[j] -= 1;
        return new String(ch);
    }
    
    // BFS 框架，打印出所有可能的密码
    void BFS(String target) {
        Queue<String> q = new LinkedList<>();
        q.offer("0000");
        
        while (!q.isEmpty()) {
            int sz = q.size();
            /* 将当前队列中的所有节点向周围扩散 */
            for (int i = 0; i < sz; i++) {
                String cur = q.poll();
                /* 判断是否到达终点 */
                System.out.println(cur);
    
                /* 将一个节点的相邻节点加入队列 */
                for (int j = 0; j < 4; j++) {
                    String up = plusOne(cur, j);
                    String down = minusOne(cur, j);
                    q.offer(up);
                    q.offer(down);
                }
            }
            /* 在这里增加步数 */
        }
        return;
    }

```

> PS：这段代码当然有很多问题，但是我们做算法题肯定不是一蹴而就的，而是从简陋到完美的。不要完美主义，咱要慢慢来，好不。

**这段 BFS 代码已经能够穷举所有可能的密码组合了，但是显然不能完成题目，有如下问题需要解决** ：

1、会走回头路。比如说我们从 ` "0000" ` 拨到 ` "1000" ` ，但是等从队列拿出 ` "1000" ` 时，还会拨出一个 ` "0000"
` ，这样的话会产生死循环。

2、没有终止条件，按照题目要求，我们找到 ` target ` 就应该结束并返回拨动的次数。

3、没有对 ` deadends ` 的处理，按道理这些「死亡密码」是不能出现的，也就是说你遇到这些密码的时候需要跳过。

如果你能够看懂上面那段代码，真得给你鼓掌，只要按照 BFS 框架在对应的位置稍作修改即可修复这些问题：

```java
    int openLock(String[] deadends, String target) {
        // 记录需要跳过的死亡密码
        Set<String> deads = new HashSet<>();
        for (String s : deadends) deads.add(s);
        // 记录已经穷举过的密码，防止走回头路
        Set<String> visited = new HashSet<>();
        Queue<String> q = new LinkedList<>();
        // 从起点开始启动广度优先搜索
        int step = 0;
        q.offer("0000");
        visited.add("0000");
        
        while (!q.isEmpty()) {
            int sz = q.size();
            /* 将当前队列中的所有节点向周围扩散 */
            for (int i = 0; i < sz; i++) {
                String cur = q.poll();
                
                /* 判断是否到达终点 */
                if (deads.contains(cur))
                    continue;
                if (cur.equals(target))
                    return step;
                
                /* 将一个节点的未遍历相邻节点加入队列 */
                for (int j = 0; j < 4; j++) {
                    String up = plusOne(cur, j);
                    if (!visited.contains(up)) {
                        q.offer(up);
                        visited.add(up);
                    }
                    String down = minusOne(cur, j);
                    if (!visited.contains(down)) {
                        q.offer(down);
                        visited.add(down);
                    }
                }
            }
            /* 在这里增加步数 */
            step++;
        }
        // 如果穷举完都没找到目标密码，那就是找不到了
        return -1;
    }

```

至此，我们就解决这道题目了。有一个比较小的优化：可以不需要 ` dead ` 这个哈希集合，可以直接将这些元素初始化到 ` visited `
集合中，效果是一样的，可能更加优雅一些。

## 四、双向 BFS 优化

你以为到这里 BFS 算法就结束了？恰恰相反。BFS 算法还有一种稍微高级一点的优化思路： **双向 BFS** ，可以进一步提高算法的效率。

篇幅所限，这里就提一下区别： **传统的 BFS 框架就是从起点开始向四周扩散，遇到终点时停止；而双向 BFS 则是从起点和终点同时开始扩散，当两边有交集的时候停止** 。

为什么这样能够能够提升效率呢？其实从 Big O 表示法分析算法复杂度的话，它俩的最坏复杂度都是 ` O(N) ` ，但是实际上双向 BFS 确实会快一些，我给你画两张图看一眼就明白了：

![](https://labuladong.gitee.io/algo/images/BFS/1.jpeg) ![](https://labuladong.gitee.io/algo/images/BFS/2.jpeg)

图示中的树形结构，如果终点在最底部，按照传统 BFS 算法的策略，会把整棵树的节点都搜索一遍，最后找到 ` target ` ；而双向 BFS 其实只遍历了半棵树就出现了交集，也就是找到了最短距离。从这个例子可以直观地感受到，双向 BFS
是要比传统 BFS 高效的。

**不过，双向 BFS 也有局限，因为你必须知道终点在哪里** 。比如我们刚才讨论的二叉树最小高度的问题，你一开始根本就不知道终点在哪里，也就无法使用双向 BFS；但是第二个密码锁的问题，是可以使用双向 BFS
算法来提高效率的，代码稍加修改即可：

```java
    int openLock(String[] deadends, String target) {
        Set<String> deads = new HashSet<>();
        for (String s : deadends) deads.add(s);
        // 用集合不用队列，可以快速判断元素是否存在
        Set<String> q1 = new HashSet<>();
        Set<String> q2 = new HashSet<>();
        Set<String> visited = new HashSet<>();
        
        int step = 0;
        q1.add("0000");
        q2.add(target);
        
        while (!q1.isEmpty() && !q2.isEmpty()) {
            // 哈希集合在遍历的过程中不能修改，用 temp 存储扩散结果
            Set<String> temp = new HashSet<>();
    
            /* 将 q1 中的所有节点向周围扩散 */
            for (String cur : q1) {
                /* 判断是否到达终点 */
                if (deads.contains(cur))
                    continue;
                if (q2.contains(cur))
                    return step;
                visited.add(cur);
    
                /* 将一个节点的未遍历相邻节点加入集合 */
                for (int j = 0; j < 4; j++) {
                    String up = plusOne(cur, j);
                    if (!visited.contains(up))
                        temp.add(up);
                    String down = minusOne(cur, j);
                    if (!visited.contains(down))
                        temp.add(down);
                }
            }
            /* 在这里增加步数 */
            step++;
            // temp 相当于 q1
            // 这里交换 q1 q2，下一轮 while 就是扩散 q2
            q1 = q2;
            q2 = temp;
        }
        return -1;
    }

```

双向 BFS 还是遵循 BFS 算法框架的，只是 **不再使用队列，而是使用 HashSet 方便快速判断两个集合是否有交集** 。

另外的一个技巧点就是 **while 循环的最后交换` q1 ` 和 ` q2 ` 的内容 ** ，所以只要默认扩散 ` q1 ` 就相当于轮流扩散 `
q1 ` 和 ` q2 ` 。

其实双向 BFS 还有一个优化，就是在 while 循环开始时做一个判断：

```java
    // ...
    while (!q1.isEmpty() && !q2.isEmpty()) {
        if (q1.size() > q2.size()) {
            // 交换 q1 和 q2
            temp = q1;
            q1 = q2;
            q2 = temp;
        }
        // ...

```

为什么这是一个优化呢？

因为按照 BFS 的逻辑，队列（集合）中的元素越多，扩散之后新的队列（集合）中的元素就越多；在双向 BFS 算法中，如果我们每次都选择一个较小的集合进行扩散，那么占用的空间增长速度就会慢一些，效率就会高一些。

不过话说回来， **无论传统 BFS 还是双向 BFS，无论做不做优化，从 Big O 衡量标准来看，时间复杂度都是一样的** ，只能说双向 BFS 是一种 trick，算法运行的速度会相对快一点，掌握不掌握其实都无所谓。最关键的是把
BFS 通用框架记下来，反正所有 BFS 算法都可以用它套出解法。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**





# 一文搞懂单链表的六大解题套路




** ~

读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 21. 合并两个有序链表（简单） ](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

[ 23. 合并K个升序链表（困难） ](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

[ 141. 环形链表（简单） ](https://leetcode-cn.com/problems/linked-list-cycle/)

[ 142. 环形链表 II（中等） ](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

[ 876. 链表的中间结点（简单） ](https://leetcode-cn.com/problems/middle-of-the-linked-
list/)

[ 160. 相交链表（简单） ](https://leetcode-cn.com/problems/intersection-of-two-linked-
lists/)

[ 19. 删除链表的倒数第 N 个结点（中等） ](https://leetcode-cn.com/problems/remove-nth-node-
from-end-of-list/)

**———–**

上次在视频号直播，跟大家说到单链表有很多巧妙的操作，本文就总结一下单链表的基本技巧，每个技巧都对应着至少一道算法题：

1、合并两个有序链表

2、合并 ` k ` 个有序链表

3、寻找单链表的倒数第 ` k ` 个节点

4、寻找单链表的中点

5、判断单链表是否包含环并找出环起点

6、判断两个单链表是否相交并找出交点

这些解法都用到了双指针技巧，所以说对于单链表相关的题目，双指针的运用是非常广泛的，下面我们就来一个一个看。

## 合并两个有序链表

这是最基本的链表技巧，力扣第 21 题「合并两个有序链表」就是这个问题：

![](https://labuladong.gitee.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/title.jpg)

给你输入两个有序链表，请你把他俩合并成一个新的有序链表，函数签名如下：

```java
    ListNode mergeTwoLists(ListNode l1, ListNode l2);

```

这题比较简单，我们直接看解法：

```java
    ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        // 虚拟头结点
        ListNode dummy = new ListNode(-1), p = dummy;
        ListNode p1 = l1, p2 = l2;
        
        while (p1 != null && p2 != null) {
            // 比较 p1 和 p2 两个指针
            // 将值较小的的节点接到 p 指针
            if (p1.val > p2.val) {
                p.next = p2;
                p2 = p2.next;
            } else {
                p.next = p1;
                p1 = p1.next;
            }
            // p 指针不断前进
            p = p.next;
        }
        
        if (p1 != null) {
            p.next = p1;
        }
        
        if (p2 != null) {
            p.next = p2;
        }
        
        return dummy.next;
    }

```

我们的 while 循环每次比较 ` p1 ` 和 ` p2 ` 的大小，把较小的节点接到结果链表上：

![](https://labuladong.gitee.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/1.gif)

这个算法的逻辑类似于「拉拉链」， ` l1, l2 ` 类似于拉链两侧的锯齿，指针 ` p ` 就好像拉链的拉索，将两个有序链表合并。

**代码中还用到一个链表的算法题中是很常见的「虚拟头结点」技巧，也就是` dummy ` 节点 ** 。你可以试试，如果不使用 ` dummy `
虚拟节点，代码会复杂很多，而有了 ` dummy ` 节点这个占位符，可以避免处理空指针的情况，降低代码的复杂性。

## 合并 k 个有序链表

看下力扣第 23 题「合并K个升序链表」：

![](https://labuladong.gitee.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/title2.jpg)

函数签名如下：

```java
    ListNode mergeKLists(ListNode[] lists);

```

合并 ` k ` 个有序链表的逻辑类似合并两个有序链表，难点在于，如何快速得到 ` k ` 个节点中的最小节点，接到结果链表上？

这里我们就要用到 [ 优先级队列（二叉堆） ](https://labuladong.gitee.io/algo/2/19/50/) 这种数据结构，把链表节点放入一个最小堆，就可以每次获得 ` k `
个节点中的最小节点：

```java
    ListNode mergeKLists(ListNode[] lists) {
        if (lists.length == 0) return null;
        // 虚拟头结点
        ListNode dummy = new ListNode(-1);
        ListNode p = dummy;
        // 优先级队列，最小堆
        PriorityQueue<ListNode> pq = new PriorityQueue<>(
            lists.length, (a, b)->(a.val - b.val));
        // 将 k 个链表的头结点加入最小堆
        for (ListNode head : lists) {
            if (head != null)
                pq.add(head);
        }
    
        while (!pq.isEmpty()) {
            // 获取最小节点，接到结果链表中
            ListNode node = pq.poll();
            p.next = node;
            if (node.next != null) {
                pq.add(node.next);
            }
            // p 指针不断前进
            p = p.next;
        }
        return dummy.next;
    }

```

这个算法是面试常考题，它的时间复杂度是多少呢？

优先队列 ` pq ` 中的元素个数最多是 ` k ` ，所以一次 ` poll ` 或者 ` add ` 方法的时间复杂度是 ` O(logk) `
；所有的链表节点都会被加入和弹出 ` pq ` ， **所以算法整体的时间复杂度是` O(Nlogk) ` ，其中 ` k ` 是链表的条数， ` N `
是这些链表的节点总数 ** 。

## 单链表的倒数第 k 个节点

从前往后寻找单链表的第 ` k ` 个节点很简单，一个 for 循环遍历过去就找到了，但是如何寻找从后往前数的第 ` k ` 个节点呢？

那你可能说，假设链表有 ` n ` 个节点，倒数第 ` k ` 个节点就是正数第 ` n - k ` 个节点，不也是一个 for 循环的事儿吗？

是的，但是算法题一般只给你一个 ` ListNode ` 头结点代表一条单链表，你不能直接得出这条链表的长度 ` n ` ，而需要先遍历一遍链表算出 ` n
` 的值，然后再遍历链表计算第 ` n - k ` 个节点。

也就是说，这个解法需要遍历两次链表才能得到出倒数第 ` k ` 个节点。

那么，我们能不能 **只遍历一次链表** ，就算出倒数第 ` k `
个节点？可以做到的，如果是面试问到这道题，面试官肯定也是希望你给出只需遍历一次链表的解法。

这个解法就比较巧妙了，假设 ` k = 2 ` ，思路如下：

首先，我们先让一个指针 ` p1 ` 指向链表的头节点 ` head ` ，然后走 ` k ` 步：

![](https://labuladong.gitee.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/1.jpeg)

现在的 ` p1 ` ，只要再走 ` n - k ` 步，就能走到链表末尾的空指针了对吧？

趁这个时候，再用一个指针 ` p2 ` 指向链表头节点 ` head ` ：

![](https://labuladong.gitee.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/2.jpeg)

接下来就很显然了，让 ` p1 ` 和 ` p2 ` 同时向前走， ` p1 ` 走到链表末尾的空指针时走了 ` n - k ` 步， ` p2 ` 也走了
` n - k ` 步，也就是链表的倒数第 ` k ` 个节点：

![](https://labuladong.gitee.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/3.jpeg)

这样，只遍历了一次链表，就获得了倒数第 ` k ` 个节点 ` p2 ` 。

上述逻辑的代码如下：

```java
    // 返回链表的倒数第 k 个节点
    ListNode findFromEnd(ListNode head, int k) {
        ListNode p1 = head;
        // p1 先走 k 步
        for (int i = 0; i < k; i++) {
            p1 = p1.next;
        }
        ListNode p2 = head;
        // p1 和 p2 同时走 n - k 步
        while (p1 != null) {
            p2 = p2.next;
            p1 = p1.next;
        }
        // p2 现在指向第 n - k 个节点
        return p2;
    }

```

当然，如果用 big O 表示法来计算时间复杂度，无论遍历一次链表和遍历两次链表的时间复杂度都是 ` O(N) ` ，但上述这个算法更有技巧性。

很多链表相关的算法题都会用到这个技巧，比如说力扣第 19 题「删除链表的倒数第 N 个结点」：

![](https://labuladong.gitee.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/title3.jpg)

我们直接看解法代码：

```java
    // 主函数
    public ListNode removeNthFromEnd(ListNode head, int n) {
        // 虚拟头结点
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        // 删除倒数第 n 个，要先找倒数第 n + 1 个节点
        ListNode x = findFromEnd(dummy, n + 1);
        // 删掉倒数第 n 个节点
        x.next = x.next.next;
        return dummy.next;
    }
        
    private ListNode findFromEnd(ListNode head, int k) {
        // 代码见上文
    }

```

这个逻辑就很简单了，要删除倒数第 ` n ` 个节点，就得获得倒数第 ` n + 1 ` 个节点的引用，可以用我们实现的 ` findFromEnd `
来操作。

不过注意我们又使用了虚拟头结点的技巧，也是为了防止出现空指针的情况，比如说链表总共有 5 个节点，题目就让你删除倒数第 5 个节点，也就是第一个节点，那按照算法逻辑，应该首先找到倒数第 6
个节点。但第一个节点前面已经没有节点了，这就会出错。

但有了我们虚拟节点 ` dummy ` 的存在，就避免了这个问题，能够对这种情况进行正确的删除。

## 单链表的中点

这个技巧在前文 [ 双指针技巧汇总 ](https://labuladong.gitee.io/algo/2/20/55/) 写过，如果看过的读者可以跳过。

力扣第 876 题「链表的中间结点」就是这个题目，问题的关键也在于我们无法直接得到单链表的长度 ` n ` ，常规方法也是先遍历链表计算 ` n `
，再遍历一次得到第 ` n / 2 ` 个节点，也就是中间节点。

如果想一次遍历就得到中间节点，也需要耍点小聪明，使用「快慢指针」的技巧：

我们让两个指针 ` slow ` 和 ` fast ` 分别指向链表头结点 ` head ` 。

**每当慢指针` slow ` 前进一步，快指针 ` fast ` 就前进两步，这样，当 ` fast ` 走到链表末尾时， ` slow `
就指向了链表中点 ** 。

上述思路的代码实现如下：

```java
    ListNode middleNode(ListNode head) {
        // 快慢指针初始化指向 head
        ListNode slow = head, fast = head;
        // 快指针走到末尾时停止
        while (fast != null && fast.next != null) {
            // 慢指针走一步，快指针走两步
            slow = slow.next;
            fast = fast.next.next;
        }
        // 慢指针指向中点
        return slow;
    }

```

需要注意的是，如果链表长度为偶数，也就是说中点有两个的时候，我们这个解法返回的节点是靠后的那个节点。

另外，这段代码稍加修改就可以直接用到判断链表成环的算法题上。

## 判断链表是否包含环

这个技巧也在前文 [ 双指针技巧汇总 ](https://labuladong.gitee.io/algo/2/20/55/) 写过，如果看过的读者可以跳过。

判断链表是否包含环属于经典问题了，解决方案也是用快慢指针：

每当慢指针 ` slow ` 前进一步，快指针 ` fast ` 就前进两步。

如果 ` fast ` 最终遇到空指针，说明链表中没有环；如果 ` fast ` 最终和 ` slow ` 相遇，那肯定是 ` fast ` 超过了 `
slow ` 一圈，说明链表中含有环。

只需要把寻找链表中点的代码稍加修改就行了：

```java
    boolean hasCycle(ListNode head) {
        // 快慢指针初始化指向 head
        ListNode slow = head, fast = head;
        // 快指针走到末尾时停止
        while (fast != null && fast.next != null) {
            // 慢指针走一步，快指针走两步
            slow = slow.next;
            fast = fast.next.next;
            // 快慢指针相遇，说明含有环
            if (slow == fast) {
                return true;
            }
        }
        // 不包含环
        return false;
    }

```

当然，这个问题还有进阶版：如果链表中含有环，如何计算这个环的起点？

这里简单提一下解法：

```java
    ListNode detectCycle(ListNode head) {
        ListNode fast, slow;
        fast = slow = head;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
            if (fast == slow) break;
        }
        // 上面的代码类似 hasCycle 函数
        if (fast == null || fast.next == null) {
            // fast 遇到空指针说明没有环
            return null;
        }
    
        // 重新指向头结点
        slow = head;
        // 快慢指针同步前进，相交点就是环起点
        while (slow != fast) {
            fast = fast.next;
            slow = slow.next;
        }
        return slow;
    }

```

可以看到，当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。

前文 [ 双指针技巧汇总 ](https://labuladong.gitee.io/algo/2/20/55/) 详细解释了其中的原理，这里简单说一下。

我们假设快慢指针相遇时，慢指针 ` slow ` 走了 ` k ` 步，那么快指针 ` fast ` 一定走了 ` 2k ` 步：

![](https://labuladong.gitee.io/algo/images/%E5%8F%8C%E6%8C%87%E9%92%88/3.jpeg)

` fast ` 一定比 ` slow ` 多走了 ` k ` 步，这多走的 ` k ` 步其实就是 ` fast ` 指针在环里转圈圈，所以 ` k `
的值就是环长度的「整数倍」。

假设相遇点距环的起点的距离为 ` m ` ，那么结合上图的 ` slow ` 指针，环的起点距头结点 ` head ` 的距离为 ` k - m `
，也就是说如果从 ` head ` 前进 ` k - m ` 步就能到达环起点。

巧的是，如果从相遇点继续前进 ` k - m ` 步，也恰好到达环起点。因为结合上图的 ` fast ` 指针，从相遇点开始走k步可以转回到相遇点，那走 `
k - m ` 步肯定就走到环起点了：

![](https://labuladong.gitee.io/algo/images/%E5%8F%8C%E6%8C%87%E9%92%88/2.jpeg)

所以，只要我们把快慢指针中的任一个重新指向 ` head ` ，然后两个指针同速前进， ` k - m ` 步后一定会相遇，相遇之处就是环的起点了。

## 两个链表是否相交

这个问题有意思，也是力扣第 160 题「相交链表」函数签名如下：

```java
    ListNode getIntersectionNode(ListNode headA, ListNode headB);

```

给你输入两个链表的头结点 ` headA ` 和 ` headB ` ，这两个链表可能存在相交。

如果相交，你的算法应该返回相交的那个节点；如果没相交，则返回 null。

比如题目给我们举的例子，如果输入的两个链表如下图：

![](https://labuladong.gitee.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/4.png)

那么我们的算法应该返回 ` c1 ` 这个节点。

这个题直接的想法可能是用 ` HashSet ` 记录一个链表的所有节点，然后和另一条链表对比，但这就需要额外的空间。

如果不用额外的空间，只使用两个指针，你如何做呢？

难点在于，由于两条链表的长度可能不同，两条链表之间的节点无法对应：

![](https://labuladong.gitee.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/5.jpeg)

如果用两个指针 ` p1 ` 和 ` p2 ` 分别在两条链表上前进，并不能 **同时** 走到公共节点，也就无法得到相交节点 ` c1 ` 。

**解决这个问题的关键是，通过某些方式，让` p1 ` 和 ` p2 ` 能够同时到达相交节点 ` c1 ` ** 。

所以，我们可以让 ` p1 ` 遍历完链表 ` A ` 之后开始遍历链表 ` B ` ，让 ` p2 ` 遍历完链表 ` B ` 之后开始遍历链表 ` A
` ，这样相当于「逻辑上」两条链表接在了一起。

如果这样进行拼接，就可以让 ` p1 ` 和 ` p2 ` 同时进入公共部分，也就是同时到达相交节点 ` c1 ` ：

![](https://labuladong.gitee.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/6.jpeg)

那你可能会问，如果说两个链表没有相交点，是否能够正确的返回 null 呢？

这个逻辑可以覆盖这种情况的，相当于 ` c1 ` 节点是 null 空指针嘛，可以正确返回 null。

按照这个思路，可以写出如下代码：

```java
    ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        // p1 指向 A 链表头结点，p2 指向 B 链表头结点
        ListNode p1 = headA, p2 = headB;
        while (p1 != p2) {
            // p1 走一步，如果走到 A 链表末尾，转到 B 链表
            if (p1 == null) p1 = headB;
            else            p1 = p1.next;
            // p2 走一步，如果走到 B 链表末尾，转到 A 链表
            if (p2 == null) p2 = headA;
            else            p2 = p2.next;
        }
        return p1;
    }

```

这样，这道题就解决了，空间复杂度为 ` O(1) ` ，时间复杂度为 ` O(N) ` 。

以上就是单链表的所有技巧，希望对你有启发。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**





# 一文秒杀所有岛屿题目




** ~

读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 200. 岛屿数量（中等） ](https://leetcode-cn.com/problems/number-of-islands)

[ 1254. 统计封闭岛屿的数目（中等） ](https://leetcode-cn.com/problems/number-of-closed-
islands)

[ 1020. 飞地的数量（中等） ](https://leetcode-cn.com/problems/number-of-enclaves)

[ 695. 岛屿的最大面积（中等） ](https://leetcode-cn.com/problems/max-area-of-island)

[ 1905. 统计子岛屿（中等） ](https://leetcode-cn.com/problems/count-sub-islands)

[ 694. 不同的岛屿数量（中等） ](https://leetcode-cn.com/problems/number-of-distinct-
islands)

**———–**

岛屿系列算法问题是经典的面试高频题，虽然基本的问题并不难，但是这类问题有一些有意思的扩展，比如求子岛屿数量，求形状不同的岛屿数量等等，本文就来把这些问题一网打尽。

**岛屿系列题目的核心考点就是用 DFS/BFS 算法遍历二维数组** 。

本文主要来讲解如何用 DFS 算法来秒杀岛屿系列题目，不过用 BFS 算法的核心思路是完全一样的，无非就是把 DFS 改写成 BFS 而已。

那么如何在二维矩阵中使用 DFS 搜索呢？如果你把二维矩阵中的每一个位置看做一个节点，这个节点的上下左右四个位置就是相邻节点，那么整个矩阵就可以抽象成一幅网状的「图」结构。

根据 [ 学习数据结构和算法的框架思维 ](https://labuladong.gitee.io/algo/1/2/) ，完全可以根据二叉树的遍历框架改写出二维矩阵的 DFS 代码框架：

```java
    // 二叉树遍历框架
    void traverse(TreeNode root) {
        traverse(root.left);
        traverse(root.right);
    }
    
    // 二维矩阵遍历框架
    void dfs(int[][] grid, int i, int j, boolean[] visited) {
        int m = grid.length, n = grid[0].length;
        if (i < 0 || j < 0 || i >= m || j >= n) {
            // 超出索引边界
            return;
        }
        if (visited[i][j]) {
            // 已遍历过 (i, j)
            return;
        }
        // 进入节点 (i, j)
        visited[i][j] = true;
        dfs(grid, i - 1, j); // 上
        dfs(grid, i + 1, j); // 下
        dfs(grid, i, j - 1); // 左
        dfs(grid, i, j + 1); // 右
    }

```

因为二维矩阵本质上是一幅「图」，所以遍历的过程中需要一个 ` visited `
布尔数组防止走回头路，如果你能理解上面这段代码，那么搞定所有岛屿系列题目都很简单。

这里额外说一个处理二维数组的常用小技巧，你有时会看到使用「方向数组」来处理上下左右的遍历，和前文 [ 图遍历框架 ](https://labuladong.gitee.io/algo/2/18/34/)
的代码很类似：

```java
    // 方向数组，分别代表上、下、左、右
    int[][] dirs = new int[][]{{-1,0}, {1,0}, {0,-1}, {0,1}};
    
    void dfs(int[][] grid, int i, int j, boolean[] visited) {
        int m = grid.length, n = grid[0].length;
        if (i < 0 || j < 0 || i >= m || j >= n) {
            // 超出索引边界
            return;
        }
        if (visited[i][j]) {
            // 已遍历过 (i, j)
            return;
        }
    
        // 进入节点 (i, j)
        visited[i][j] = true;
        // 递归遍历上下左右的节点
        for (int[] d : dirs) {
            int next_i = i + d[0];
            int next_j = j + d[1];
            dfs(grid, next_i, next_j);
        }
        // 离开节点 (i, j)
    }

```

这种写法无非就是用 for 循环处理上下左右的遍历罢了，你可以按照个人喜好选择写法。

## 岛屿数量

这是力扣第 200 题「岛屿数量」，最简单也是最经典的一道问题，题目会输入一个二维数组 ` grid ` ，其中只包含 ` 0 ` 或者 ` 1 ` ， `
0 ` 代表海水， ` 1 ` 代表陆地，且假设该矩阵四周都是被海水包围着的。

我们说连成片的陆地形成岛屿，那么请你写一个算法，计算这个矩阵 ` grid ` 中岛屿的个数，函数签名如下：

```java
    int numIslands(char[][] grid);

```

比如说题目给你输入下面这个 ` grid ` 有四片岛屿，算法应该返回 4：

![](https://labuladong.gitee.io/algo/images/%e5%b2%9b%e5%b1%bf/1.jpg)

思路很简单，关键在于如何寻找并标记「岛屿」，这就要 DFS 算法发挥作用了，我们直接看解法代码：

```java
    // 主函数，计算岛屿数量
    int numIslands(char[][] grid) {
        int res = 0;
        int m = grid.length, n = grid[0].length;
        // 遍历 grid
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == '1') {
                    // 每发现一个岛屿，岛屿数量加一
                    res++;
                    // 然后使用 DFS 将岛屿淹了
                    dfs(grid, i, j);
                }
            }
        }
        return res;
    }
    
    // 从 (i, j) 开始，将与之相邻的陆地都变成海水
    void dfs(char[][] grid, int i, int j) {
        int m = grid.length, n = grid[0].length;
        if (i < 0 || j < 0 || i >= m || j >= n) {
            // 超出索引边界
            return;
        }
        if (grid[i][j] == '0') {
            // 已经是海水了
            return;
        }
        // 将 (i, j) 变成海水
        grid[i][j] = '0';
        // 淹没上下左右的陆地
        dfs(grid, i + 1, j);
        dfs(grid, i, j + 1);
        dfs(grid, i - 1, j);
        dfs(grid, i, j - 1);
    }

```

**为什么每次遇到岛屿，都要用 DFS 算法把岛屿「淹了」呢？主要是为了省事，避免维护` visited ` 数组 ** 。

因为 ` dfs ` 函数遍历到值为 ` 0 ` 的位置会直接返回，所以只要把经过的位置都设置为 ` 0 ` ，就可以起到不走回头路的作用。

> PS：这类 DFS 算法还有个别名叫做 [ FloodFill 算法
> 
> ](https://mp.weixin.qq.com/s/Y7snQIraCC6PRhj9ZSnlzw) ，现在有没有觉得 FloodFill
> 这个名字还挺贴切的~

这个最最基本的算法问题就说到这，我们来看看后面的题目有什么花样。

## 封闭岛屿的数量

上一题说二维矩阵四周可以认为也是被海水包围的，所以靠边的陆地也算作岛屿。

力扣第 1254 题「统计封闭岛屿的数目」和上一题有两点不同：

1、用 ` 0 ` 表示陆地，用 ` 1 ` 表示海水。

2、让你计算「封闭岛屿」的数目。所谓「封闭岛屿」就是上下左右全部被 ` 1 ` 包围的 ` 0 ` ，也就是说 **靠边的陆地不算作「封闭岛屿」** 。

函数签名如下：

```java
    int closedIsland(int[][] grid)

```

比如题目给你输入如下这个二维矩阵：

![](https://labuladong.gitee.io/algo/images/%e5%b2%9b%e5%b1%bf/2.png)

算法返回 2，只有图中灰色部分的 ` 0 ` 是四周全都被海水包围着的「封闭岛屿」。

**那么如何判断「封闭岛屿」呢？其实很简单，把上一题中那些靠边的岛屿排除掉，剩下的不就是「封闭岛屿」了吗** ？

有了这个思路，就可以直接看代码了，注意这题规定 ` 0 ` 表示陆地，用 ` 1 ` 表示海水：

```java
    // 主函数：计算封闭岛屿的数量
    int closedIsland(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        for (int j = 0; j < n; j++) {
            // 把靠上边的岛屿淹掉
            dfs(grid, 0, j);
            // 把靠下边的岛屿淹掉
            dfs(grid, m - 1, j);
        }
        for (int i = 0; i < m; i++) {
            // 把靠左边的岛屿淹掉
            dfs(grid, i, 0);
            // 把靠右边的岛屿淹掉
            dfs(grid, i, n - 1);
        }
        // 遍历 grid，剩下的岛屿都是封闭岛屿
        int res = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 0) {
                    res++;
                    dfs(grid, i, j);
                }
            }
        }
        return res;
    }
    
    // 从 (i, j) 开始，将与之相邻的陆地都变成海水
    void dfs(int[][] grid, int i, int j) {
        int m = grid.length, n = grid[0].length;
        if (i < 0 || j < 0 || i >= m || j >= n) {
            return;
        }
        if (grid[i][j] == 1) {
            // 已经是海水了
            return;
        }
        // 将 (i, j) 变成海水
        grid[i][j] = 1;
        // 淹没上下左右的陆地
        dfs(grid, i + 1, j);
        dfs(grid, i, j + 1);
        dfs(grid, i - 1, j);
        dfs(grid, i, j - 1);
    }

```

只要提前把靠边的陆地都淹掉，然后算出来的就是封闭岛屿了。

> PS：处理这类岛屿题目除了 DFS/BFS 算法之外，Union Find 并查集算法也是一种可选的方法，前文 [ Union Find 算法运用
> 
> ](https://labuladong.gitee.io/algo/2/18/38/) 就用 Union Find 算法解决了一道类似的问题。

这道岛屿题目的解法稍微改改就可以解决力扣第 1020 题「飞地的数量」，这题不让你求封闭岛屿的数量，而是求封闭岛屿的面积总和。

其实思路都是一样的，先把靠边的陆地淹掉，然后去数剩下的陆地数量就行了，注意第 1020 题中 ` 1 ` 代表陆地， ` 0 ` 代表海水：

```java
    int numEnclaves(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        // 淹掉靠边的陆地
        for (int i = 0; i < m; i++) {
            dfs(grid, i, 0);
            dfs(grid, i, n - 1);
        }
        for (int j = 0; j < n; j++) {
            dfs(grid, 0, j);
            dfs(grid, m - 1, j);
        }
    
        // 数一数剩下的陆地
        int res = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    res += 1;
                }
            }
        }
    
        return res;
    }
    
    // 和之前的实现类似
    void dfs(int[][] grid, int i, int j) {
        // ...
    }

```

篇幅所限，具体代码我就不写了，我们继续看其他的岛屿题目。

## 岛屿的最大面积

这是力扣第 695 题「岛屿的最大面积」， ` 0 ` 表示海水， ` 1 `
表示陆地，现在不让你计算岛屿的个数了，而是让你计算最大的那个岛屿的面积，函数签名如下：

```java
    int maxAreaOfIsland(int[][] grid)

```

比如题目给你输入如下一个二维矩阵：

![](https://labuladong.gitee.io/algo/images/%e5%b2%9b%e5%b1%bf/3.jpg)

其中面积最大的是橘红色的岛屿，算法返回它的面积 6。

**这题的大体思路和之前完全一样，只不过` dfs ` 函数淹没岛屿的同时，还应该想办法记录这个岛屿的面积 ** 。

我们可以给 ` dfs ` 函数设置返回值，记录每次淹没的陆地的个数，直接看解法吧：

```java
    int maxAreaOfIsland(int[][] grid) {
        // 记录岛屿的最大面积
        int res = 0;
        int m = grid.length, n = grid[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    // 淹没岛屿，并更新最大岛屿面积
                    res = Math.max(res, dfs(grid, i, j));
                }
            }
        }
        return res;
    }
    
    // 淹没与 (i, j) 相邻的陆地，并返回淹没的陆地面积
    int dfs(int[][] grid, int i, int j) {
        int m = grid.length, n = grid[0].length;
        if (i < 0 || j < 0 || i >= m || j >= n) {
            // 超出索引边界
            return 0;
        }
        if (grid[i][j] == 0) {
            // 已经是海水了
            return 0;
        }
        // 将 (i, j) 变成海水
        grid[i][j] = 0;
    
        return dfs(grid, i + 1, j)
             + dfs(grid, i, j + 1)
             + dfs(grid, i - 1, j)
             + dfs(grid, i, j - 1) + 1;
    }

```

解法和之前相比差不多，我也不多说了，接下来的两道岛屿题目是比较有技巧性的，我们重点来看一下。

## 子岛屿数量

如果说前面的题目都是模板题，那么力扣第 1905 题「统计子岛屿」可能得动动脑子了：

![](https://labuladong.gitee.io/algo/images/%e5%b2%9b%e5%b1%bf/4.jpg)

**这道题的关键在于，如何快速判断子岛屿** ？肯定可以借助 [ Union Find 并查集算法 ](https://labuladong.gitee.io/algo/2/18/37/)
来判断，不过本文重点在 DFS 算法，就不展开并查集算法了。

什么情况下 ` grid2 ` 中的一个岛屿 ` B ` 是 ` grid1 ` 中的一个岛屿 ` A ` 的子岛？

当岛屿 ` B ` 中所有陆地在岛屿 ` A ` 中也是陆地的时候，岛屿 ` B ` 是岛屿 ` A ` 的子岛。

**反过来说，如果岛屿` B ` 中存在一片陆地，在岛屿 ` A ` 的对应位置是海水，那么岛屿 ` B ` 就不是岛屿 ` A ` 的子岛 ** 。

那么，我们只要遍历 ` grid2 ` 中的所有岛屿，把那些不可能是子岛的岛屿排除掉，剩下的就是子岛。

依据这个思路，可以直接写出下面的代码：

```java
    int countSubIslands(int[][] grid1, int[][] grid2) {
        int m = grid1.length, n = grid1[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid1[i][j] == 0 && grid2[i][j] == 1) {
                    // 这个岛屿肯定不是子岛，淹掉
                    dfs(grid2, i, j);
                }
            }
        }
        // 现在 grid2 中剩下的岛屿都是子岛，计算岛屿数量
        int res = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid2[i][j] == 1) {
                    res++;
                    dfs(grid2, i, j);
                }
            }
        }
        return res;
    }
    
    // 从 (i, j) 开始，将与之相邻的陆地都变成海水
    void dfs(int[][] grid, int i, int j) {
        int m = grid.length, n = grid[0].length;
        if (i < 0 || j < 0 || i >= m || j >= n) {
            return;
        }
        if (grid[i][j] == 0) {
            return;
        }
    
        grid[i][j] = 0;
        dfs(grid, i + 1, j);
        dfs(grid, i, j + 1);
        dfs(grid, i - 1, j);
        dfs(grid, i, j - 1);
    }

```

这道题的思路和计算「封闭岛屿」数量的思路有些类似，只不过后者排除那些靠边的岛屿，前者排除那些不可能是子岛的岛屿。

## 不同的岛屿数量

这是本文的最后一道岛屿题目，作为压轴题，当然是最有意思的。

力扣第 694 题「不同的岛屿数量」，题目还是输入一个二维矩阵， ` 0 ` 表示海水， ` 1 ` 表示陆地，这次让你计算 **不同的
(distinct)** 岛屿数量，函数签名如下：

```java
    int numDistinctIslands(int[][] grid)

```

比如题目输入下面这个二维矩阵：

![](https://labuladong.gitee.io/algo/images/%e5%b2%9b%e5%b1%bf/5.jpg)

其中有四个岛屿，但是左下角和右上角的岛屿形状相同，所以不同的岛屿共有三个，算法返回 3。

很显然我们得想办法把二维矩阵中的「岛屿」进行转化，变成比如字符串这样的类型，然后利用 HashSet 这样的数据结构去重，最终得到不同的岛屿的个数。

如果想把岛屿转化成字符串，说白了就是序列化，序列化说白了就是遍历嘛，前文 [ 二叉树的序列化和反序列化 ](https://labuladong.gitee.io/algo/2/17/28/)
讲了二叉树和字符串互转，这里也是类似的。

**首先，对于形状相同的岛屿，如果从同一起点出发，` dfs ` 函数遍历的顺序肯定是一样的 ** 。

因为遍历顺序是写死在你的递归函数里面的，不会动态改变：

```java
    void dfs(int[][] grid, int i, int j) {
        // 递归顺序：
        dfs(grid, i - 1, j); // 上
        dfs(grid, i + 1, j); // 下
        dfs(grid, i, j - 1); // 左
        dfs(grid, i, j + 1); // 右
    }

```

所以，遍历顺序从某种意义上说就可以用来描述岛屿的形状，比如下图这两个岛屿：

![](https://labuladong.gitee.io/algo/images/%e5%b2%9b%e5%b1%bf/6.png)

假设它们的遍历顺序是：

> 下，右，上，撤销上，撤销右，撤销下

如果我用分别用 ` 1, 2, 3, 4 ` 代表上下左右，用 ` -1, -2, -3, -4 ` 代表上下左右的撤销，那么可以这样表示它们的遍历顺序：

> 2, 4, 1, -1, -4, -2

**你看，这就相当于是岛屿序列化的结果，只要每次使用` dfs ` 遍历岛屿的时候生成这串数字进行比较，就可以计算到底有多少个不同的岛屿了 ** 。

我们需要稍微改造 ` dfs ` 函数，添加一些函数参数以便记录遍历顺序：

```java
    void dfs(int[][] grid, int i, int j, StringBuilder sb, int dir) {
        int m = grid.length, n = grid[0].length;
        if (i < 0 || j < 0 || i >= m || j >= n 
            || grid[i][j] == 0) {
            return;
        }
        // 前序遍历位置：进入 (i, j)
        grid[i][j] = 0;
        sb.append(dir).append(',');
        
        dfs(grid, i - 1, j, sb, 1); // 上
        dfs(grid, i + 1, j, sb, 2); // 下
        dfs(grid, i, j - 1, sb, 3); // 左
        dfs(grid, i, j + 1, sb, 4); // 右
        
        // 后序遍历位置：离开 (i, j)
        sb.append(-dir).append(',');
    }

```

` dir ` 记录方向， ` dfs ` 函数递归结束后， ` sb ` 记录着整个遍历顺序，其实这就是前文 [ 回溯算法核心套路

](https://labuladong.gitee.io/algo/4/28/105/) 说到的回溯算法框架，你看到头来这些算法都是相通的。

有了这个 ` dfs ` 函数就好办了，我们可以直接写出最后的解法代码：

```java
    int numDistinctIslands(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        // 记录所有岛屿的序列化结果
        HashSet<String> islands = new HashSet<>();
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    // 淹掉这个岛屿，同时存储岛屿的序列化结果
                    StringBuilder sb = new StringBuilder();
                    // 初始的方向可以随便写，不影响正确性
                    dfs(grid, i, j, sb, 666);
                    islands.add(sb.toString());
                }
            }
        }
        // 不相同的岛屿数量
        return islands.size();
    }

```

这样，这道题就解决了，至于为什么初始调用 ` dfs ` 函数时的 ` dir ` 参数可以随意写，这里涉及 DFS 和回溯算法的一个细微差别，前文 [
图算法基础 ](https://labuladong.gitee.io/algo/2/18/34/) 有写，这里就不展开了。

以上就是全部岛屿系列题目的解题思路，也许前面的题目大部分人会做，但是最后两题还是比较巧妙的，希望本文对你有帮助。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**





# 我写了首诗，让你闭着眼睛也能写对二分搜索




** ~

读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 704. 二分查找（简单） ](https://leetcode-cn.com/problems/binary-search)

[ 34. 在排序数组中查找元素的第一个和最后一个位置（中等） ](https://leetcode-cn.com/problems/find-first-
and-last-position-of-element-in-sorted-array/)

**———–**

本文是前文 [ 二分搜索详解 ](https://mp.weixin.qq.com/s/uA2suoVykENmCQcKFMOSuQ)
的修订版，添加了对二分搜索算法更详细的分析。

先给大家讲个笑话乐呵一下：

有一天阿东到图书馆借了 N
本书，出图书馆的时候，警报响了，于是保安把阿东拦下，要检查一下哪本书没有登记出借。阿东正准备把每一本书在报警器下过一下，以找出引发警报的书，但是保安露出不屑的眼神：你连二分查找都不会吗？于是保安把书分成两堆，让第一堆过一下报警器，报警器响；于是再把这堆书分成两堆……
最终，检测了 logN 次之后，保安成功的找到了那本引起警报的书，露出了得意和嘲讽的笑容。于是阿东背着剩下的书走了。

从此，图书馆丢了 N - 1 本书。

二分查找并不简单，Knuth 大佬（发明 KMP 算法的那位）都说二分查找： **思路很简单，细节是魔鬼** 。很多人喜欢拿整型溢出的 bug 说事儿，但是二分查找真正的坑根本就不是那个细节问题，而是在于到底要给 ` mid `
加一还是减一，while 里到底用 ` <= ` 还是 ` < ` 。

你要是没有正确理解这些细节，写二分肯定就是玄学编程，有没有 bug 只能靠菩萨保佑。 **我特意写了一首诗来歌颂该算法，概括本文的主要内容，建议保存** ：

![](https://labuladong.gitee.io/algo/images/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/poem.png)

本文就来探究几个最常用的二分查找场景：寻找一个数、寻找左侧边界、寻找右侧边界。而且，我们就是要深入细节，比如不等号是否应该带等号，mid 是否应该加一等等。分析这些细节的差异以及出现这些差异的原因，保证你能灵活准确地写出正确的二分查找算法。

## 零、二分查找框架

```java
    int binarySearch(int[] nums, int target) {
        int left = 0, right = ...;
    
        while(...) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                ...
            } else if (nums[mid] < target) {
                left = ...
            } else if (nums[mid] > target) {
                right = ...
            }
        }
        return ...;
    }

```

**分析二分查找的一个技巧是：不要出现 else，而是把所有情况用 else if 写清楚，这样可以清楚地展现所有细节** 。本文都会使用 else if，旨在讲清楚，读者理解后可自行简化。

其中 ` ... ` 标记的部分，就是可能出现细节问题的地方，当你见到一个二分查找的代码时，首先注意这几个地方。后文用实例分析这些地方能有什么样的变化。

另外声明一下，计算 mid 时需要防止溢出，代码中 ` left + (right - left) / 2 ` 就和 ` (left + right) / 2 ` 的结果相同，但是有效防止了 ` left ` 和 ` right `
太大直接相加导致溢出。

## 一、寻找一个数（基本的二分搜索）

这个场景是最简单的，可能也是大家最熟悉的，即搜索一个数，如果存在，返回其索引，否则返回 -1。

```java
    int binarySearch(int[] nums, int target) {
        int left = 0; 
        int right = nums.length - 1; // 注意
    
        while(left <= right) {
            int mid = left + (right - left) / 2;
            if(nums[mid] == target)
                return mid; 
            else if (nums[mid] < target)
                left = mid + 1; // 注意
            else if (nums[mid] > target)
                right = mid - 1; // 注意
        }
        return -1;
    }

```

**1、为什么 while 循环的条件中是 <=，而不是 < ** ？

答：因为初始化 ` right ` 的赋值是 ` nums.length - 1 ` ，即最后一个元素的索引，而不是 ` nums.length ` 。

这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 ` [left, right] ` ，后者相当于左闭右开区间 ` [left, right) ` ，因为索引大小为 ` nums.length ` 是越界的。

我们这个算法中使用的是前者 ` [left, right] ` 两端都闭的区间。 **这个区间其实就是每次进行搜索的区间** 。

什么时候应该停止搜索呢？当然，找到了目标值的时候可以终止：

```java
        if(nums[mid] == target)
            return mid; 

```

但如果没找到，就需要 while 循环终止，然后返回 -1。那 while 循环什么时候应该终止？ **搜索区间为空的时候应该终止**
，意味着你没得找了，就等于没找到嘛。

` while(left <= right) ` 的终止条件是 ` left == right + 1 ` ，写成区间的形式就是 ` [right + 1, right] ` ，或者带个具体的数字进去 ` [3, 2] ` ，可见 **
这时候区间为空** ，因为没有数字既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。

` while(left < right) ` 的终止条件是 ` left == right ` ，写成区间的形式就是 ` [right, right] `
，或者带个具体的数字进去 ` [2, 2] ` ， **这时候区间非空** ，还有一个数 2，但此时 while 循环终止了。也就是说这区间 ` [2, 2] ` 被漏掉了，索引 2 没有被搜索，如果这时候直接返回 -1 就是错误的。

当然，如果你非要用 ` while(left < right) ` 也可以，我们已经知道了出错的原因，就打个补丁好了：

```java
        //...
        while(left < right) {
            // ...
        }
        return nums[left] == target ? left : -1;

```

**2、为什么` left = mid + 1 ` ， ` right = mid - 1 ` ？我看有的代码是 ` right = mid ` 或者 `
left = mid ` ，没有这些加加减减，到底怎么回事，怎么判断 ** ？

答：这也是二分查找的一个难点，不过只要你能理解前面的内容，就能够很容易判断。

刚才明确了「搜索区间」这个概念，而且本算法的搜索区间是两端都闭的，即 ` [left, right] ` 。那么当我们发现索引 ` mid ` 不是要找的
` target ` 时，下一步应该去搜索哪里呢？

当然是去搜索 ` [left, mid-1] ` 或者 ` [mid+1, right] ` 对不对？ **因为` mid `
已经搜索过，应该从搜索区间中去除 ** 。

**3、此算法有什么缺陷** ？

答：至此，你应该已经掌握了该算法的所有细节，以及这样处理的原因。但是，这个算法存在局限性。

比如说给你有序数组 ` nums = [1,2,2,2,3] ` ， ` target ` 为 2，此算法返回的索引是 2，没错。但是如果我想得到 `
target ` 的左侧边界，即索引 1，或者我想得到 ` target ` 的右侧边界，即索引 3，这样的话此算法是无法处理的。

这样的需求很常见， **你也许会说，找到一个` target ` ，然后向左或向右线性搜索不行吗？可以，但是不好，因为这样难以保证二分查找对数级的复杂度了

** 。

我们后续的算法就来讨论这两种二分查找的算法。

## 二、寻找左侧边界的二分搜索

以下是最常见的代码形式，其中的标记是需要注意的细节：

```java
    int left_bound(int[] nums, int target) {
        if (nums.length == 0) return -1;
        int left = 0;
        int right = nums.length; // 注意
        
        while (left < right) { // 注意
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                right = mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid; // 注意
            }
        }
        return left;
    }

```

**1、为什么 while 中是` < ` 而不是 ` <= ` ** ?

答：用相同的方法分析，因为 ` right = nums.length ` 而不是 ` nums.length - 1 ` 。因此每次循环的「搜索区间」是
` [left, right) ` 左闭右开。

` while(left < right) ` 终止的条件是 ` left == right ` ，此时搜索区间 ` [left, left) `
为空，所以可以正确终止。

> PS：这里先要说一个搜索左右边界和上面这个算法的一个区别，也是很多读者问的： **刚才的` right ` 不是 ` nums.length - 1 `
> 吗，为啥这里非要写成 ` nums.length ` 使得「搜索区间」变成左闭右开呢 ** ？

因为对于搜索左右侧边界的二分查找，这种写法比较普遍，我就拿这种写法举例了，保证你以后遇到这类代码可以理解。你非要用两端都闭的写法反而更简单，我会在后面写相关的代码，把三种二分搜索都用一种两端都闭的写法统一起来，你耐心往后看就行了。

**2、为什么没有返回 -1 的操作？如果` nums ` 中不存在 ` target ` 这个值，怎么办 ** ？

答：因为要一步一步来，先理解一下这个「左侧边界」有什么特殊含义：

![](https://labuladong.gitee.io/algo/images/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/1.jpg)

对于这个数组，算法会返回索引 1。

这个索引 1 的含义可以解读为「 ` nums ` 中小于 2 的元素有 1 个」。

比如对于有序数组 ` nums = [2,3,5,7] ` , ` target = 1 ` ，算法会返回 0，含义是： ` nums ` 中小于 1 的元素有 0 个。

再比如说 ` nums = [2,3,5,7], target = 8 ` ，算法会返回 4，含义是： ` nums ` 中小于 8 的元素有 4 个。

> PS：对于 ` target ` 不存在 ` nums ` 中的情况，函数的返回值还可以有多种理解方式，详见 [ 随机权重算法
> 
> ](https://mp.weixin.qq.com/s/_5t0RSqUzErWUYYb-w0MMw) 中对二分搜索的运用。

综上可以看出，函数的返回值（即 ` left ` 变量的值）取值区间是闭区间 ` [0, nums.length] `
，所以我们简单添加两行代码就能在正确的时候 return -1：

```java
    while (left < right) {
        //...
    }
    // target 比所有数都大
    if (left == nums.length) return -1;
    // 类似之前算法的处理方式
    return nums[left] == target ? left : -1;

```

**3、为什么` left = mid + 1 ` ， ` right = mid ` ？和之前的算法不一样 ** ？

答：这个很好解释，因为我们的「搜索区间」是 ` [left, right) ` 左闭右开，所以当 ` nums[mid] `
被检测之后，下一步的搜索区间应该去掉 ` mid ` 分割成两个区间，即 ` [left, mid) ` 或 ` [mid + 1, right) ` 。

**4、为什么该算法能够搜索左侧边界** ？

答：关键在于对于 ` nums[mid] == target ` 这种情况的处理：

```java
        if (nums[mid] == target)
            right = mid;

```

可见，找到 target 时不要立即返回，而是缩小「搜索区间」的上界 ` right ` ，在区间 ` [left, mid) `
中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。

**5、为什么返回` left ` 而不是 ` right ` ** ？

答：都是一样的，因为 while 终止的条件是 ` left == right ` 。

**6、能不能想办法把` right ` 变成 ` nums.length - 1 `
，也就是继续使用两边都闭的「搜索区间」？这样就可以和第一种二分搜索在某种程度上统一起来了 ** 。

答：当然可以，只要你明白了「搜索区间」这个概念，就能有效避免漏掉元素，随便你怎么改都行。下面我们严格根据逻辑来修改：

因为你非要让搜索区间两端都闭，所以 ` right ` 应该初始化为 ` nums.length - 1 ` ，while 的终止条件应该是 ` left == right + 1 ` ，也就是其中应该用 ` <= ` ：

```java
    int left_bound(int[] nums, int target) {
        // 搜索区间为 [left, right]
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            // if else ...
        }

```

因为搜索区间是两端都闭的，且现在是搜索左侧边界，所以 ` left ` 和 ` right ` 的更新逻辑如下：

```java
    if (nums[mid] < target) {
        // 搜索区间变为 [mid+1, right]
        left = mid + 1;
    } else if (nums[mid] > target) {
        // 搜索区间变为 [left, mid-1]
        right = mid - 1;
    } else if (nums[mid] == target) {
        // 收缩右侧边界
        right = mid - 1;
    }

```

由于 while 的退出条件是 ` left == right + 1 ` ，所以当 ` target ` 比 ` nums `
中所有元素都大时，会存在以下情况使得索引越界：

![](https://labuladong.gitee.io/algo/images/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/2.jpg)

因此，最后返回结果的代码应该检查越界情况：

```java
    if (left >= nums.length || nums[left] != target)
        return -1;
    return left;

```

至此，整个算法就写完了，完整代码如下：

```java
    int left_bound(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        // 搜索区间为 [left, right]
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                // 搜索区间变为 [mid+1, right]
                left = mid + 1;
            } else if (nums[mid] > target) {
                // 搜索区间变为 [left, mid-1]
                right = mid - 1;
            } else if (nums[mid] == target) {
                // 收缩右侧边界
                right = mid - 1;
            }
        }
        // 检查出界情况
        if (left >= nums.length || nums[left] != target)
            return -1;
        return left;
    }

```

这样就和第一种二分搜索算法统一了，都是两端都闭的「搜索区间」，而且最后返回的也是 ` left `
变量的值。只要把住二分搜索的逻辑，两种形式大家看自己喜欢哪种记哪种吧。

## 三、寻找右侧边界的二分查找

类似寻找左侧边界的算法，这里也会提供两种写法，还是先写常见的左闭右开的写法，只有两处和搜索左侧边界不同，已标注：

```java
    int right_bound(int[] nums, int target) {
        if (nums.length == 0) return -1;
        int left = 0, right = nums.length;
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                left = mid + 1; // 注意
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid;
            }
        }
        return left - 1; // 注意
    }

```

**1、为什么这个算法能够找到右侧边界** ？

答：类似地，关键点还是这里：

```java
    if (nums[mid] == target) {
        left = mid + 1;

```

当 ` nums[mid] == target ` 时，不要立即返回，而是增大「搜索区间」的下界 ` left `
，使得区间不断向右收缩，达到锁定右侧边界的目的。

**2、为什么最后返回` left - 1 ` 而不像左侧边界的函数，返回 ` left ` ？而且我觉得这里既然是搜索右侧边界，应该返回 ` right
` 才对 ** 。

答：首先，while 循环的终止条件是 ` left == right ` ，所以 ` left ` 和 ` right `
是一样的，你非要体现右侧的特点，返回 ` right - 1 ` 好了。

至于为什么要减一，这是搜索右侧边界的一个特殊点，关键在这个条件判断：

```java
    if (nums[mid] == target) {
        left = mid + 1;
        // 这样想: mid = left - 1

```

![](https://labuladong.gitee.io/algo/images/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/3.jpg)

因为我们对 ` left ` 的更新必须是 ` left = mid + 1 ` ，就是说 while 循环结束时， ` nums[left] `
一定不等于 ` target ` 了，而 ` nums[left-1] ` 可能是 ` target ` 。

至于为什么 ` left ` 的更新必须是 ` left = mid + 1 ` ，同左侧边界搜索，就不再赘述。

**3、为什么没有返回 -1 的操作？如果` nums ` 中不存在 ` target ` 这个值，怎么办 ** ？

答：类似之前的左侧边界搜索，因为 while 的终止条件是 ` left == right ` ，就是说 ` left ` 的取值范围是 ` [0, nums.length] ` ，所以可以添加两行代码，正确地返回 -1：

```java
    while (left < right) {
        // ...
    }
    if (left == 0) return -1;
    return nums[left-1] == target ? (left-1) : -1;

```

**4、是否也可以把这个算法的「搜索区间」也统一成两端都闭的形式呢？这样这三个写法就完全统一了，以后就可以闭着眼睛写出来了** 。

答：当然可以，类似搜索左侧边界的统一写法，其实只要改两个地方就行了：

```java
    int right_bound(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            } else if (nums[mid] == target) {
                // 这里改成收缩左侧边界即可
                left = mid + 1;
            }
        }
        // 这里改为检查 right 越界的情况，见下图
        if (right < 0 || nums[right] != target)
            return -1;
        return right;
    }

```

当 ` target ` 比所有元素都小时， ` right ` 会被减到 -1，所以需要在最后防止越界：

![](https://labuladong.gitee.io/algo/images/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/4.jpg)

至此，搜索右侧边界的二分查找的两种写法也完成了，其实将「搜索区间」统一成两端都闭反而更容易记忆，你说是吧？

## 四、逻辑统一

来梳理一下这些细节差异的因果逻辑：

**第一个，最基本的二分查找算法** ：

```java
    因为我们初始化 right = nums.length - 1
    所以决定了我们的「搜索区间」是 [left, right]
    所以决定了 while (left <= right)
    同时也决定了 left = mid+1 和 right = mid-1
    
    因为我们只需找到一个 target 的索引即可
    所以当 nums[mid] == target 时可以立即返回

```

**第二个，寻找左侧边界的二分查找** ：

```java
    因为我们初始化 right = nums.length
    所以决定了我们的「搜索区间」是 [left, right)
    所以决定了 while (left < right)
    同时也决定了 left = mid + 1 和 right = mid
    
    因为我们需找到 target 的最左侧索引
    所以当 nums[mid] == target 时不要立即返回
    而要收紧右侧边界以锁定左侧边界

```

**第三个，寻找右侧边界的二分查找** ：

```java
    因为我们初始化 right = nums.length
    所以决定了我们的「搜索区间」是 [left, right)
    所以决定了 while (left < right)
    同时也决定了 left = mid + 1 和 right = mid
    
    因为我们需找到 target 的最右侧索引
    所以当 nums[mid] == target 时不要立即返回
    而要收紧左侧边界以锁定右侧边界
    
    又因为收紧左侧边界时必须 left = mid + 1
    所以最后无论返回 left 还是 right，必须减一

```

对于寻找左右边界的二分搜索，常见的手法是使用左闭右开的「搜索区间」，
**我们还根据逻辑将「搜索区间」全都统一成了两端都闭，便于记忆，只要修改两处即可变化出三种写法** ：

```java
    int binary_search(int[] nums, int target) {
        int left = 0, right = nums.length - 1; 
        while(left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1; 
            } else if(nums[mid] == target) {
                // 直接返回
                return mid;
            }
        }
        // 直接返回
        return -1;
    }
    
    int left_bound(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            } else if (nums[mid] == target) {
                // 别返回，锁定左侧边界
                right = mid - 1;
            }
        }
        // 最后要检查 left 越界的情况
        if (left >= nums.length || nums[left] != target)
            return -1;
        return left;
    }
    
    int right_bound(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            } else if (nums[mid] == target) {
                // 别返回，锁定右侧边界
                left = mid + 1;
            }
        }
        // 最后要检查 right 越界的情况
        if (right < 0 || nums[right] != target)
            return -1;
        return right;
    }

```

如果以上内容你都能理解，那么恭喜你，二分查找算法的细节不过如此。

通过本文，你学会了：

1、分析二分查找代码时，不要出现 else，全部展开成 else if 方便理解。

2、注意「搜索区间」和 while 的终止条件，如果存在漏掉的元素，记得在最后检查。

3、如需定义左闭右开的「搜索区间」搜索左右边界，只要在 ` nums[mid] == target ` 时做修改即可，搜索右侧时需要减一。

4、如果将「搜索区间」全都统一成两端都闭，好记，只要稍改 ` nums[mid] == target ` 条件处的代码和返回的逻辑即可，
**推荐拿小本本记下，作为二分搜索模板** 。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**





# 我写了首诗，把滑动窗口算法算法变成了默写题




** ~

读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 76. 最小覆盖子串（困难） ](https://leetcode-cn.com/problems/minimum-window-substring)

[ 567. 字符串的排列（中等） ](https://leetcode-cn.com/problems/permutation-in-string)

[ 438. 找到字符串中所有字母异位词（中等） ](https://leetcode-cn.com/problems/find-all-anagrams-
in-a-string)

[ 3. 无重复字符的最长子串（中等） ](https://leetcode-cn.com/problems/longest-substring-
without-repeating-characters)

**———–**

鉴于前文 [ 二分搜索框架详解 ](https://labuladong.gitee.io/algo/2/20/57/)
的那首《二分搜索升天词》很受好评，并在民间广为流传，成为安睡助眠的一剂良方，今天在滑动窗口算法框架中，我再次编写一首小诗来歌颂滑动窗口算法的伟大：

![](https://labuladong.gitee.io/algo/images/slidingwindow/poem.png)

关于双指针的快慢指针和左右指针的用法，可以参见前文 [ 双指针技巧汇总 ](https://labuladong.gitee.io/algo/2/20/55/)
，本文就解决一类最难掌握的双指针技巧：滑动窗口技巧。总结出一套框架，可以保你闭着眼睛都能写出正确的解法。

说起滑动窗口算法，很多读者都会头疼。这个算法技巧的思路非常简单，就是维护一个窗口，不断滑动，然后更新答案么。LeetCode 上有起码 10 道运用滑动窗口算法的题目，难度都是中等和困难。该算法的大致逻辑如下：

```java
    int left = 0, right = 0;
    
    while (right < s.size()) {
        // 增大窗口
        window.add(s[right]);
        right++;
        
        while (window needs shrink) {
            // 缩小窗口
            window.remove(s[left]);
            left++;
        }
    }

```

这个算法技巧的时间复杂度是 O(N)，比字符串暴力算法要高效得多。

其实困扰大家的，不是算法的思路，而是各种细节问题。比如说如何向窗口中添加新元素，如何缩小窗口，在窗口滑动的哪个阶段更新结果。即便你明白了这些细节，也容易出 bug，找 bug 还不知道怎么找，真的挺让人心烦的。

**所以今天我就写一套滑动窗口算法的代码框架，我连再哪里做输出 debug 都给你写好了，以后遇到相关的问题，你就默写出来如下框架然后改三个地方就行，还不会出 bug** ：

```java
    /* 滑动窗口算法框架 */
    void slidingWindow(string s, string t) {
        unordered_map<char, int> need, window;
        for (char c : t) need[c]++;
        
        int left = 0, right = 0;
        int valid = 0; 
        while (right < s.size()) {
            // c 是将移入窗口的字符
            char c = s[right];
            // 右移窗口
            right++;
            // 进行窗口内数据的一系列更新
            ...
    
            /*** debug 输出的位置 ***/
            printf("window: [%d, %d)\n", left, right);
            /********************/
            
            // 判断左侧窗口是否要收缩
            while (window needs shrink) {
                // d 是将移出窗口的字符
                char d = s[left];
                // 左移窗口
                left++;
                // 进行窗口内数据的一系列更新
                ...
            }
        }
    }

```

**其中两处` ... ` 表示的更新窗口数据的地方，到时候你直接往里面填就行了 ** 。

而且，这两个 ` ... ` 处的操作分别是右移和左移窗口更新操作，等会你会发现它们操作是完全对称的。

说句题外话，我发现很多人喜欢执着于表象，不喜欢探求问题的本质。比如说有很多人评论我这个框架，说什么散列表速度慢，不如用数组代替散列表；还有很多人喜欢把代码写得特别短小，说我这样代码太多余，影响编译速度，LeetCode 上速度不够快。

我服了。算法看的是时间复杂度，你能确保自己的时间复杂度最优，就行了。至于 LeetCode 所谓的运行速度，那个都是玄学，只要不是慢的离谱就没啥问题，根本不值得你从编译层面优化，不要舍本逐末……

我的公众号重点在于算法思想，你把框架思维了然于心，然后随你魔改代码好吧，你高兴就好。

言归正传，下面就直接上 **四道** LeetCode 原题来套这个框架，其中第一道题会详细说明其原理，后面四道就直接闭眼睛秒杀了。

因为滑动窗口很多时候都是在处理字符串相关的问题，Java 处理字符串不方便，所以本文代码为 C++ 实现。不会用到什么编程方面的奇技淫巧，但是还是简单介绍一下一些用到的数据结构，以免有的读者因为语言的细节问题阻碍对算法思想的理解：

` unordered_map ` 就是哈希表（字典），它的一个方法 ` count(key) ` 相当于 Java 的 `
containsKey(key) ` 可以判断键 key 是否存在。

可以使用方括号访问键对应的值 ` map[key] ` 。需要注意的是，如果该 ` key ` 不存在，C++ 会自动创建这个 key，并把 `
map[key] ` 赋值为 0。

所以代码中多次出现的 ` map[key]++ ` 相当于 Java 的 ` map.put(key, map.getOrDefault(key, 0) +

1) ` 。

## 一、最小覆盖子串

先来看看力扣第 76 题「最小覆盖子串」难度 Hard：

![](https://labuladong.gitee.io/algo/images/slidingwindow/title1.png)

就是说要在 ` S ` (source) 中找到包含 ` T ` (target) 中全部字母的一个子串，且这个子串一定是所有可能子串中最短的。

如果我们使用暴力解法，代码大概是这样的：

```java
    for (int i = 0; i < s.size(); i++)
        for (int j = i + 1; j < s.size(); j++)
            if s[i:j] 包含 t 的所有字母:
                更新答案

```

思路很直接，但是显然，这个算法的复杂度肯定大于 O(N^2) 了，不好。

**滑动窗口算法的思路是这样** ：

1、我们在字符串 ` S ` 中使用双指针中的左右指针技巧，初始化 ` left = right = 0 ` ，把索引 **左闭右开** 区间 `
[left, right) ` 称为一个「窗口」。

2、我们先不断地增加 ` right ` 指针扩大窗口 ` [left, right) ` ，直到窗口中的字符串符合要求（包含了 ` T `
中的所有字符）。

3、此时，我们停止增加 ` right ` ，转而不断增加 ` left ` 指针缩小窗口 ` [left, right) `
，直到窗口中的字符串不再符合要求（不包含 ` T ` 中的所有字符了）。同时，每次增加 ` left ` ，我们都要更新一轮结果。

4、重复第 2 和第 3 步，直到 ` right ` 到达字符串 ` S ` 的尽头。

这个思路其实也不难， **第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解**
，也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动，这就是「滑动窗口」这个名字的来历。

下面画图理解一下， ` needs ` 和 ` window ` 相当于计数器，分别记录 ` T ` 中字符出现次数和「窗口」中的相应字符的出现次数。

初始状态：

![](https://labuladong.gitee.io/algo/images/slidingwindow/1.png)

增加 ` right ` ，直到窗口 ` [left, right] ` 包含了 ` T ` 中所有字符：

![](https://labuladong.gitee.io/algo/images/slidingwindow/2.png)

现在开始增加 ` left ` ，缩小窗口 ` [left, right] ` ：

![](https://labuladong.gitee.io/algo/images/slidingwindow/3.png)

直到窗口中的字符串不再符合要求， ` left ` 不再继续移动：

![](https://labuladong.gitee.io/algo/images/slidingwindow/4.png)

之后重复上述过程，先移动 ` right ` ，再移动 ` left ` …… 直到 ` right ` 指针到达字符串 ` S ` 的末端，算法结束。

如果你能够理解上述过程，恭喜，你已经完全掌握了滑动窗口算法思想。 **现在我们来看看这个滑动窗口代码框架怎么用** ：

首先，初始化 ` window ` 和 ` need ` 两个哈希表，记录窗口中的字符和需要凑齐的字符：

```java
    unordered_map<char, int> need, window;
    for (char c : t) need[c]++;

```

然后，使用 ` left ` 和 ` right ` 变量初始化窗口的两端，不要忘了，区间 ` [left, right) `
是左闭右开的，所以初始情况下窗口没有包含任何元素：

```java
    int left = 0, right = 0;
    int valid = 0; 
    while (right < s.size()) {
        // 开始滑动
    }

```

**其中` valid ` 变量表示窗口中满足 ` need ` 条件的字符个数 ** ，如果 ` valid ` 和 ` need.size `
的大小相同，则说明窗口已满足条件，已经完全覆盖了串 ` T ` 。

**现在开始套模板，只需要思考以下四个问题** ：

1、当移动 ` right ` 扩大窗口，即加入字符时，应该更新哪些数据？

2、什么条件下，窗口应该暂停扩大，开始移动 ` left ` 缩小窗口？

3、当移动 ` left ` 缩小窗口，即移出字符时，应该更新哪些数据？

4、我们要的结果应该在扩大窗口时还是缩小窗口时进行更新？

如果一个字符进入窗口，应该增加 ` window ` 计数器；如果一个字符将移出窗口的时候，应该减少 ` window ` 计数器；当 ` valid `
满足 ` need ` 时应该收缩窗口；应该在收缩窗口的时候更新最终结果。

下面是完整代码：

```java
    string minWindow(string s, string t) {
        unordered_map<char, int> need, window;
        for (char c : t) need[c]++;
    
        int left = 0, right = 0;
        int valid = 0;
        // 记录最小覆盖子串的起始索引及长度
        int start = 0, len = INT_MAX;
        while (right < s.size()) {
            // c 是将移入窗口的字符
            char c = s[right];
            // 右移窗口
            right++;
            // 进行窗口内数据的一系列更新
            if (need.count(c)) {
                window[c]++;
                if (window[c] == need[c])
                    valid++;
            }
    
            // 判断左侧窗口是否要收缩
            while (valid == need.size()) {
                // 在这里更新最小覆盖子串
                if (right - left < len) {
                    start = left;
                    len = right - left;
                }
                // d 是将移出窗口的字符
                char d = s[left];
                // 左移窗口
                left++;
                // 进行窗口内数据的一系列更新
                if (need.count(d)) {
                    if (window[d] == need[d])
                        valid--;
                    window[d]--;
                }                    
            }
        }
        // 返回最小覆盖子串
        return len == INT_MAX ?
            "" : s.substr(start, len);
    }

```

> PS：使用 Java 的读者要尤其警惕语言特性的陷阱。Java 的 Integer，String 等类型判定相等应该用 ` equals `
> 方法而不能直接用等号 ` == ` ，这是 Java包装类的一个隐晦细节。所以在左移窗口更新数据的时候，不能直接改写为 ` window.get(d)
> == need.get(d) ` ，而要用 ` window.get(d).equals(need.get(d)) ` ，之后的题目代码同理。

需要注意的是，当我们发现某个字符在 ` window ` 的数量满足了 ` need ` 的需要，就要更新 ` valid `
，表示有一个字符已经满足要求。而且，你能发现，两次对窗口内数据的更新操作是完全对称的。

当 ` valid == need.size() ` 时，说明 ` T `
中所有字符已经被覆盖，已经得到一个可行的覆盖子串，现在应该开始收缩窗口了，以便得到「最小覆盖子串」。

移动 ` left ` 收缩窗口时，窗口内的字符都是可行解，所以应该在收缩窗口的阶段进行最小覆盖子串的更新，以便从可行解中找到长度最短的最终结果。

至此，应该可以完全理解这套框架了，滑动窗口算法又不难，就是细节问题让人烦得很。 **以后遇到滑动窗口算法，你就按照这框架写代码，保准没有 bug，还省事儿** 。

下面就直接利用这套框架秒杀几道题吧，你基本上一眼就能看出思路了。

## 二、字符串排列

LeetCode 567 题，Permutation in String，难度 Medium：

![](https://labuladong.gitee.io/algo/images/slidingwindow/title2.png)

注意哦，输入的 ` s1 ` 是可以包含重复字符的，所以这个题难度不小。

这种题目，是明显的滑动窗口算法， **相当给你一个` S ` 和一个 ` T ` ，请问你 ` S ` 中是否存在一个子串，包含 ` T `
中所有字符且不包含其他字符 ** ？

首先，先复制粘贴之前的算法框架代码，然后明确刚才提出的 4 个问题，即可写出这道题的答案：

```java
    // 判断 s 中是否存在 t 的排列
    bool checkInclusion(string t, string s) {
        unordered_map<char, int> need, window;
        for (char c : t) need[c]++;
    
        int left = 0, right = 0;
        int valid = 0;
        while (right < s.size()) {
            char c = s[right];
            right++;
            // 进行窗口内数据的一系列更新
            if (need.count(c)) {
                window[c]++;
                if (window[c] == need[c])
                    valid++;
            }
    
            // 判断左侧窗口是否要收缩
            while (right - left >= t.size()) {
                // 在这里判断是否找到了合法的子串
                if (valid == need.size())
                    return true;
                char d = s[left];
                left++;
                // 进行窗口内数据的一系列更新
                if (need.count(d)) {
                    if (window[d] == need[d])
                        valid--;
                    window[d]--;
                }
            }
        }
        // 未找到符合条件的子串
        return false;
    }

```

对于这道题的解法代码，基本上和最小覆盖子串一模一样，只需要改变两个地方：

1、本题移动 ` left ` 缩小窗口的时机是窗口大小大于 ` t.size() ` 时，应为排列嘛，显然长度应该是一样的。

2、当发现 ` valid == need.size() ` 时，就说明窗口中就是一个合法的排列，所以立即返回 ` true ` 。

至于如何处理窗口的扩大和缩小，和最小覆盖子串完全相同。

## 三、找所有字母异位词

这是 LeetCode 第 438 题，Find All Anagrams in a String，难度 Medium：

![](https://labuladong.gitee.io/algo/images/slidingwindow/title3.png)

呵呵，这个所谓的字母异位词，不就是排列吗，搞个高端的说法就能糊弄人了吗？ **相当于，输入一个串` S ` ，一个串 ` T ` ，找到 ` S ` 中所有
` T ` 的排列，返回它们的起始索引 ** 。

直接默写一下框架，明确刚才讲的 4 个问题，即可秒杀这道题：

```java
    vector<int> findAnagrams(string s, string t) {
        unordered_map<char, int> need, window;
        for (char c : t) need[c]++;
    
        int left = 0, right = 0;
        int valid = 0;
        vector<int> res; // 记录结果
        while (right < s.size()) {
            char c = s[right];
            right++;
            // 进行窗口内数据的一系列更新
            if (need.count(c)) {
                window[c]++;
                if (window[c] == need[c]) 
                    valid++;
            }
            // 判断左侧窗口是否要收缩
            while (right - left >= t.size()) {
                // 当窗口符合条件时，把起始索引加入 res
                if (valid == need.size())
                    res.push_back(left);
                char d = s[left];
                left++;
                // 进行窗口内数据的一系列更新
                if (need.count(d)) {
                    if (window[d] == need[d])
                        valid--;
                    window[d]--;
                }
            }
        }
        return res;
    }

```

跟寻找字符串的排列一样，只是找到一个合法异位词（排列）之后将起始索引加入 ` res ` 即可。

## 四、最长无重复子串

这是 LeetCode 第 3 题，Longest Substring Without Repeating Characters，难度 Medium：

![](https://labuladong.gitee.io/algo/images/slidingwindow/title4.png)

这个题终于有了点新意，不是一套框架就出答案，不过反而更简单了，稍微改一改框架就行了：

```java
    int lengthOfLongestSubstring(string s) {
        unordered_map<char, int> window;
    
        int left = 0, right = 0;
        int res = 0; // 记录结果
        while (right < s.size()) {
            char c = s[right];
            right++;
            // 进行窗口内数据的一系列更新
            window[c]++;
            // 判断左侧窗口是否要收缩
            while (window[c] > 1) {
                char d = s[left];
                left++;
                // 进行窗口内数据的一系列更新
                window[d]--;
            }
            // 在这里更新答案
            res = max(res, right - left);
        }
        return res;
    }

```

这就是变简单了，连 ` need ` 和 ` valid ` 都不需要，而且更新窗口内数据也只需要简单的更新计数器 ` window ` 即可。

当 ` window[c] ` 值大于 1 时，说明窗口中存在重复字符，不符合条件，就该移动 ` left ` 缩小窗口了嘛。

唯一需要注意的是，在哪里更新结果 ` res ` 呢？我们要的是最长无重复子串，哪一个阶段可以保证窗口中的字符串是没有重复的呢？

这里和之前不一样，要在收缩窗口完成后更新 ` res ` ，因为窗口收缩的 while 条件是存在重复元素，换句话说收缩完成后一定保证窗口中没有重复嘛。

## 五、最后总结

建议背诵并默写这套框架，顺便背诵一下文章开头的那首诗。以后就再也不怕子串、子数组问题了好吧。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**





# 一个方法团灭 LeetCode 股票买卖问题




** ~

读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 121. 买卖股票的最佳时机（简单） ](https://leetcode-cn.com/problems/best-time-to-buy-and-
sell-stock/)

[ 122. 买卖股票的最佳时机 II（简单） ](https://leetcode-cn.com/problems/best-time-to-buy-
and-sell-stock-ii/)

[ 123. 买卖股票的最佳时机 III（困难） ](https://leetcode-cn.com/problems/best-time-to-buy-
and-sell-stock-iii/)

[ 188. 买卖股票的最佳时机 IV（困难） ](https://leetcode-cn.com/problems/best-time-to-buy-
and-sell-stock-iv/)

[ 309. 最佳买卖股票时机含冷冻期（中等） ](https://leetcode-cn.com/problems/best-time-to-buy-
and-sell-stock-with-cooldown/)

[ 714. 买卖股票的最佳时机含手续费（中等） ](https://leetcode-cn.com/problems/best-time-to-buy-
and-sell-stock-with-transaction-fee/)

**———–**

很多读者抱怨 LeetCode 的股票系列问题奇技淫巧太多，如果面试真的遇到这类问题，基本不会想到那些巧妙的办法，怎么办？
**所以本文拒绝奇技淫巧，而是稳扎稳打，只用一种通用方法解决所用问题，以不变应万变** 。

这篇文章参考 [ 英文版高赞题解 ](https://leetcode.com/problems/best-time-to-buy-and-sell-
stock-with-transaction-fee/discuss/108870/Most-consistent-ways-of-dealing- with-the-series-of-stock-problems)
的思路，用状态机的技巧来解决，可以全部提交通过。不要觉得这个名词高大上，文学词汇而已，实际上就是 DP table，看一眼就明白了。

先随便抽出一道题，看看别人的解法：

```java
    int maxProfit(vector<int>& prices) {
        if(prices.empty()) return 0;
        int s1 = -prices[0], s2 = INT_MIN, s3 = INT_MIN, s4 = INT_MIN;
    
        for(int i = 1; i < prices.size(); ++i) {            
            s1 = max(s1, -prices[i]);
            s2 = max(s2, s1 + prices[i]);
            s3 = max(s3, s2 - prices[i]);
            s4 = max(s4, s3 + prices[i]);
        }
        return max(0, s4);
    }

```

能看懂吧？会做了吗？不可能的，你看不懂，这才正常。就算你勉强看懂了，下一个问题你还是做不出来。为什么别人能写出这么诡异却又高效的解法呢？因为这类问题是有框架的，但是人家不会告诉你的，因为一旦告诉你，你五分钟就学会了，该算法题就不再神秘，变得不堪一击了。

本文就来告诉你这个框架，然后带着你一道一道秒杀。这篇文章用状态机的技巧来解决，可以全部提交通过。不要觉得这个名词高大上，文学词汇而已，实际上就是 DP table，看一眼就明白了。

这 6 道题目是有共性的，我就抽出来第 4 道题目，因为这道题是一个最泛化的形式，其他的问题都是这个形式的简化，看下题目：

![](https://labuladong.gitee.io/algo/images/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/title.png)

第一题是只进行一次交易，相当于 ` k = 1 ` ；第二题是不限交易次数，相当于 ` k = +infinity ` （正无穷）；第三题是只进行 2 次交易，相当于 ` k = 2 `
；剩下两道也是不限次数，但是加了交易「冷冻期」和「手续费」的额外条件，其实就是第二题的变种，都很容易处理。

如果你还不熟悉题目，可以去 LeetCode 查看这些题目的内容，本文为了节省篇幅，就不列举这些题目的具体内容了。下面言归正传，开始解题。

## 一、穷举框架

首先，还是一样的思路：如何穷举？

[ 动态规划核心套路 ](https://labuladong.gitee.io/algo/3/22/66/) 说过，动态规划算法本质上就是穷举「状态」，然后在「选择」中选择最优解。

那么对于这道题，我们具体到每一天，看看总共有几种可能的「状态」，再找出每个「状态」对应的「选择」。我们要穷举所有「状态」，穷举的目的是根据对应的「选择」更新状态。听起来抽象，你只要记住「状态」和「选择」两个词就行，下面实操一下就很容易明白了。

```java
    for 状态1 in 状态1的所有取值：
        for 状态2 in 状态2的所有取值：
            for ...
                dp[状态1][状态2][...] = 择优(选择1，选择2...)

```

比如说这个问题， **每天都有三种「选择」** ：买入、卖出、无操作，我们用 ` buy ` , ` sell ` , ` rest ` 表示这三种选择。

但问题是，并不是每天都可以任意选择这三种选择的，因为 ` sell ` 必须在 ` buy ` 之后， ` buy ` 必须在 ` sell ` 之后。那么
` rest ` 操作还应该分两种状态，一种是 ` buy ` 之后的 ` rest ` （持有了股票），一种是 ` sell ` 之后的 ` rest `
（没有持有股票）。而且别忘了，我们还有交易次数 ` k ` 的限制，就是说你 ` buy ` 还只能在 ` k > 0 ` 的前提下操作。

很复杂对吧，不要怕，我们现在的目的只是穷举，你有再多的状态，老夫要做的就是一把梭全部列举出来。

**这个问题的「状态」有三个** ，第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态（即之前说的 ` rest ` 的状态，我们不妨用 1 表示持有，0 表示没有持有）。然后我们用一个三维数组就可以装下这几种状态的全部组合：

```java
    dp[i][k][0 or 1]
    0 <= i <= n - 1, 1 <= k <= K
    n 为天数，大 K 为交易数的上限，0 和 1 代表是否持有股票。
    此问题共 n × K × 2 种状态，全部穷举就能搞定。
    
    for 0 <= i < n:
        for 1 <= k <= K:
            for s in {0, 1}:
                dp[i][k][s] = max(buy, sell, rest)

```

而且我们可以用自然语言描述出每一个状态的含义，比如说 ` dp[3][2][1] ` 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。再比如 ` dp[2][3][0] `
的含义：今天是第二天，我现在手上没有持有股票，至今最多进行 3 次交易。很容易理解，对吧？

我们想求的最终答案是 ` dp[n - 1][K][0] ` ，即最后一天，最多允许 ` K ` 次交易，最多获得多少利润。

读者可能问为什么不是 ` dp[n - 1][K][1] ` ？因为 ` dp[n - 1][K][1] ` 代表到最后一天手上还持有股票， ` dp[n

- 1][K][0] ` 表示最后一天手上的股票已经卖出去了，很显然后者得到的利润一定大于前者。

记住如何解释「状态」，一旦你觉得哪里不好理解，把它翻译成自然语言就容易理解了。

## 二、状态转移框架

现在，我们完成了「状态」的穷举，我们开始思考每种「状态」有哪些「选择」，应该如何更新「状态」。

只看「持有状态」，可以画个状态转移图：

![](https://labuladong.gitee.io/algo/images/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/1.png)

通过这个图可以很清楚地看到，每种状态（0 和 1）是如何转移而来的。根据这个图，我们来写一下状态转移方程：

```java
    dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
                  max( 今天选择 rest,        今天选择 sell       )

```

解释：今天我没有持有股票，有两种可能，我从这两种可能中求最大利润：

1、我昨天就没有持有，且截至昨天最大交易次数限制为 ` k ` ；然后我今天选择 ` rest ` ，所以我今天还是没有持有，最大交易次数限制依然为 ` k
` 。

2、我昨天持有股票，且截至昨天最大交易次数限制为 ` k ` ；但是今天我 ` sell ` 了，所以我今天没有持有股票了，最大交易次数限制依然为 ` k
` 。

```java
    dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
                  max( 今天选择 rest,         今天选择 buy         )

```

解释：今天我持有着股票，最大交易次数限制为 ` k ` ，那么对于昨天来说，有两种可能，我从这两种可能中求最大利润：

1、我昨天就持有着股票，且截至昨天最大交易次数限制为 ` k ` ；然后今天选择 ` rest ` ，所以我今天还持有着股票，最大交易次数限制依然为 ` k
` 。

2、我昨天本没有持有，且截至昨天最大交易次数限制为 ` k - 1 ` ；但今天我选择 ` buy ` ，所以今天我就持有股票了，最大交易次数限制为 ` k
` 。

> 这里着重提醒一下，时刻牢记「状态」的定义， ` k `
> 的定义并不是「已进行的交易次数」，而是「最大交易次数的上限限制」。如果确定今天进行一次交易，且要保证截至今天最大交易次数上限为 ` k `
> ，那么昨天的最大交易次数上限必须是 ` k - 1 ` 。

这个解释应该很清楚了，如果 ` buy ` ，就要从利润中减去 ` prices[i] ` ，如果 ` sell ` ，就要给利润增加 `
prices[i] ` 。今天的最大利润就是这两种可能选择中较大的那个。

注意 ` k ` 的限制，在选择 ` buy ` 的时候相当于开启了一次交易，那么对于昨天来说，交易次数的上限 ` k ` 应该减小 1。

> 修正：以前我以为在 ` sell ` 的时候给 ` k ` 减小 1 和在 ` buy ` 的时候给 ` k ` 减小 1
> 是等效的，但细心的读者向我提出质疑，经过深入思考我发现前者确实是错误的，因为交易是从 ` buy ` 开始，如果 ` buy ` 的选择不改变交易次数
> ` k ` 的约束，会出现交易次数超出限制的的错误。

现在，我们已经完成了动态规划中最困难的一步：状态转移方程。 **如果之前的内容你都可以理解，那么你已经可以秒杀所有问题了，只要套这个框架就行了**
。不过还差最后一点点，就是定义 base case，即最简单的情况。

```java
    dp[-1][...][0] = 0
    解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0。
    
    dp[-1][...][1] = -infinity
    解释：还没开始的时候，是不可能持有股票的。
    因为我们的算法要求一个最大值，所以初始值设为一个最小值，方便取最大值。
    
    dp[...][0][0] = 0
    解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0。
    
    dp[...][0][1] = -infinity
    解释：不允许交易的情况下，是不可能持有股票的。
    因为我们的算法要求一个最大值，所以初始值设为一个最小值，方便取最大值。

```

把上面的状态转移方程总结一下：

```java
    base case：
    dp[-1][...][0] = dp[...][0][0] = 0
    dp[-1][...][1] = dp[...][0][1] = -infinity
    
    状态转移方程：
    dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
    dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])

```

读者可能会问，这个数组索引是 -1 怎么编程表示出来呢，负无穷怎么表示呢？这都是细节问题，有很多方法实现。现在完整的框架已经完成，下面开始具体化。

## 三、秒杀题目

**第一题，k = 1**

直接套状态转移方程，根据 base case，可以做一些化简：

```java
    dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])
    dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i]) 
                = max(dp[i-1][1][1], -prices[i])
    解释：k = 0 的 base case，所以 dp[i-1][0][0] = 0。
    
    现在发现 k 都是 1，不会改变，即 k 对状态转移已经没有影响了。
    可以进行进一步化简去掉所有 k：
    dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
    dp[i][1] = max(dp[i-1][1], -prices[i])

```

直接写出代码：

```java
    int n = prices.length;
    int[][] dp = new int[n][2];
    for (int i = 0; i < n; i++) {
        dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
        dp[i][1] = Math.max(dp[i-1][1], -prices[i]);
    }
    return dp[n - 1][0];

```

显然 ` i = 0 ` 时 ` i - 1 ` 是不合法的索引，这是因为我们没有对 ` i ` 的 base case 进行处理，可以这样给一个特化处理：

```java
    if (i - 1 == -1) {
        dp[i][0] = 0;
        // 根据状态转移方程可得：
        //   dp[i][0] 
        // = max(dp[-1][0], dp[-1][1] + prices[i])
        // = max(0, -infinity + prices[i]) = 0
    
        dp[i][1] = -prices[i];
        // 根据状态转移方程可得：
        //   dp[i][1] 
        // = max(dp[-1][1], dp[-1][0] - prices[i])
        // = max(-infinity, 0 - prices[i]) 
        // = -prices[i]
        continue;
    }

```

第一题就解决了，但是这样处理 base case 很麻烦，而且注意一下状态转移方程，新状态只和相邻的一个状态有关，其实不用整个 ` dp `
数组，只需要一个变量储存相邻的那个状态就足够了，这样可以把空间复杂度降到 O(1):

```java
    // 原始版本
    int maxProfit_k_1(int[] prices) {
        int n = prices.length;
        int[][] dp = new int[n][2];
        for (int i = 0; i < n; i++) {
            if (i - 1 == -1) {
                // base case
                dp[i][0] = 0;
                dp[i][1] = -prices[i];
                continue;
            }
            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i-1][1], -prices[i]);
        }
        return dp[n - 1][0];
    }
    
    // 空间复杂度优化版本
    int maxProfit_k_1(int[] prices) {
        int n = prices.length;
        // base case: dp[-1][0] = 0, dp[-1][1] = -infinity
        int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;
        for (int i = 0; i < n; i++) {
            // dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
            dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
            // dp[i][1] = max(dp[i-1][1], -prices[i])
            dp_i_1 = Math.max(dp_i_1, -prices[i]);
        }
        return dp_i_0;
    }

```

两种方式都是一样的，不过这种编程方法简洁很多，但是如果没有前面状态转移方程的引导，是肯定看不懂的。后续的题目，你可以对比一下如何把 ` dp `
数组的空间优化掉。

**第二题，k = +infinity**

如果 ` k ` 为正无穷，那么就可以认为 ` k ` 和 ` k - 1 ` 是一样的。可以这样改写框架：

```java
    dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
    dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
                = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i])
    
    我们发现数组中的 k 已经不会改变了，也就是说不需要记录 k 这个状态了：
    dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
    dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])

```

直接翻译成代码：

```java
    // 原始版本
    int maxProfit_k_inf(int[] prices) {
        int n = prices.length;
        int[][] dp = new int[n][2];
        for (int i = 0; i < n; i++) {
            if (i - 1 == -1) {
                // base case
                dp[i][0] = 0;
                dp[i][1] = -prices[i];
                continue;
            }
            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] - prices[i]);
        }
        return dp[n - 1][0];
    }
    
    // 空间复杂度优化版本
    int maxProfit_k_inf(int[] prices) {
        int n = prices.length;
        int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;
        for (int i = 0; i < n; i++) {
            int temp = dp_i_0;
            dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
            dp_i_1 = Math.max(dp_i_1, temp - prices[i]);
        }
        return dp_i_0;
    }

```

**第三题，k = +infinity with cooldown**

每次 ` sell ` 之后要等一天才能继续交易。只要把这个特点融入上一题的状态转移方程即可：

```java
    dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
    dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])
    解释：第 i 天选择 buy 的时候，要从 i-2 的状态转移，而不是 i-1 。

```

翻译成代码：

```java
    // 原始版本
    int maxProfit_with_cool(int[] prices) {
        int n = prices.length;
        int[][] dp = new int[n][2];
        for (int i = 0; i < n; i++) {
            if (i - 1 == -1) {
                // base case 1
                dp[i][0] = 0;
                dp[i][1] = -prices[i];
                continue;
            }
            if (i - 2 == -1) {
                // base case 2
                dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
                // i - 2 小于 0 时根据状态转移方程推出对应 base case
                dp[i][1] = Math.max(dp[i-1][1], -prices[i]);
                //   dp[i][1] 
                // = max(dp[i-1][1], dp[-1][0] - prices[i])
                // = max(dp[i-1][1], 0 - prices[i])
                // = max(dp[i-1][1], -prices[i])
                continue;
            }
            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i-1][1], dp[i-2][0] - prices[i]);
        }
        return dp[n - 1][0];
    }
    
    // 空间复杂度优化版本
    int maxProfit_with_cool(int[] prices) {
        int n = prices.length;
        int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;
        int dp_pre_0 = 0; // 代表 dp[i-2][0]
        for (int i = 0; i < n; i++) {
            int temp = dp_i_0;
            dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
            dp_i_1 = Math.max(dp_i_1, dp_pre_0 - prices[i]);
            dp_pre_0 = temp;
        }
        return dp_i_0;
    }

```

**第四题，k = +infinity with fee**

每次交易要支付手续费，只要把手续费从利润中减去即可。改写方程：

```java
    dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
    dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i] - fee)
    解释：相当于买入股票的价格升高了。
    在第一个式子里减也是一样的，相当于卖出股票的价格减小了。

```

> 如果直接把 ` fee ` 放在第一个式子里减，会有测试用例无法通过，错误原因是整型溢出而不是思路问题。一种解决方案是把代码中的 ` int `
> 类型都改成 ` long ` 类型，避免 ` int ` 的整型溢出。

直接翻译成代码，注意状态转移方程改变后 base case 也要做出对应改变：

```java
    // 原始版本
    int maxProfit_with_fee(int[] prices, int fee) {
        int n = prices.length;
        int[][] dp = new int[n][2];
        for (int i = 0; i < n; i++) {
            if (i - 1 == -1) {
                // base case
                dp[i][0] = 0;
                dp[i][1] = -prices[i] - fee;
                //   dp[i][1]
                // = max(dp[i - 1][1], dp[i - 1][0] - prices[i] - fee)
                // = max(dp[-1][1], dp[-1][0] - prices[i] - fee)
                // = max(-inf, 0 - prices[i] - fee)
                // = -prices[i] - fee
                continue;
            }
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i] - fee);
        }
        return dp[n - 1][0];
    }
    
    // 空间复杂度优化版本
    int maxProfit_with_fee(int[] prices, int fee) {
        int n = prices.length;
        int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;
        for (int i = 0; i < n; i++) {
            int temp = dp_i_0;
            dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
            dp_i_1 = Math.max(dp_i_1, temp - prices[i] - fee);
        }
        return dp_i_0;
    }

```

**第五题，k = 2**

` k = 2 ` 和前面题目的情况稍微不同，因为上面的情况都和 ` k ` 的关系不太大。要么 ` k ` 是正无穷，状态转移和 ` k `
没关系了；要么 ` k = 1 ` ，跟 ` k = 0 ` 这个 base case 挨得近，最后也没有存在感。

这道题 ` k = 2 ` 和后面要讲的 ` k ` 是任意正整数的情况中，对 ` k ` 的处理就凸显出来了。我们直接写代码，边写边分析原因。

```java
    原始的状态转移方程，没有可化简的地方
    dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
    dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])

```

按照之前的代码，我们可能想当然这样写代码（错误的）：

```java
    int k = 2;
    int[][][] dp = new int[n][k + 1][2];
    for (int i = 0; i < n; i++) {
        if (i - 1 == -1) {
            // 处理 base case
            dp[i][k][0] = 0;
            dp[i][k][1] = -prices[i];
            continue;
        }
        dp[i][k][0] = Math.max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);
        dp[i][k][1] = Math.max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);
    }
    return dp[n - 1][k][0];

```

为什么错误？我这不是照着状态转移方程写的吗？

还记得前面总结的「穷举框架」吗？就是说我们必须穷举所有状态。其实我们之前的解法，都在穷举所有状态，只是之前的题目中 ` k ` 都被化简掉了。

比如说第一题， ` k = 1 ` 时的代码框架：

```java
    int n = prices.length;
    int[][] dp = new int[n][2];
    for (int i = 0; i < n; i++) {
        dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
        dp[i][1] = Math.max(dp[i-1][1], -prices[i]);
    }
    return dp[n - 1][0];

```

但当 ` k = 2 ` 时，由于没有消掉 ` k ` 的影响，所以必须要对 ` k ` 进行穷举：

```java
    // 原始版本
    int maxProfit_k_2(int[] prices) {
        int max_k = 2, n = prices.length;
        int[][][] dp = new int[n][max_k + 1][2];
        for (int i = 0; i < n; i++) {
            for (int k = max_k; k >= 1; k--) {
                if (i - 1 == -1) {
                    // 处理 base case
                    dp[i][k][0] = 0;
                    dp[i][k][1] = -prices[i];
                    continue;
                }
                dp[i][k][0] = Math.max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);
                dp[i][k][1] = Math.max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);
            }
        }
        // 穷举了 n × max_k × 2 个状态，正确。
        return dp[n - 1][max_k][0];
    }

```

> **PS：这里肯定会有读者疑惑，` k ` 的 base case 是 0，按理说应该从 ` k = 1, k++ ` 这样穷举状态 ` k `
> 才对？而且如果你真的这样从小到大遍历 ` k ` ，提交发现也是可以的 ** 。

这个疑问很正确，因为我们前文 [ 动态规划答疑篇 ](https://labuladong.gitee.io/algo/3/22/68/) 有介绍 ` dp ` 数组的遍历顺序是怎么确定的，主要是根据 base case，以 base case 为起点，逐步向结果靠近。

但为什么我从大到小遍历 ` k ` 也可以正确提交呢？因为你注意看， ` dp[i][k] ` 不会依赖 ` dp[i][k - 1] ` ，而是依赖 `
dp[i - 1][k - 1] ` ，对于 ` dp[i - 1][...] ` ，都是已经计算出来的。所以不管你是 ` k = max_k, k-- `
，还是 ` k = 1, k++ ` ，都是可以得出正确答案的。

那为什么我使用 ` k = max_k, k-- ` 的方式呢？因为这样符合语义。

你买股票，初始的「状态」是什么？应该是从第 0 天开始，而且还没有进行过买卖，所以最大交易次数限制 ` k ` 应该是 ` max_k `
；而随着「状态」的推移，你会进行交易，那么交易次数上限 ` k ` 应该不断减少，这样一想， ` k = max_k, k-- `
的方式是比较合乎实际场景的。

当然，这里 ` k ` 取值范围比较小，所以可以不用 for 循环，直接把 k = 1 和 2 的情况全部列举出来也可以：

```java
    // 状态转移方程：
    // dp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])
    // dp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])
    // dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])
    // dp[i][1][1] = max(dp[i-1][1][1], -prices[i])
    
    // 空间复杂度优化版本
    int maxProfit_k_2(int[] prices) {
        // base case
        int dp_i10 = 0, dp_i11 = Integer.MIN_VALUE;
        int dp_i20 = 0, dp_i21 = Integer.MIN_VALUE;
        for (int price : prices) {
            dp_i20 = Math.max(dp_i20, dp_i21 + price);
            dp_i21 = Math.max(dp_i21, dp_i10 - price);
            dp_i10 = Math.max(dp_i10, dp_i11 + price);
            dp_i11 = Math.max(dp_i11, -price);
        }
        return dp_i20;
    }

```

有状态转移方程和含义明确的变量名指导，相信你很容易看懂。其实我们可以故弄玄虚，把上述四个变量换成 ` a, b, c, d `
。这样当别人看到你的代码时就会大惊失色，对你肃然起敬。

**第六题，k = any integer**

有了上一题 ` k = 2 ` 的铺垫，这题应该和上一题的第一个解法没啥区别。但是出现了一个超内存的错误，原来是传入的 ` k ` 值会非常大， ` dp
` 数组太大了。现在想想，交易次数 ` k ` 最多有多大呢？

一次交易由买入和卖出构成，至少需要两天。所以说有效的限制 ` k ` 应该不超过 ` n/2 ` ，如果超过，就没有约束作用了，相当于 ` k = +infinity ` 。这种情况是之前解决过的。

直接把之前的代码重用：

```java
    int maxProfit_k_any(int max_k, int[] prices) {
        int n = prices.length;
        if (n <= 0) {
            return 0;
        }
        if (max_k > n / 2) {
            // 交易次数 k 没有限制的情况
            return maxProfit_k_inf(prices);
        }
    
        // base case：
        // dp[-1][...][0] = dp[...][0][0] = 0
        // dp[-1][...][1] = dp[...][0][1] = -infinity
        int[][][] dp = new int[n][max_k + 1][2];
        // k = 0 时的 base case
        for (int i = 0; i < n; i++) {
            dp[i][0][1] = Integer.MIN_VALUE;
            dp[i][0][0] = 0;
        }
    
        for (int i = 0; i < n; i++) 
            for (int k = max_k; k >= 1; k--) {
                if (i - 1 == -1) {
                    // 处理 i = -1 时的 base case
                    dp[i][k][0] = 0;
                    dp[i][k][1] = -prices[i];
                    continue;
                }
                dp[i][k][0] = Math.max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);
                dp[i][k][1] = Math.max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);     
            }
        return dp[n - 1][max_k][0];
    }

```

至此，6 道题目通过一个状态转移方程全部解决。

**四、最后总结**

本文给大家讲了如何通过状态转移的方法解决复杂的问题，用一个状态转移方程秒杀了 6 道股票买卖问题，现在想想，其实也不算难对吧？这已经属于动态规划问题中较困难的了。

关键就在于列举出所有可能的「状态」，然后想想怎么穷举更新这些「状态」。一般用一个多维 ` dp ` 数组储存这些状态，从 base case
开始向后推进，推进到最后的状态，就是我们想要的答案。想想这个过程，你是不是有点理解「动态规划」这个名词的意义了呢？

具体到股票买卖问题，我们发现了三个状态，使用了一个三维数组，无非还是穷举 + 更新，不过我们可以说的高大上一点，这叫「三维 DP」，怕不怕？这个大实话一说，立刻显得你高人一等，名利双收有没有，所以给个在看/分享吧，鼓励一下我。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**





# 一个方法团灭 LeetCode 打家劫舍问题



** ~

读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 198. 打家劫舍（简单） ](https://leetcode-cn.com/problems/house-robber)

[ 213. 打家劫舍II（中等） ](https://leetcode-cn.com/problems/house-robber-ii)

[ 337. 打家劫舍III（中等） ](https://leetcode-cn.com/problems/house-robber-iii)

**———–**

有读者私下问我 LeetCode 「打家劫舍」系列问题（英文版叫 House Robber）怎么做，我发现这一系列题目的点赞非常之高，是比较有代表性和技巧性的动态规划题目，今天就来聊聊这道题目。

打家劫舍系列总共有三道，难度设计非常合理，层层递进。第一道是比较标准的动态规划问题，而第二道融入了环形数组的条件，第三道更绝，把动态规划的自底向上和自顶向下解法和二叉树结合起来，我认为很有启发性。如果没做过的朋友，建议学习一下。

下面，我们从第一道开始分析。

**＿＿＿＿＿＿＿＿＿＿＿＿＿**

应合作方要求，本文不便在此发布，请扫码关注回复关键词「抢房子」查看：

![](https://labuladong.gitee.io/algo/images/qrcode.jpg)

# 一个方法团灭 nSum 问题




** ~

读完本文，你不仅学会了算法套路，还可以顺便去 LeetCode 上拿下如下题目：

[ 15. 三数之和（中等） ](https://leetcode-cn.com/problems/3sum/)

[ 18. 四数之和（中等） ](https://leetcode-cn.com/problems/4sum/)

**———–**

经常刷 LeetCode 的读者肯定知道鼎鼎有名的 ` twoSum ` 问题，我们旧文 [ twoSum 问题的核心思想

](https://labuladong.gitee.io/algo/2/20/64/) 就对 ` twoSum ` 的几个变种做了解析。

但是除了 ` twoSum ` 问题，LeetCode 上面还有 ` 3Sum ` ， ` 4Sum ` 问题，我估计以后出个 ` 5Sum ` ， `
6Sum ` 也不是不可能。

那么，对于这种问题有没有什么好办法用套路解决呢？

今天 labuladong 就由浅入深，层层推进，用一个函数来解决所有 ` nSum ` 类型的问题。

## 一、twoSum 问题

上篇文章 [ twoSum 问题的核心思想 ](https://labuladong.gitee.io/algo/2/20/64/) 写了力扣上的 2Sum 问题，题目要求返回的是索引，这里我来编一道 2Sum 题目：

如果假设输入一个数组 ` nums ` 和一个目标和 ` target ` ， **请你返回` nums ` 中能够凑出 ` target `
的两个元素的值 ** ，比如输入 ` nums = [1,3,5,6], target = 9 ` ，那么算法返回两个元素 ` [3,6] `
。可以假设只有且仅有一对儿元素可以凑出 ` target ` 。

我们可以先对 ` nums ` 排序，然后利用前文 [ 双指针技巧 ](https://labuladong.gitee.io/algo/2/20/55/) 写过的左右双指针技巧，从两端相向而行就行了：

```java
    vector<int> twoSum(vector<int>& nums, int target) {
        // 先对数组排序
        sort(nums.begin(), nums.end());
        // 左右指针
        int lo = 0, hi = nums.size() - 1;
        while (lo < hi) {
            int sum = nums[lo] + nums[hi];
            // 根据 sum 和 target 的比较，移动左右指针
            if (sum < target) {
                lo++;
            } else if (sum > target) {
                hi--;
            } else if (sum == target) {
                return {lo, hi};
            }
        }
        return {};
    }

```

这样就可以解决这个问题，不过 labuladong 要魔改一下题目，把这个题目变得更泛华，更困难一点。

题目告诉我们可以假设 ` nums ` 中有且只有一个答案，且需要我们返回对应元素的索引，现在修改这些条件： **` nums `
中可能有多对儿元素之和都等于 ` target ` ，请你的算法返回所有和为 ` target ` 的元素对儿，其中不能出现重复 ** 。

函数签名如下：

```java
    vector<vector<int>> twoSumTarget(vector<int>& nums, int target);

```

比如说输入为 ` nums = [1,3,1,2,2,3], target = 4 ` ，那么算法返回的结果就是： ` [[1,3],[2,2]] ` 。

对于修改后的问题，返回元素的值而不是对应索引并没什么难度，关键难点是现在可能有多个和为 ` target ` 的数对儿，还不能重复，比如上述例子中 `
[1,3] ` 和 ` [3,1] ` 就算重复，只能算一次。

首先，基本思路肯定还是排序加双指针：

```java
    vector<vector<int>> twoSumTarget(vector<int>& nums, int target {
        // 先对数组排序
        sort(nums.begin(), nums.end());
        vector<vector<int>> res;
        int lo = 0, hi = nums.size() - 1;
        while (lo < hi) {
            int sum = nums[lo] + nums[hi];
            // 根据 sum 和 target 的比较，移动左右指针
            if      (sum < target) lo++;
            else if (sum > target) hi--;
            else {
                res.push_back({lo, hi});
                lo++; hi--;
            }
        }
        return res;
    }

```

但是，这样实现会造成重复的结果，比如说 ` nums = [1,1,1,2,2,3,3], target = 4 ` ，得到的结果中 ` [1,3] `
肯定会重复。

出问题的地方在于 ` sum == target ` 条件的 if 分支，当给 ` res ` 加入一次结果后， ` lo ` 和 ` hi `
不应该只改变 1，而应该跳过所有重复的元素：

![](https://labuladong.gitee.io/algo/images/nSum/1.jpeg)

所以，可以对双指针的 while 循环做出如下修改：

```java
    while (lo < hi) {
        int sum = nums[lo] + nums[hi];
        // 记录索引 lo 和 hi 最初对应的值
        int left = nums[lo], right = nums[hi];
        if (sum < target)      lo++;
        else if (sum > target) hi--;
        else {
            res.push_back({left, right});
            // 跳过所有重复的元素
            while (lo < hi && nums[lo] == left) lo++;
            while (lo < hi && nums[hi] == right) hi--;
        }
    }

```

这样就可以保证一个答案只被添加一次，重复的结果都会被跳过，可以得到正确的答案。不过，受这个思路的启发，其实前两个 if 分支也是可以做一点效率优化，跳过相同的元素：

```java
    vector<vector<int>> twoSumTarget(vector<int>& nums, int target) {
        // nums 数组必须有序
        sort(nums.begin(), nums.end());
        int lo = 0, hi = nums.size() - 1;
        vector<vector<int>> res;
        while (lo < hi) {
            int sum = nums[lo] + nums[hi];
            int left = nums[lo], right = nums[hi];
            if (sum < target) {
                while (lo < hi && nums[lo] == left) lo++;
            } else if (sum > target) {
                while (lo < hi && nums[hi] == right) hi--;
            } else {
                res.push_back({left, right});
                while (lo < hi && nums[lo] == left) lo++;
                while (lo < hi && nums[hi] == right) hi--;
            }
        }
        return res;
    }

```

这样，一个通用化的 ` twoSum ` 函数就写出来了，请确保你理解了该算法的逻辑，我们后面解决 ` 3Sum ` 和 ` 4Sum `
的时候会复用这个函数。

这个函数的时间复杂度非常容易看出来，双指针操作的部分虽然有那么多 while 循环，但是时间复杂度还是 ` O(N) ` ，而排序的时间复杂度是 `
O(NlogN) ` ，所以这个函数的时间复杂度是 ` O(NlogN) ` 。

## 二、3Sum 问题

这是 LeetCode 第 15 题：

![](https://labuladong.gitee.io/algo/images/nSum/title2.jpg)

题目就是让我们找 ` nums ` 中和为 0 的三个元素，返回所有可能的三元组（triple），函数签名如下：

```java
    vector<vector<int>> threeSum(vector<int>& nums);

```

这样，我们再泛化一下题目，不要光和为 0 的三元组了，计算和为 ` target ` 的三元组吧，同上面的 ` twoSum ` 一样，也不允许重复的结果：

**＿＿＿＿＿＿＿＿＿＿＿＿＿**

应合作方要求，本文不便在此发布，请扫码关注回复关键词「nsum」查看：

![](https://labuladong.gitee.io/algo/images/qrcode.jpg)

# 提高刷题幸福感的小技巧


相信每个人都有过被代码的小 bug 搞得心态爆炸的经历，本文分享一个我最常用的简单技巧，可以大幅提升刷题的幸福感。

在这之前，首先回答一个问题，刷力扣题是直接在网页上刷比较好还是在本地 IDE 上刷比较好？

如果是牛客网笔试那种自己处理输入输出的判题形式，一定要在 IDE 上写，这个没啥说的，但 **像力扣这种判题形式，我个人偏好直接在网页上刷** ，原因有二：

**1、方便**

因为力扣有的数据结构是自定的，比如说 ` TreeNode ` ， ` ListNode ` 这种，在本地你还得把这个类 copy 过去。

而且在 IDE 上没办法测试，写完代码之后还得粘贴到网页上跑测试数据，那还不如直接网页上写呢。

算法又不是工程代码，量都比较小，IDE 的自动补全带来的收益基本可以忽略不计。

**2、实用**

到时候面试的时候，面试官给你出的算法题大都是希望你直接在网页上完成的，最好是边写边讲你的思路。

如果平时练习的时候就习惯没有 IDE 的自动补全，习惯手写代码大脑编译，到时候面试的时候写代码就能更快更从容。

之前我面快手的时候，有个面试官让我 [ 实现 LRU 算法 ](https://labuladong.gitee.io/algo/2/19/43/)
，我直接把双链表的实现、哈希链表的实现，在网页上全写出来了，而且一次无 bug 跑通，可以看到面试官惊讶的表情😂

我秋招能当 offer 收割机，很大程度上就是因为手写算法这一关超出面试官的预期，其实都是因为之前在网页上刷题练出来的。

接下来分享我觉得最常实用的干货技巧。

## 如何给算法 debug

代码的错误时无法避免的，有时候可能整个思路都错了，有时候可能是某些细节问题，比如 ` i ` 和 ` j ` 写反了，这种问题怎么排查？

我想一般的算法问题肯定不难排查，肉眼检查应该都没啥问题，再不济 ` print ` 打印一些关键变量的值，总能发现问题。

**比较让人头疼的的应该是递归算法的问题排查** 。

如果没有一定的经验，函数递归的过程很难被正确理解，所以这里就重点讲讲如何高效 debug 递归算法。

有的读者可能会说，把算法 copy 到 IDE 里面，然后打断点一步步跟着走不就行了吗？

这个方法肯定是可以的，但是之前的文章多次说过，递归函数最好从一个全局的角度理解，而不要跳进具体的细节。

如果你对递归还不够熟悉，没有一个全局的视角，这种一步步打断点的方式也容易把人绕进去。

**我的建议是直接在递归函数内部打印关键值，配合缩进，直观地观察递归函数执行情况** 。

最能提升我们 debug 效率的是缩进，除了解法函数，我们新定义一个函数 ` printIndent ` 和一个全局变量 ` count ` ：

```java
    // 全局变量，记录递归函数的递归层数
    int count = 0;
    
    // 输入 n，打印 n 个 tab 缩进
    void printIndent(int n) {
        for (int i = 0; i < n; i++) {
            printf("   ");
        }
    }

```

接下来，套路来了：

**在递归函数的开头，调用` printIndent(count++) ` 并打印关键变量；然后在所有 ` return ` 语句之前调用 `
printIndent(--count) ` 并打印返回值 ** 。

举个具体的例子，比如说上篇文章 [ 练琴时悟出的一个动态规划算法 ](https://labuladong.gitee.io/algo/3/25/86/) 中实现了一个递归的 ` dp `
函数，大致的结构如下：

```java
    int dp(string& ring, int i, string& key, int j) {
        /* base case */
        if (j == key.size()) {
            return 0;
        }
    
        /* 状态转移 */
        int res = INT_MAX;
        for (int k : charToIndex[key[j]]) {
            res = min(res, dp(ring, j, key, i + 1));
        }
    
        return res;
    }

```

这个递归的 ` dp ` 函数在我进行了 debug 之后，变成了这样：

```java
    int count = 0;
    void printIndent(int n) {
        for (int i = 0; i < n; i++) {
            printf("   ");
        }
    }
    
    int dp(string& ring, int i, string& key, int j) {
        // printIndent(count++);
        // printf("i = %d, j = %d\n", i, j);
        
        if (j == key.size()) {
            // printIndent(--count);
            // printf("return 0\n");
            return 0;
        }
        
        int res = INT_MAX;
        for (int k : charToIndex[key[j]]) {
            res = min(res, dp(ring, j, key, i + 1));
        }
        
        // printIndent(--count);
        // printf("return %d\n", res);
        return res;
    }

```

**就是在函数开头和所有` return ` 语句对应的地方加上一些打印代码 ** 。

如果去掉注释，执行一个测试用例，输出如下：

![](https://labuladong.gitee.io/algo/images/%e5%88%b7%e9%a2%98%e6%8a%80%e5%b7%a7/1.jpg)

这样，我们通过对比对应的缩进就能知道每次递归时输入的关键参数 ` i, j ` 的值，以及每次递归调用返回的结果是多少。

**最重要的是，这样可以比较直观地看出递归过程，你有没有发现这就是一棵递归树** ？

![](https://labuladong.gitee.io/algo/images/%e5%88%b7%e9%a2%98%e6%8a%80%e5%b7%a7/2.jpg)

前文 [ 动态规划套路详解 ](https://labuladong.gitee.io/algo/3/22/66/)
说过，理解递归函数最重要的就是画出递归树，这样打印一下，连递归树都不用自己画了，而且还能清晰地看出每次递归的返回值。

**可以说，这是对刷题「幸福感」提升最大的一个小技巧，比 IDE 打断点要高效** 。

好了，本文分享就到这里，马上快过年了，估计大家都无心学习了，不过刷题还是要坚持的，这就叫弯道超车，顺便实践一下这个技巧。

如果本文对你有帮助，点个在看，就会被推荐更多相似文章。